<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Tcp&amp;ip | 黑暗森林</title><meta name="author" content="BlackForest1990"><meta name="copyright" content="BlackForest1990"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="本文基于一个TCP&amp;IP项目进行学习，主要目的是来探索网络编程的奇妙。如下为本次学习的一些网络库和知识库。 代码参考：https:&#x2F;&#x2F;github.com&#x2F;saminiir&#x2F;level-ip 基础知识参考：https:&#x2F;&#x2F;beej-zhcn.netdpi.net&#x2F; TCP&amp;IP 协议层 网络接口层（Network Interface Layer）：  对应于OSI模型的物理层和数据">
<meta property="og:type" content="article">
<meta property="og:title" content="Tcp&amp;ip">
<meta property="og:url" content="https://blackforest1990.github.io/2024/01/16/Tcp-ip/index.html">
<meta property="og:site_name" content="黑暗森林">
<meta property="og:description" content="本文基于一个TCP&amp;IP项目进行学习，主要目的是来探索网络编程的奇妙。如下为本次学习的一些网络库和知识库。 代码参考：https:&#x2F;&#x2F;github.com&#x2F;saminiir&#x2F;level-ip 基础知识参考：https:&#x2F;&#x2F;beej-zhcn.netdpi.net&#x2F; TCP&amp;IP 协议层 网络接口层（Network Interface Layer）：  对应于OSI模型的物理层和数据">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blackforest1990.github.io/image/blackforest.jpg">
<meta property="article:published_time" content="2024-01-16T04:52:04.000Z">
<meta property="article:modified_time" content="2024-01-16T08:00:16.583Z">
<meta property="article:author" content="BlackForest1990">
<meta property="article:tag" content="how to make">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blackforest1990.github.io/image/blackforest.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blackforest1990.github.io/2024/01/16/Tcp-ip/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Tcp&ip',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-16 16:00:16'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="黑暗森林" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/image/blackforest.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="黑暗森林"><span class="site-name">黑暗森林</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Tcp&amp;ip</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-16T04:52:04.000Z" title="发表于 2024-01-16 12:52:04">2024-01-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-16T08:00:16.583Z" title="更新于 2024-01-16 16:00:16">2024-01-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Tcp&amp;ip"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>本文基于一个TCP&amp;IP项目进行学习，主要目的是来探索网络编程的奇妙。如下为本次学习的一些网络库和知识库。</p>
<p>代码参考：<a target="_blank" rel="noopener" href="https://github.com/saminiir/level-ip">https://github.com/saminiir/level-ip</a></p>
<p>基础知识参考：<a target="_blank" rel="noopener" href="https://beej-zhcn.netdpi.net/">https://beej-zhcn.netdpi.net/</a></p>
<h2 id="TCP-IP-协议层">TCP&amp;IP 协议层</h2>
<p><strong>网络接口层（Network Interface Layer）：</strong></p>
<ul>
<li>对应于OSI模型的物理层和数据链路层。负责将数据帧封装成比特流，并处理与物理网络设备的交互。</li>
</ul>
<p><strong>网络层（Internet Layer）：</strong></p>
<ul>
<li>对应于OSI模型的网络层。主要功能是在网络中路由数据包，为数据包选择最佳路径。IP协议是在这一层工作的关键协议。</li>
</ul>
<p><strong>传输层（Transport Layer）：</strong></p>
<ul>
<li>对应于OSI模型的传输层。负责端到端的通信，提供可靠的数据传输。TCP（传输控制协议）和UDP（用户数据报协议）是在这一层工作的协议。</li>
</ul>
<p><strong>应用层（Application Layer）：</strong></p>
<ul>
<li>对应于OSI模型的会话层、表示层和应用层。包含了各种应用程序，如HTTP（超文本传输协议）、FTP（文件传输协议）、SMTP（简单邮件传输协议）等。</li>
</ul>
<h2 id="Ethernet-ARP">Ethernet &amp; ARP</h2>
<h3 id="TAP设备">TAP设备</h3>
<p>为了拦截来自 Linux 内核的低级网络流量，我们将使用 Linux TAP 设备。简而言之，网络用户空间应用程序通常使用 TUN/TAP 设备分别操作 L3/L2 流量。在Linux中，TAP代表（Tap Virtual Network Device）。TAP设备是一种虚拟网络设备，通常用于模拟网络连接或实现虚拟专用网络（VPN）等网络功能。由于我们想要从第 2 层开始构建网络堆栈，因此我们需要一个 TAP 设备。我们像这样实例化它：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tun_alloc</span><span class="params">(<span class="type">char</span> *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifr</span>;</span></span><br><span class="line">    <span class="type">int</span> fd, err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( (fd = open(<span class="string">&quot;/dev/net/tap&quot;</span>, O_RDWR)) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Cannot open TUN/TAP dev\n&quot;</span></span><br><span class="line">                    <span class="string">&quot;Make sure one exists with &quot;</span> </span><br><span class="line">                    <span class="string">&quot;&#x27;$ mknod /dev/net/tap c 10 200&#x27;&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CLEAR(ifr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Flags: IFF_TUN   - TUN device (no Ethernet headers)</span></span><br><span class="line"><span class="comment">     *        IFF_TAP   - TAP device</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *        IFF_NO_PI - Do not provide packet information</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ifr.ifr_flags = IFF_TAP | IFF_NO_PI;</span><br><span class="line">    <span class="keyword">if</span>( *dev ) &#123;</span><br><span class="line">        <span class="built_in">strncpy</span>(ifr.ifr_name, dev, IFNAMSIZ);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( (err = ioctl(fd, TUNSETIFF, (<span class="type">void</span> *) &amp;ifr)) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">        perror(<span class="string">&quot;ERR: Could not ioctl tun&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(dev, ifr.ifr_name);</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这之后，返回的文件描述符<code>fd</code>可以用于读取和写入数据到虚拟设备的以太网缓冲区。<code>IFF_NO_PI</code>标志在这里非常关键，否则我们将得到不必要的数据包信息附加到以太网帧之前。</p>
<h3 id="以太网帧格式">以太网帧格式</h3>
<p>多种不同的以太网技术是连接<em>局域网</em>(LAN) 中计算机的支柱。</p>
<p>以太网标准：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/IEEE_802.3">https://en.wikipedia.org/wiki/IEEE_802.3</a></p>
<p>接下来，我们将看一下以太网帧头。可以将其声明为 C 结构体，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eth_hdr</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span>  dmac[<span class="number">6</span>];</span><br><span class="line">    <span class="type">uint8_t</span>  smac[<span class="number">6</span>];</span><br><span class="line">    <span class="type">uint16_t</span> ethertype;</span><br><span class="line">    <span class="type">uint8_t</span>  payload[];</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<p><code>dmac smac</code>: 它们包含通信双方的 MAC 地址（分别是目标和源）。</p>
<p>重载字段<code>ethertype</code>是一个 2 个八位字节的字段，根据其值，指示有效负载的长度或类型。具体来说，如果该字段的值大于或等于1536，则该字段包含有效负载的类型（例如IPv4、ARP）。如果该值小于该值，则它包含有效负载的长度。</p>
<p>在类型字段之后，以太网帧可能有几个不同的<em>标签。<em>这些标签可用于描述帧的</em>虚拟 LAN</em> (VLAN) 或<em>服务质量</em>(QoS) 类型。以太网帧标签被排除在我们的实现之外，因此相应的字段也不会出现在我们的协议声明中。</p>
<p><code>payload</code>包含指向以太网帧有效负载的指针。在我们的例子中，这将包含 ARP 或 IPv4 数据包。如果有效负载长度小于所需的最小48字节（不含标签），则将填充字节附加到有效负载的末尾以满足要求。</p>
<p>我们还包含<code>if_ether.h</code>Linux 标头来提供以太类型及其十六进制值之间的映射。</p>
<p>最后，以太网帧格式末尾还包括帧校验序列字段，该字段与循环冗余校验（CRC）一起用于检查帧的完整性。我们将在实现中省略对该字段的处理。</p>
<p><code>__attribute__((packed))</code>：这是一个GCC特有的属性，用于告诉编译器以最小的字节对齐方式来布局结构体，确保没有额外的填充字节。这对于网络协议帧头等需要严格字节对齐的结构体来说是重要的。</p>
<h3 id="以太网帧解析">以太网帧解析</h3>
<p>解析和处理传入以太网帧的总体场景非常简单：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tun_read(buf, BUFLEN) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    print_error(<span class="string">&quot;ERR: Read from tun_fd: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eth_hdr</span> *<span class="title">hdr</span> =</span> init_eth_hdr(buf);</span><br><span class="line"></span><br><span class="line">handle_frame(&amp;netdev, hdr);</span><br></pre></td></tr></table></figure>
<h3 id="地址解析协议">地址解析协议</h3>
<p>地址解析协议（ARP）用于将48位以太网地址（MAC地址）动态映射到协议地址（例如IPv4地址）。这里的关键是，通过 ARP，可以使用多种不同的 L3 协议：不仅是 IPv4，还有其他协议。通常的情况是知道 LAN 中某些服务的 IP 地址，但要建立实际通信，还需要知道硬件地址 (MAC)。因此，ARP用于广播和查询网络，要求IP地址的所有者报告其硬件地址。</p>
<p>ARP数据包格式比较简单：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arp_hdr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> hwtype;</span><br><span class="line">    <span class="type">uint16_t</span> protype;</span><br><span class="line">    <span class="type">uint8_t</span> hwsize;</span><br><span class="line">    <span class="type">uint8_t</span> prosize;</span><br><span class="line">    <span class="type">uint16_t</span> opcode;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data[];</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<p>ARP 标头 ( <code>arp_hdr</code>) 包含 2 个八位字节<code>hwtype</code>，它确定所使用的链路层类型。在我们的例子中，这是以太网，实际值为<code>0x0001</code>。</p>
<p>2 个八位字节<code>protype</code>字段指示协议类型。在我们的例子中，这是 IPv4，通过值 进行通信<code>0x0800</code>。</p>
<p><code>hwsize</code>（硬件地址长度）： 一个8位的整数，表示硬件地址的长度，以字节为单位</p>
<p><code>prosize</code>（协议地址长度）：一个8位的整数，表示协议地址的长度，以字节为单位。</p>
<p>2 个八位字节字段<code>opcode</code>声明 ARP 消息的类型。它可以是 ARP 请求 (1)、ARP 应答 (2)、RARP 请求 (3) 或 RARP 应答 (4)。</p>
<p>该<code>data</code>字段包含 ARP 消息的实际负载，在我们的例子中，它将包含 IPv4 特定信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arp_ipv4</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> smac[<span class="number">6</span>];</span><br><span class="line">    <span class="type">uint32_t</span> sip;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> dmac[<span class="number">6</span>];</span><br><span class="line">    <span class="type">uint32_t</span> dip;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<p>这些字段非常不言自明。<code>smac dmac</code>分别包含发送方和接收方的 6 字节 MAC 地址。<code>sip</code>和<code>dip</code>分别包含发送者和接收者的 IP 地址。</p>
<h3 id="地址解析算法">地址解析算法</h3>
<ol>
<li><strong>检查硬件类型（<code>ar$hrd</code>）：</strong>
<ul>
<li>如果硬件类型存在（几乎肯定存在），继续。</li>
</ul>
</li>
<li><strong>可选地检查硬件长度（<code>ar$hln</code>）：</strong></li>
<li><strong>检查协议类型（<code>ar$pro</code>）：</strong>
<ul>
<li>如果协议类型存在，继续。</li>
</ul>
</li>
<li><strong>可选地检查协议长度（<code>ar$pln</code>）：</strong></li>
<li><strong>初始化<code>Merge_flag</code>为false：</strong></li>
<li><strong>检查转换表中是否存在 <code>&lt;协议类型，发送者协议地址&gt;</code> 这一对：</strong>
<ul>
<li>如果已存在：
<ul>
<li>使用数据包中的新信息更新该条目的发送者硬件地址字段。</li>
<li>将 <code>Merge_flag</code> 设置为 true。</li>
</ul>
</li>
</ul>
</li>
<li><strong>检查当前设备是否是目标协议地址：</strong>
<ul>
<li>如果是：
<ul>
<li>如果 <code>Merge_flag</code> 为false，则将 <code>&lt;协议类型，发送者协议地址，发送者硬件地址&gt;</code> 添加到转换表中。</li>
</ul>
</li>
</ul>
</li>
<li><strong>检查操作码是否是ARP请求 (<code>ares_op$REQUEST</code>)：</strong>
<ul>
<li>如果是：
<ul>
<li>交换硬件和协议字段，将本地硬件和协议地址放入发送者字段。</li>
<li>将 <code>ar$op</code> 字段设置为 <code>ares_op$REPLY</code>。</li>
<li>将数据包发送到在同一硬件上收到请求时的新目标硬件地址。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>这个算法描述了在接收到ARP请求时的处理流程，包括更新转换表、响应ARP请求和发送ARP回复。</p>
<p><code>translation table</code>用于存储 ARP 结果，以便主机只需查找其缓存中是否已有该条目即可。这可以避免向网络发送冗余 ARP 请求的垃圾邮件。</p>
<h2 id="IPv4-and-ICMPv4">IPv4 and ICMPv4</h2>
<h3 id="IPv4">IPv4</h3>
<p>我们的实现中的下一层 (L3)（在以太网帧之后）处理将数据传送到目的地的情况。也就是说，互联网协议(IP) 的发明是为了为 TCP 和 UDP 等传输协议提供基础。它是无连接的，这意味着与 TCP 不同，所有数据报在网络堆栈中都是相互独立处理的。这也意味着 IP 数据报可能会无序到达。</p>
<p>此外，IP 并不能保证成功传输。这是协议设计者有意识的选择，因为 IP 旨在为同样不保证传输的协议提供基础。UDP 就是这样一种协议。如果通信双方之间需要可靠性，则可以在 IP 之上使用 TCP 等协议。在这种情况下，更高级别的协议负责检测丢失的数据并确保所有数据均已传输。</p>
<h4 id="Header">Header</h4>
<p>IPv4 标头的长度通常为 20 个八位位组。标头可以包含尾随选项，但我们的实现中省略了它们。字段的含义相对简单，可以用 C 结构体来描述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> ihl : <span class="number">4</span>; <span class="comment">/* <span class="doctag">TODO:</span> Support Big Endian hosts */</span></span><br><span class="line">    <span class="type">uint8_t</span> version : <span class="number">4</span>;</span><br><span class="line">    <span class="type">uint8_t</span> tos;</span><br><span class="line">    <span class="type">uint16_t</span> len;</span><br><span class="line">    <span class="type">uint16_t</span> id;</span><br><span class="line">    <span class="type">uint16_t</span> frag_offset;</span><br><span class="line">    <span class="type">uint8_t</span> ttl;</span><br><span class="line">    <span class="type">uint8_t</span> proto;</span><br><span class="line">    <span class="type">uint16_t</span> csum;</span><br><span class="line">    <span class="type">uint32_t</span> saddr;</span><br><span class="line">    <span class="type">uint32_t</span> daddr;</span><br><span class="line">    <span class="type">uint8_t</span> data[];</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<ul>
<li>4 位字段<code>version</code>指示 Internet 标头的格式。在我们的例子中，IPv4 的值为 4。</li>
<li>互联网报头长度字段<code>ihl</code>的长度同样为 4 位，由于该字段的大小为 4 位，因此它最多只能容纳 15。因此，IP 标头的最大长度为 60 个八位字节（15 乘以 32 除以 8）。</li>
<li>服务类型字段源自<code>tos</code>为IP 数据报的服务质量。</li>
<li>总长度字段<code>len</code> 传达整个 IP数据报的长度。由于它是 16 位字段，因此最大长度为 65535 字节。大型 IP 数据报会被分割成更小的数据报，以满足不同通信接口的最大传输单元(MTU)。</li>
<li><code>id</code>字段用于索引数据报，最终用于重组分片的IP数据报。该字段的值只是一个由发送方递增的计数器。反过来，接收方知道如何对传入的片段进行排序。</li>
<li><code>flags</code>字段定义了数据报的各种控制标志。具体来说，发送方可以指定数据报是否允许分片，是否是最后一个分片，或者是否还有更多分片传入。</li>
<li>片段偏移字段<code>frag_offset</code>指示片段在数据报中的位置。当然，第一个数据报的索引设置为 0。</li>
<li><code>ttl</code>是一个常见属性，数据报的生命周期。它通常由原始发送方设置为 64，每个接收方都会将该计数器减 1。当它达到零时，数据报将被丢弃，并且可能会回复一条 ICMP 消息以指示错误。</li>
<li>该<code>proto</code>字段为数据报提供了在其有效负载中携带其他协议的固有能力。该字段通常包含 16 (UDP) 或 6 (TCP) 等值，仅用于向接收方传达实际数据的类型。</li>
<li>报头校验和字段<code>csum</code>，用于验证 IP 报头的完整性。</li>
<li>最后，<code>saddr</code>和<code>daddr</code>字段分别指示数据报的源地址和目标地址。</li>
</ul>
<h4 id="Internet-Checksum">Internet Checksum</h4>
<p>互联网校验和字段用于检查 IP 数据报的完整性。算法的实际代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">sum_every_16bits</span><span class="params">(<span class="type">void</span> *addr, <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">uint32_t</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint16_t</span> * ptr = addr;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>( count &gt; <span class="number">1</span> )  &#123;</span><br><span class="line">        <span class="comment">/*  This is the inner loop */</span></span><br><span class="line">        sum += * ptr++;</span><br><span class="line">        count -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  Add left-over byte, if any */</span></span><br><span class="line">    <span class="keyword">if</span>( count &gt; <span class="number">0</span> )</span><br><span class="line">        sum += * (<span class="type">uint8_t</span> *) ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">checksum</span><span class="params">(<span class="type">void</span> *addr, <span class="type">int</span> count, <span class="type">int</span> start_sum)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Compute Internet Checksum for &quot;count&quot; bytes</span></span><br><span class="line"><span class="comment">     *         beginning at location &quot;addr&quot;.</span></span><br><span class="line"><span class="comment">     * Taken from https://tools.ietf.org/html/rfc1071</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint32_t</span> sum = start_sum;</span><br><span class="line"></span><br><span class="line">    sum += sum_every_16bits(addr, count);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*  Fold 32-bit sum to 16 bits */</span></span><br><span class="line">    <span class="keyword">while</span> (sum&gt;&gt;<span class="number">16</span>)</span><br><span class="line">        sum = (sum &amp; <span class="number">0xffff</span>) + (sum &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ~sum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>sum_every_16bits</code> 函数：
<ul>
<li>参数 <code>void *addr</code> 是指向内存地址的指针，表示数据的起始地址。</li>
<li>参数 <code>int count</code> 是要计算校验和的数据字节数。</li>
<li>函数使用指针 <code>ptr</code> 迭代访问数据，每次累加两个字节的值到 <code>sum</code> 中，直到处理完所有的字节。</li>
<li>如果数据字节数是奇数，最后一个字节单独累加。</li>
<li>返回一个 32 位整数，表示所有 16 位字的和。</li>
</ul>
</li>
<li><code>checksum</code> 函数：
<ul>
<li>参数 <code>void *addr</code> 是数据的起始地址。</li>
<li>参数 <code>int count</code> 是要计算校验和的数据字节数。</li>
<li>参数 <code>int start_sum</code> 是初始的校验和值。</li>
<li>函数调用 <code>sum_every_16bits</code> 函数计算数据的 16 位字的和，然后将其加到初始校验和值 <code>start_sum</code> 中。</li>
<li>然后，使用一个循环将 32 位的和折叠为 16 位，直到和不再超过 16 位。</li>
<li>最后，返回计算得到的校验和的一位补码。</li>
</ul>
</li>
</ol>
<p>这些函数的目的是按照 RFC1071 中描述的方式计算 Internet 校验和。计算校验和的过程涉及将所有 16 位字相加，然后将 32 位和折叠为 16 位。最终，返回的值是校验和的一位补码。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blackforest1990.github.io">BlackForest1990</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blackforest1990.github.io/2024/01/16/Tcp-ip/">https://blackforest1990.github.io/2024/01/16/Tcp-ip/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blackforest1990.github.io" target="_blank">黑暗森林</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/how-to-make/">how to make</a></div><div class="post_share"><div class="social-share" data-image="/image/blackforest.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>谢谢支持</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechatpay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechatpay.jpg"/></a><div class="post-qr-code-desc"></div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/01/09/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" title="万历十五年读书笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">万历十五年读书笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-IP-%E5%8D%8F%E8%AE%AE%E5%B1%82"><span class="toc-number">1.</span> <span class="toc-text">TCP&amp;IP 协议层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ethernet-ARP"><span class="toc-number">2.</span> <span class="toc-text">Ethernet &amp; ARP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TAP%E8%AE%BE%E5%A4%87"><span class="toc-number">2.1.</span> <span class="toc-text">TAP设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">以太网帧格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E8%A7%A3%E6%9E%90"><span class="toc-number">2.3.</span> <span class="toc-text">以太网帧解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.4.</span> <span class="toc-text">地址解析协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">2.5.</span> <span class="toc-text">地址解析算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IPv4-and-ICMPv4"><span class="toc-number">3.</span> <span class="toc-text">IPv4 and ICMPv4</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IPv4"><span class="toc-number">3.1.</span> <span class="toc-text">IPv4</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Header"><span class="toc-number">3.1.1.</span> <span class="toc-text">Header</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Internet-Checksum"><span class="toc-number">3.1.2.</span> <span class="toc-text">Internet Checksum</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By BlackForest1990</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">如果只允许一种声音存在，那么，唯一存在的那个声音就是谎言。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>