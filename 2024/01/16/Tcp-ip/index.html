<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Tcp&amp;ip | 黑暗森林</title><meta name="author" content="BlackForest1990"><meta name="copyright" content="BlackForest1990"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="本文基于一个TCP&amp;IP项目进行学习，主要目的是来探索网络编程的奇妙。如下为本次学习的一些网络库和知识库。 代码参考：https:&#x2F;&#x2F;github.com&#x2F;saminiir&#x2F;level-ip 基础知识参考：https:&#x2F;&#x2F;beej-zhcn.netdpi.net&#x2F; TCP&amp;IP 协议层 网络接口层（Network Interface Layer）：  对应于OSI模型的物理层和数据">
<meta property="og:type" content="article">
<meta property="og:title" content="Tcp&amp;ip">
<meta property="og:url" content="https://blackforest1990.github.io/2024/01/16/Tcp-ip/index.html">
<meta property="og:site_name" content="黑暗森林">
<meta property="og:description" content="本文基于一个TCP&amp;IP项目进行学习，主要目的是来探索网络编程的奇妙。如下为本次学习的一些网络库和知识库。 代码参考：https:&#x2F;&#x2F;github.com&#x2F;saminiir&#x2F;level-ip 基础知识参考：https:&#x2F;&#x2F;beej-zhcn.netdpi.net&#x2F; TCP&amp;IP 协议层 网络接口层（Network Interface Layer）：  对应于OSI模型的物理层和数据">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blackforest1990.github.io/image/blackforest.jpg">
<meta property="article:published_time" content="2024-01-16T04:52:04.000Z">
<meta property="article:modified_time" content="2024-01-23T06:28:32.592Z">
<meta property="article:author" content="BlackForest1990">
<meta property="article:tag" content="how to make">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blackforest1990.github.io/image/blackforest.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blackforest1990.github.io/2024/01/16/Tcp-ip/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Tcp&ip',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-23 14:28:32'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="黑暗森林" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/image/blackforest.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="黑暗森林"><span class="site-name">黑暗森林</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Tcp&amp;ip</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-16T04:52:04.000Z" title="发表于 2024-01-16 12:52:04">2024-01-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-23T06:28:32.592Z" title="更新于 2024-01-23 14:28:32">2024-01-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Tcp&amp;ip"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>本文基于一个TCP&amp;IP项目进行学习，主要目的是来探索网络编程的奇妙。如下为本次学习的一些网络库和知识库。</p>
<p>代码参考：<a target="_blank" rel="noopener" href="https://github.com/saminiir/level-ip">https://github.com/saminiir/level-ip</a></p>
<p>基础知识参考：<a target="_blank" rel="noopener" href="https://beej-zhcn.netdpi.net/">https://beej-zhcn.netdpi.net/</a></p>
<h2 id="TCP-IP-协议层">TCP&amp;IP 协议层</h2>
<p><strong>网络接口层（Network Interface Layer）：</strong></p>
<ul>
<li>对应于OSI模型的物理层和数据链路层。负责将数据帧封装成比特流，并处理与物理网络设备的交互。</li>
</ul>
<p><strong>网络层（Internet Layer）：</strong></p>
<ul>
<li>对应于OSI模型的网络层。主要功能是在网络中路由数据包，为数据包选择最佳路径。IP协议是在这一层工作的关键协议。</li>
</ul>
<p><strong>传输层（Transport Layer）：</strong></p>
<ul>
<li>对应于OSI模型的传输层。负责端到端的通信，提供可靠的数据传输。TCP（传输控制协议）和UDP（用户数据报协议）是在这一层工作的协议。</li>
</ul>
<p><strong>应用层（Application Layer）：</strong></p>
<ul>
<li>对应于OSI模型的会话层、表示层和应用层。包含了各种应用程序，如HTTP（超文本传输协议）、FTP（文件传输协议）、SMTP（简单邮件传输协议）等。</li>
</ul>
<h2 id="Ethernet-ARP">Ethernet &amp; ARP</h2>
<h3 id="TAP设备">TAP设备</h3>
<p>为了拦截来自 Linux 内核的低级网络流量，我们将使用 Linux TAP 设备。简而言之，网络用户空间应用程序通常使用 TUN/TAP 设备分别操作 L3/L2 流量。在Linux中，TAP代表（Tap Virtual Network Device）。TAP设备是一种虚拟网络设备，通常用于模拟网络连接或实现虚拟专用网络（VPN）等网络功能。由于我们想要从第 2 层开始构建网络堆栈，因此我们需要一个 TAP 设备。我们像这样实例化它：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tun_alloc</span><span class="params">(<span class="type">char</span> *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifr</span>;</span></span><br><span class="line">    <span class="type">int</span> fd, err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( (fd = open(<span class="string">&quot;/dev/net/tap&quot;</span>, O_RDWR)) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Cannot open TUN/TAP dev\n&quot;</span></span><br><span class="line">                    <span class="string">&quot;Make sure one exists with &quot;</span> </span><br><span class="line">                    <span class="string">&quot;&#x27;$ mknod /dev/net/tap c 10 200&#x27;&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CLEAR(ifr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Flags: IFF_TUN   - TUN device (no Ethernet headers)</span></span><br><span class="line"><span class="comment">     *        IFF_TAP   - TAP device</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *        IFF_NO_PI - Do not provide packet information</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ifr.ifr_flags = IFF_TAP | IFF_NO_PI;</span><br><span class="line">    <span class="keyword">if</span>( *dev ) &#123;</span><br><span class="line">        <span class="built_in">strncpy</span>(ifr.ifr_name, dev, IFNAMSIZ);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( (err = ioctl(fd, TUNSETIFF, (<span class="type">void</span> *) &amp;ifr)) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">        perror(<span class="string">&quot;ERR: Could not ioctl tun&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(dev, ifr.ifr_name);</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这之后，返回的文件描述符<code>fd</code>可以用于读取和写入数据到虚拟设备的以太网缓冲区。<code>IFF_NO_PI</code>标志在这里非常关键，否则我们将得到不必要的数据包信息附加到以太网帧之前。</p>
<h3 id="以太网帧格式">以太网帧格式</h3>
<p>多种不同的以太网技术是连接<em>局域网</em>(LAN) 中计算机的支柱。</p>
<p>以太网标准：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/IEEE_802.3">https://en.wikipedia.org/wiki/IEEE_802.3</a></p>
<p>接下来，我们将看一下以太网帧头。可以将其声明为 C 结构体，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eth_hdr</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span>  dmac[<span class="number">6</span>];</span><br><span class="line">    <span class="type">uint8_t</span>  smac[<span class="number">6</span>];</span><br><span class="line">    <span class="type">uint16_t</span> ethertype;</span><br><span class="line">    <span class="type">uint8_t</span>  payload[];</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<p><code>dmac smac</code>: 它们包含通信双方的 MAC 地址（分别是目标和源）。</p>
<p>重载字段<code>ethertype</code>是一个 2 个八位字节的字段，根据其值，指示有效负载的长度或类型。具体来说，如果该字段的值大于或等于1536，则该字段包含有效负载的类型（例如IPv4、ARP）。如果该值小于该值，则它包含有效负载的长度。</p>
<p>在类型字段之后，以太网帧可能有几个不同的<em>标签。<em>这些标签可用于描述帧的</em>虚拟 LAN</em> (VLAN) 或<em>服务质量</em>(QoS) 类型。以太网帧标签被排除在我们的实现之外，因此相应的字段也不会出现在我们的协议声明中。</p>
<p><code>payload</code>包含指向以太网帧有效负载的指针。在我们的例子中，这将包含 ARP 或 IPv4 数据包。如果有效负载长度小于所需的最小48字节（不含标签），则将填充字节附加到有效负载的末尾以满足要求。</p>
<p>我们还包含<code>if_ether.h</code>Linux 标头来提供以太类型及其十六进制值之间的映射。</p>
<p>最后，以太网帧格式末尾还包括帧校验序列字段，该字段与循环冗余校验（CRC）一起用于检查帧的完整性。我们将在实现中省略对该字段的处理。</p>
<p><code>__attribute__((packed))</code>：这是一个GCC特有的属性，用于告诉编译器以最小的字节对齐方式来布局结构体，确保没有额外的填充字节。这对于网络协议帧头等需要严格字节对齐的结构体来说是重要的。</p>
<h3 id="以太网帧解析">以太网帧解析</h3>
<p>解析和处理传入以太网帧的总体场景非常简单：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tun_read(buf, BUFLEN) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    print_error(<span class="string">&quot;ERR: Read from tun_fd: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eth_hdr</span> *<span class="title">hdr</span> =</span> init_eth_hdr(buf);</span><br><span class="line"></span><br><span class="line">handle_frame(&amp;netdev, hdr);</span><br></pre></td></tr></table></figure>
<h3 id="地址解析协议">地址解析协议</h3>
<p>地址解析协议（ARP）用于将48位以太网地址（MAC地址）动态映射到协议地址（例如IPv4地址）。这里的关键是，通过 ARP，可以使用多种不同的 L3 协议：不仅是 IPv4，还有其他协议。通常的情况是知道 LAN 中某些服务的 IP 地址，但要建立实际通信，还需要知道硬件地址 (MAC)。因此，ARP用于广播和查询网络，要求IP地址的所有者报告其硬件地址。</p>
<p>ARP数据包格式比较简单：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arp_hdr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> hwtype;</span><br><span class="line">    <span class="type">uint16_t</span> protype;</span><br><span class="line">    <span class="type">uint8_t</span> hwsize;</span><br><span class="line">    <span class="type">uint8_t</span> prosize;</span><br><span class="line">    <span class="type">uint16_t</span> opcode;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data[];</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<p>ARP 标头 ( <code>arp_hdr</code>) 包含 2 个八位字节<code>hwtype</code>，它确定所使用的链路层类型。在我们的例子中，这是以太网，实际值为<code>0x0001</code>。</p>
<p>2 个八位字节<code>protype</code>字段指示协议类型。在我们的例子中，这是 IPv4，通过值 进行通信<code>0x0800</code>。</p>
<p><code>hwsize</code>（硬件地址长度）： 一个8位的整数，表示硬件地址的长度，以字节为单位</p>
<p><code>prosize</code>（协议地址长度）：一个8位的整数，表示协议地址的长度，以字节为单位。</p>
<p>2 个八位字节字段<code>opcode</code>声明 ARP 消息的类型。它可以是 ARP 请求 (1)、ARP 应答 (2)、RARP 请求 (3) 或 RARP 应答 (4)。</p>
<p>该<code>data</code>字段包含 ARP 消息的实际负载，在我们的例子中，它将包含 IPv4 特定信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arp_ipv4</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> smac[<span class="number">6</span>];</span><br><span class="line">    <span class="type">uint32_t</span> sip;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> dmac[<span class="number">6</span>];</span><br><span class="line">    <span class="type">uint32_t</span> dip;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<p>这些字段非常不言自明。<code>smac dmac</code>分别包含发送方和接收方的 6 字节 MAC 地址。<code>sip</code>和<code>dip</code>分别包含发送者和接收者的 IP 地址。</p>
<h3 id="地址解析算法">地址解析算法</h3>
<ol>
<li><strong>检查硬件类型（<code>ar$hrd</code>）：</strong>
<ul>
<li>如果硬件类型存在（几乎肯定存在），继续。</li>
</ul>
</li>
<li><strong>可选地检查硬件长度（<code>ar$hln</code>）：</strong></li>
<li><strong>检查协议类型（<code>ar$pro</code>）：</strong>
<ul>
<li>如果协议类型存在，继续。</li>
</ul>
</li>
<li><strong>可选地检查协议长度（<code>ar$pln</code>）：</strong></li>
<li><strong>初始化<code>Merge_flag</code>为false：</strong></li>
<li><strong>检查转换表中是否存在 <code>&lt;协议类型，发送者协议地址&gt;</code> 这一对：</strong>
<ul>
<li>如果已存在：
<ul>
<li>使用数据包中的新信息更新该条目的发送者硬件地址字段。</li>
<li>将 <code>Merge_flag</code> 设置为 true。</li>
</ul>
</li>
</ul>
</li>
<li><strong>检查当前设备是否是目标协议地址：</strong>
<ul>
<li>如果是：
<ul>
<li>如果 <code>Merge_flag</code> 为false，则将 <code>&lt;协议类型，发送者协议地址，发送者硬件地址&gt;</code> 添加到转换表中。</li>
</ul>
</li>
</ul>
</li>
<li><strong>检查操作码是否是ARP请求 (<code>ares_op$REQUEST</code>)：</strong>
<ul>
<li>如果是：
<ul>
<li>交换硬件和协议字段，将本地硬件和协议地址放入发送者字段。</li>
<li>将 <code>ar$op</code> 字段设置为 <code>ares_op$REPLY</code>。</li>
<li>将数据包发送到在同一硬件上收到请求时的新目标硬件地址。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>这个算法描述了在接收到ARP请求时的处理流程，包括更新转换表、响应ARP请求和发送ARP回复。</p>
<p><code>translation table</code>用于存储 ARP 结果，以便主机只需查找其缓存中是否已有该条目即可。这可以避免向网络发送冗余 ARP 请求的垃圾邮件。</p>
<h2 id="IPv4-and-ICMPv4">IPv4 and ICMPv4</h2>
<h3 id="IPv4">IPv4</h3>
<p>我们的实现中的下一层 (L3)（在以太网帧之后）处理将数据传送到目的地的情况。也就是说，互联网协议(IP) 的发明是为了为 TCP 和 UDP 等传输协议提供基础。它是无连接的，这意味着与 TCP 不同，所有数据报在网络堆栈中都是相互独立处理的。这也意味着 IP 数据报可能会无序到达。</p>
<p>此外，IP 并不能保证成功传输。这是协议设计者有意识的选择，因为 IP 旨在为同样不保证传输的协议提供基础。UDP 就是这样一种协议。如果通信双方之间需要可靠性，则可以在 IP 之上使用 TCP 等协议。在这种情况下，更高级别的协议负责检测丢失的数据并确保所有数据均已传输。</p>
<h4 id="Header">Header</h4>
<p>IPv4 标头的长度通常为 20 个八位位组。标头可以包含尾随选项，但我们的实现中省略了它们。字段的含义相对简单，可以用 C 结构体来描述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> ihl : <span class="number">4</span>; <span class="comment">/* <span class="doctag">TODO:</span> Support Big Endian hosts */</span></span><br><span class="line">    <span class="type">uint8_t</span> version : <span class="number">4</span>;</span><br><span class="line">    <span class="type">uint8_t</span> tos;</span><br><span class="line">    <span class="type">uint16_t</span> len;</span><br><span class="line">    <span class="type">uint16_t</span> id;</span><br><span class="line">    <span class="type">uint16_t</span> frag_offset;</span><br><span class="line">    <span class="type">uint8_t</span> ttl;</span><br><span class="line">    <span class="type">uint8_t</span> proto;</span><br><span class="line">    <span class="type">uint16_t</span> csum;</span><br><span class="line">    <span class="type">uint32_t</span> saddr;</span><br><span class="line">    <span class="type">uint32_t</span> daddr;</span><br><span class="line">    <span class="type">uint8_t</span> </span><br><span class="line">        [];</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<ul>
<li>4 位字段<code>version</code>指示 Internet 标头的格式。在我们的例子中，IPv4 的值为 4。</li>
<li>互联网报头长度字段<code>ihl</code>的长度同样为 4 位，由于该字段的大小为 4 位，因此它最多只能容纳 15。因此，IP 标头的最大长度为 60 个八位字节（15 乘以 32 除以 8）。</li>
<li>服务类型字段源自<code>tos</code>为IP 数据报的服务质量。</li>
<li>总长度字段<code>len</code> 传达整个 IP数据报的长度。由于它是 16 位字段，因此最大长度为 65535 字节。大型 IP 数据报会被分割成更小的数据报，以满足不同通信接口的最大传输单元(MTU)。</li>
<li><code>id</code>字段用于索引数据报，最终用于重组分片的IP数据报。该字段的值只是一个由发送方递增的计数器。反过来，接收方知道如何对传入的片段进行排序。</li>
<li><code>flags</code>字段定义了数据报的各种控制标志。具体来说，发送方可以指定数据报是否允许分片，是否是最后一个分片，或者是否还有更多分片传入。</li>
<li>片段偏移字段<code>frag_offset</code>指示片段在数据报中的位置。当然，第一个数据报的索引设置为 0。</li>
<li><code>ttl</code>是一个常见属性，数据报的生命周期。它通常由原始发送方设置为 64，每个接收方都会将该计数器减 1。当它达到零时，数据报将被丢弃，并且可能会回复一条 ICMP 消息以指示错误。</li>
<li>该<code>proto</code>字段为数据报提供了在其有效负载中携带其他协议的固有能力。该字段通常包含 16 (UDP) 或 6 (TCP) 等值，仅用于向接收方传达实际数据的类型。</li>
<li>报头校验和字段<code>csum</code>，用于验证 IP 报头的完整性。</li>
<li>最后，<code>saddr</code>和<code>daddr</code>字段分别指示数据报的源地址和目标地址。</li>
</ul>
<h4 id="Internet-Checksum">Internet Checksum</h4>
<p>互联网校验和字段用于检查 IP 数据报的完整性。算法的实际代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">sum_every_16bits</span><span class="params">(<span class="type">void</span> *addr, <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">uint32_t</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint16_t</span> * ptr = addr;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>( count &gt; <span class="number">1</span> )  &#123;</span><br><span class="line">        <span class="comment">/*  This is the inner loop */</span></span><br><span class="line">        sum += * ptr++;</span><br><span class="line">        count -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  Add left-over byte, if any */</span></span><br><span class="line">    <span class="keyword">if</span>( count &gt; <span class="number">0</span> )</span><br><span class="line">        sum += * (<span class="type">uint8_t</span> *) ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">checksum</span><span class="params">(<span class="type">void</span> *addr, <span class="type">int</span> count, <span class="type">int</span> start_sum)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Compute Internet Checksum for &quot;count&quot; bytes</span></span><br><span class="line"><span class="comment">     *         beginning at location &quot;addr&quot;.</span></span><br><span class="line"><span class="comment">     * Taken from https://tools.ietf.org/html/rfc1071</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint32_t</span> sum = start_sum;</span><br><span class="line"></span><br><span class="line">    sum += sum_every_16bits(addr, count);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*  Fold 32-bit sum to 16 bits */</span></span><br><span class="line">    <span class="keyword">while</span> (sum&gt;&gt;<span class="number">16</span>)</span><br><span class="line">        sum = (sum &amp; <span class="number">0xffff</span>) + (sum &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ~sum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>sum_every_16bits</code> 函数：
<ul>
<li>参数 <code>void *addr</code> 是指向内存地址的指针，表示数据的起始地址。</li>
<li>参数 <code>int count</code> 是要计算校验和的数据字节数。</li>
<li>函数使用指针 <code>ptr</code> 迭代访问数据，每次累加两个字节的值到 <code>sum</code> 中，直到处理完所有的字节。</li>
<li>如果数据字节数是奇数，最后一个字节单独累加。</li>
<li>返回一个 32 位整数，表示所有 16 位字的和。</li>
</ul>
</li>
<li><code>checksum</code> 函数：
<ul>
<li>参数 <code>void *addr</code> 是数据的起始地址。</li>
<li>参数 <code>int count</code> 是要计算校验和的数据字节数。</li>
<li>参数 <code>int start_sum</code> 是初始的校验和值。</li>
<li>函数调用 <code>sum_every_16bits</code> 函数计算数据的 16 位字的和，然后将其加到初始校验和值 <code>start_sum</code> 中。</li>
<li>然后，使用一个循环将 32 位的和折叠为 16 位，直到和不再超过 16 位。</li>
<li>最后，返回计算得到的校验和的一位补码。</li>
</ul>
</li>
</ol>
<p>这些函数的目的是按照 RFC1071 中描述的方式计算 Internet 校验和。计算校验和的过程涉及将所有 16 位字相加，然后将 32 位和折叠为 16 位。最终，返回的值是校验和的一位补码。</p>
<h3 id="Internet-Control-Message-Protocol-version-4">Internet Control Message Protocol version 4</h3>
<p>由于互联网协议缺乏可靠性机制，因此需要某种方式来通知通信方可能的错误情况。因此，互联网控制消息协议(ICMP) 用于网络中的诊断措施。</p>
<h4 id="Header-2">Header</h4>
<p>ICMP 标头驻留在相应 IP 数据包的有效负载中。ICMPv4报头的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">icmp_v4</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> type;</span><br><span class="line">    <span class="type">uint8_t</span> code;</span><br><span class="line">    <span class="type">uint16_t</span> csum;</span><br><span class="line">    <span class="type">uint8_t</span> data[];</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<p><code>type</code>字段传达消息的目的。类型字段保留了42个不同的值，但常用的只有大约8个。在我们的实现中，使用类型 0（Echo Reply）、3（Destination Unreachable）和 8（Echo request）。</p>
<p><code>code</code>字段进一步描述了消息的含义。例如，当类型为 3（目的地不可达）时，代码字段暗示原因。一个常见错误是当数据包无法路由到网络时：始发主机很可能会收到类型为 3 且代码为 0（网络不可达）的 ICMP 消息。</p>
<p><code>csum</code>字段与IPv4报头中的校验和字段相同，并且可以使用相同的算法来计算它。在 ICMPv4 中，校验和是端到端的，这意味着计算校验和时还包括有效负载。</p>
<h4 id="消息及其处理">消息及其处理</h4>
<p>实际的 ICMP 负载由查询/信息消息和错误消息组成。首先，我们来看看回显请求/回复消息，在网络中通常称为“ping”：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">icmp_v4_echo</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> id;</span><br><span class="line">    <span class="type">uint16_t</span> seq;</span><br><span class="line">    <span class="type">uint8_t</span> data[];</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<p>消息格式紧凑。该字段<code>id</code>由发送主机设置，以确定回显应答要发送给哪个进程。例如，可以在此字段中设置进程 ID。</p>
<p>该字段<code>seq</code>是回显的序列号，它只是一个从零开始的数字，每当形成新的回显请求时就加一。这用于检测回显消息在传输过程中是否消失或重新排序。</p>
<p>该<code>data</code>字段是可选的，但通常包含回显时间戳等信息。然后可以使用它来估计主机之间的往返时间。</p>
<p>ICMPv4 错误消息Destination Unreachable具有以下格式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">icmp_v4_dst_unreachable</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> unused;</span><br><span class="line">    <span class="type">uint8_t</span> len;</span><br><span class="line">    <span class="type">uint16_t</span> var;</span><br><span class="line">    <span class="type">uint8_t</span> data[];</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<p>首先，第一个八位字节未使用。然后，长度字段（len field）表示原始数据报的长度，以IPv4的4字节单位计算。2字节字段var的值取决于ICMP代码。最后，导致目标不可达状态的原始IP数据包的尽可能多的部分被放置到数据字段中。</p>
<h2 id="TCP-基础知识和握手">TCP 基础知识和握手</h2>
<h3 id="可靠性机制">可靠性机制</h3>
<p>可靠发送数据的问题看似表面，但涉及到其实际的实现。主要是，在数据报式网络中的错误修复方面出现了几个问题：</p>
<ul>
<li>发送方应等待接收方确认多长时间？</li>
<li>如果接收方处理数据的速度无法赶上发送数据的速度怎么办？</li>
<li>如果中间的网络（例如路由器）无法像发送数据一样快速处理数据怎么办？</li>
</ul>
<p>在所有情况下，数据包交换网络的潜在危险都存在——来自接收方的确认可能在传输过程中被损坏甚至丢失，这使发送方陷入困境。</p>
<p>为了解决这些问题，可以使用多种机制。也许最常见的是滑动窗口技术，双方都对传输的数据进行记录。窗口数据被认为是连续的（就像数组的切片），并且当双方处理（并确认）数据时，窗口向前“滑动”：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Left window edge             Right window edge</span><br><span class="line">                   |                             |</span><br><span class="line">                   |                             |</span><br><span class="line">      ---------------------------------------------------------</span><br><span class="line">      ...|    3    |    4    |    5    |    6    |    7    |...</span><br><span class="line">      ---------------------------------------------------------</span><br><span class="line">              ^     ^                            ^    ^</span><br><span class="line">              |      \                          /     |</span><br><span class="line">              |       \                        /      |</span><br><span class="line">         Sent and           Window size: 3         Cannot be</span><br><span class="line">         ACKed                                     sent yet</span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<p>使用这种滑动窗口的便利特性是它还减轻了流量控制的问题。当接收方处理数据的速度不能达到发送数据的速度时，就需要进行流量控制。在这种情况下，滑动窗口的大小将协商得较小，从而导致发送方的输出受到限制。</p>
<p>另一方面，拥塞控制有助于发送方和接收方之间的网络堆栈不发生拥塞。有两种通用方法：在显式版本中，协议有一个字段用于专门通知发送方有关拥塞状态的信息。在隐式版本中，发送方尝试猜测网络何时拥塞并应限制其输出。总体而言，拥塞控制是一个复杂的、反复出现的网络问题。</p>
<h3 id="TCP-基础知识">TCP 基础知识</h3>
<p>TCP 中的底层机制比 UDP 和 IP 等其他协议涉及更多。TCP是面向连接的协议，这意味着首先在正好两端之间建立单播通信通道。这个连接是由双方主动处理的：建立连接（握手），告知对方数据的状态和可能出现的问题。</p>
<p>TCP 的另一个重要属性是它是一种流协议。与 UDP 不同，TCP 不保证应用程序在发送和接收数据时保持稳定的数据“块”。相反，TCP 实现必须缓冲数据，当数据包丢失、重新排序或损坏时，TCP 必须等待并组织缓冲区中的数据。只有当数据被认为是完整的时，TCP才可以将数据交给应用程序的套接字。</p>
<p>由于 TCP 将数据作为流进行操作，因此流中的“块”必须转换为 IP 可以承载的数据包。这称为打包，其中 TCP 标头包含流中当前索引的序列号。这还有一个方便的特性，即流可以分成许多可变大小的段，然后 TCP 知道如何重新打包它们。</p>
<p>与 IP 类似，TCP 也检查消息的完整性。这是通过与 IP 中相同的校验和算法实现的，但增加了细节。主要是，校验和是端到端的，这意味着标头和数据都包含在校验和中。此外，还包括根据 IP 标头构建的伪标头。</p>
<p>如果 TCP 实现接收到损坏的段，它会丢弃它们并且不会通知发送方。这个错误可以通过发送方设置的定时器来纠正，如果接收方从未确认过该报文段，则可以使用该定时器来重新传输该报文段。</p>
<p>TCP 也是一个全双工系统，这意味着流量可以同时在两个方向上流动。这意味着通信双方必须在内存中保持双向数据的排序。更深入地说，TCP 通过在其发送的段中包含对相反流量的确认来保留其流量足迹。</p>
<p>从本质上讲，数据流的排序是 TCP 的主要原理。然而，保持同步的问题并不是一个简单的问题。</p>
<h3 id="TCP-Header">TCP Header</h3>
<p>接下来，我们将定义消息标头并描述其字段。TCP头看似简单，但是包含了很多关于通信状态的信息。</p>
<p>TCP 标头为 20 个八位位组，大小为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> 0                            15                              31</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">|          <span class="built_in">source</span> port          |       destination port        |</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">|                        sequence number                        |</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">|                     acknowledgment number                     |</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">|  HL   | rsvd  |C|E|U|A|P|R|S|F|        window size            |</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">|         TCP checksum          |       urgent pointer          |</span><br><span class="line">-----------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<p>源端口和目标端口字段用于建立来自和到主机的多个连接。也就是说，Berkeley 套接字是应用程序绑定到 TCP 网络堆栈的流行接口。通过端口，网络堆栈知道将流量定向到哪里。由于字段大小为 16 位，因此端口值范围为 0 到 65535。</p>
<p>由于流中的每个字节都有编号，因此序列号代表 TCP 段的窗口索引。握手时，它包含<em>初始序列号</em>(ISN)。</p>
<p>确认号包含发送方期望接收的下一个字节的窗口索引。握手后，必须始终填充 ACK 字段。</p>
<p>报头长度(HL) 字段以 32 位字表示报头的长度。</p>
<p>接下来，展示了几个标志。前 4 位 ( rsvd ) 未使用。</p>
<ol>
<li>拥塞窗口降低©用于通知发送方降低了其发送速率。</li>
<li>ECN Echo (E) 通知发送方收到拥塞通知。</li>
<li>Urgent Pointer（U）指示该段包含优先级数据。</li>
<li>ACK (A) 字段用于传达 TCP 握手的状态。它在连接的剩余时间内保持开启状态。</li>
<li>PSH（P）用于指示接收方应尽快将数据“推送”到应用程序。</li>
<li>RST ® 重置 TCP 连接。</li>
<li>SYN (S)用于在初始握手时同步序列号。</li>
<li>FIN (F)表示发送方已完成数据发送。</li>
</ol>
<p>window size字段用于通告窗口大小。换句话说，这是接收方愿意接受的字节数。由于它是 16 位字段，因此最大窗口大小为 65,535 字节。</p>
<p>TCP checksum字段用于验证 TCP 段的完整性。该算法与 Internet 协议相同，但输入段还包含 TCP 数据以及来自 IP 数据报的伪标头。</p>
<p>当设置 U 标志时，使用紧急指针。该指针指示紧急数据在流中的位置。</p>
<p>在可能的选项之后，接下来是实际数据。然而，该数据不是必需的。例如，握手仅通过 TCP 标头完成。</p>
<h3 id="TCP握手">TCP握手</h3>
<p>TCP连接通常经历以下阶段：连接建立（握手）、数据传输和连接关闭。下图描述了 TCP 通常的握手例程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TCP A                                                TCP B</span><br><span class="line">   	  </span><br><span class="line">   1.  CLOSED                                               LISTEN</span><br><span class="line">   	</span><br><span class="line">   2.  SYN-SENT    --&gt; &lt;SEQ=100&gt;&lt;CTL=SYN&gt;               --&gt; SYN-RECEIVED</span><br><span class="line">   	  </span><br><span class="line">   3.  ESTABLISHED &lt;-- &lt;SEQ=300&gt;&lt;ACK=101&gt;&lt;CTL=SYN,ACK&gt;  &lt;-- SYN-RECEIVED</span><br><span class="line">   			</span><br><span class="line">   4.  ESTABLISHED --&gt; &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;       --&gt; ESTABLISHED</span><br><span class="line">   			  </span><br><span class="line">   5.  ESTABLISHED --&gt; &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;&lt;DATA&gt; --&gt; ESTABLISHED</span><br></pre></td></tr></table></figure>
<ol>
<li>主机 A 的套接字处于关闭状态，这意味着它不接受连接。相反，主机 B 绑定到特定端口的套接字正在侦听新连接。</li>
<li>主机 A 打算发起与主机 B 的连接。因此，A 制作了一个 TCP 段，该段设置了 SYN 标志，并且序列字段填充了值 (100)。</li>
<li>主机 B 使用设置了 SYN 和 ACK 字段的 TCP 段进行响应，并通过向其加 1 来确认 A 的序列号 (ACK=101)。同样，B 生成序列号（300）。</li>
<li>3 次握手由连接请求发起者 (A) 的 ACK 完成。确认字段反映了主机接下来期望从另一端接收到的序列号。</li>
<li>数据开始流动，主要是双方都确认了对方的段号。</li>
</ol>
<p>这是建立TCP连接的常见场景。然而，出现了几个问题：</p>
<ol>
<li>初始序列号是如何选择的？</li>
<li>如果双方同时请求彼此连接怎么办？</li>
<li>如果路段延迟一段时间或无限期怎么办？</li>
</ol>
<p>初始序列号(ISN) 由通信双方在第一次联系时独立选择。由于它是识别连接的关键部分，因此必须选择它，使其最有可能是唯一的且不易被猜测。事实上，在TCP 序列号攻击中，攻击者可以复制 TCP 连接并有效地将数据传送给目标，冒充受信任的主机。</p>
<p>最初的规范建议 ISN 由每 4 微秒递增的计数器选择。然而，攻击者可以猜测到这一点。实际上，现代网络堆栈通过更复杂的方法生成 ISN。</p>
<p>两个端点收到对方的连接请求（SYN）的情况称为同时打开。这是通过 TCP 握手中的额外消息交换来解决的：双方都发送 ACK（不知道另一方也已完成），并且双方对请求进行 SYN-ACK。此后，数据传输开始。</p>
<p>最后，TCP 实现必须有一个计时器来知道何时放弃建立连接。尝试重新建立连接，通常采用指数退避，但一旦达到最大重试次数或时间阈值，连接将被视为不存在。</p>
<h3 id="TCP-选项">TCP 选项</h3>
<p>TCP 标头段中的最后一个字段是为可能的 TCP 选项保留的。最初的规范提供了三个选项，但后来的规范添加了更多选项。接下来，我们将看看最常见的选项。</p>
<p>最大段大小(MSS) 选项告知 TCP 实现愿意接收的最大 TCP 段大小。IPv4 中的典型值为 1460 字节。</p>
<p>选择性确认(SACK) 选项优化了许多数据包在传输过程中丢失且接收器的数据窗口充满“漏洞”的情况。为了弥补由此造成的吞吐量下降，TCP 实现可以通过 SACK 通知发送方它未收到的特定数据包。因此，发送方以比累积确认方案更直接的方式接收有关数据状态的信息。</p>
<p>窗口缩放选项增加了有限的 16 位窗口大小。也就是说，如果双方在握手段中都包含此选项，则窗口大小将乘以此比例。拥有更大的窗口大小对于批量数据传输非常重要。</p>
<p>时间戳选项允许发送方将时间戳放入 TCP 分段中，然后可用于计算每个 ACK 分段的 RTT。然后可以使用该信息来计算 TCP 重传超时。</p>
<h2 id="TCP-Data-Flow-Socket-API">TCP Data Flow &amp; Socket API</h2>
<h3 id="Transmission-Control-Block">Transmission Control Block</h3>
<p>通过定义记录数据流状态的变量来开始讨论 TCP 数据管理是有益的。</p>
<p>简而言之，TCP 必须跟踪它已发送和接收确认的数据序列。为了实现这一点，为每个打开的连接初始化一个称为传输控制块（TCB）的数据结构。</p>
<p>传出（发送）端的变量是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Send Sequence Variables</span><br><span class="line"></span><br><span class="line">     SND.UNA - send unacknowledged</span><br><span class="line">     SND.NXT - send next</span><br><span class="line">     SND.WND - send window</span><br><span class="line">     SND.UP  - send urgent pointer</span><br><span class="line">     SND.WL1 - segment sequence number used <span class="keyword">for</span> last window update</span><br><span class="line">     SND.WL2 - segment acknowledgment number used <span class="keyword">for</span> last window update</span><br><span class="line">     ISS     - initial send sequence number</span><br></pre></td></tr></table></figure>
<p>依次，为接收方记录以下数据：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Receive Sequence Variables</span><br><span class="line">											  </span><br><span class="line">      RCV.NXT - receive next</span><br><span class="line">      RCV.WND - receive window</span><br><span class="line">      RCV.UP  - receive urgent pointer</span><br><span class="line">      IRS     - initial receive sequence number</span><br></pre></td></tr></table></figure>
<p>此外，当前正在处理的段的辅助变量定义如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Current Segment Variables</span><br><span class="line">	</span><br><span class="line">      SEG.SEQ - segment sequence number</span><br><span class="line">      SEG.ACK - segment acknowledgment number</span><br><span class="line">      SEG.LEN - segment length</span><br><span class="line">      SEG.WND - segment window</span><br><span class="line">      SEG.UP  - segment urgent pointer</span><br><span class="line">      SEG.PRC - segment precedence value</span><br></pre></td></tr></table></figure>
<p>这些变量共同构成了给定连接的大部分 TCP 控制逻辑。</p>
<h3 id="TCP数据通讯">TCP数据通讯</h3>
<p>一旦建立连接，就会开始显式处理数据流。TCB 中的三个变量对于状态的基本跟踪非常重要：</p>
<ul>
<li><code>SND.NXT</code>- 发件人将跟踪要在<code>SND.NXT</code>中使用的下一个序列号。</li>
<li><code>RCV.NXT</code>- 接收方记录下一个期望的序列号<code>RCV.NXT</code>。</li>
<li><code>SND.UNA</code>- 发送方将在<code>SND.UNA</code> 中记录最早的未确认序列号。</li>
</ul>
<p>在足够的时间段内，当TCP管理数据通信且没有传输发生时，这三个变量将相等。</p>
<p>例如，当 A 决定向 B 发送带有数据的段时，以下事件发生：</p>
<ol>
<li>TCP A发送一个段并在其自己的记录（TCB）中推进SND.NXT。</li>
<li>TCB B接收该段并通过推进RCV.NXT进行确认，并发送一个ACK。</li>
<li>TCB A接收ACK并推进SND.UNA。</li>
</ol>
<p>这些变量推进的数量是段中数据的长度。这是TCP在传输数据上的控制逻辑基础。</p>
<h3 id="TCP-连接终止">TCP 连接终止</h3>
<p>关闭 TCP 连接同样是一个复杂的操作，可以强制终止（RST）或通过双方协议（FIN）完成。</p>
<p>基本场景如下：</p>
<ol>
<li>主动关闭者发送FIN 报文段。</li>
<li>被动关闭者通过发送 ACK 段来确认这一点。</li>
<li>被动关闭器者开始自己的关闭操作（当它没有更多数据要发送时）并有效地成为主动关闭者。</li>
<li>一旦双方都向对方发送了 FIN 并且向两个方向都确认了它们，连接就会关闭。</li>
</ol>
<p>显然，TCP 连接的关闭需要四个段，而 TCP 连接建立（三次握手）则需要三个段。</p>
<p>此外，TCP 是一种双向协议，因此可以让另一端宣布它没有更多数据要发送，但仍保持在线状态以接收传入数据。这称为TCP 半关闭。</p>
<p>数据包交换网络的不可靠特性给连接终止带来了额外的复杂性 - FIN 段可能会消失或永远不会被有意发送，从而使连接处于尴尬的状态。例如，在 Linux 中，内核参数<code>tcp_fin_timeout</code>控制 TCP 在强制关闭连接之前等待最终 FIN 数据包的秒数。这违反了规范，但却是预防拒绝服务 (DoS) 所必需的。</p>
<p>中止连接涉及设置了 RST 标志的段。发生重置的原因有很多，但常见的原因有：</p>
<ol>
<li>对不存在的端口或接口的连接请求</li>
<li>另一个 TCP 已崩溃并最终处于不同步连接状态</li>
<li>尝试干扰现有连接</li>
</ol>
<p>因此，TCP 数据传输的最佳路径永远不会涉及 RST 段。</p>
<h3 id="套接字API">套接字API</h3>
<p>为了能够利用网络堆栈，必须为应用程序提供某种接口。BSD <em>Socket API</em>是最著名的一种，它起源于 1983 年的 4.2BSD UNIX 版本。Linux 中的 Socket API 与 BSD Socket API 兼容。</p>
<p><code>socket(2)</code>通过调用并将套接字类型和协议作为参数传递，可以从网络堆栈中保留套接字。通用值为<code>AF_INET</code>和<code>SOCK_STREAM</code>。这将默认为 TCP-over-IPv4 套接字。</p>
<p>成功从网络堆栈保留 TCP 套接字后，它将连接到远程端点。这是<code>connect(2)</code>使用的地方，调用它将启动 TCP 握手。</p>
<p>从那时起，我们就可以从套接字<code>write(2)</code>和<code>read(2)</code>获取数据了。</p>
<p>网络堆栈将处理 TCP 流中数据的排队、重传、错误检查和重组。对于应用程序来说，TCP的内部行为大多是不透明的。应用程序唯一可以依赖的是 TCP 已确认发送和接收数据流的责任，并且它将通过套接字 API 通知应用程序意外行为。</p>
<p>socket()：</p>
<ul>
<li>创建一个套接字，返回一个套接字描述符。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure>
<p>bind()：</p>
<ul>
<li>将套接字与特定地址（IP地址和端口号）绑定。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>
<p>listen()：</p>
<ul>
<li>启动服务端等待客户端连接请求的过程。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br></pre></td></tr></table></figure>
<p>accept()：</p>
<ul>
<li>接受客户端的连接请求，返回一个新的套接字用于与客户端通信。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure>
<p>connect()：</p>
<ul>
<li>发起与远程服务器的连接。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>
<p>send() 和 recv()：</p>
<ul>
<li>用于发送和接收数据。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="TCP-重传">TCP 重传</h2>
<h3 id="自动重复请求">自动重复请求</h3>
<p>许多可靠协议的基础是自动重复请求 (ARQ)的概念。</p>
<p>在 ARQ 中，接收方发送其已接收数据的确认，而发送方则重新传输其从未收到确认的数据。</p>
<p>正如我们所讨论的，TCP 将传输数据的序列号保存在内存中并以确认进行响应。传输的数据被放入重传队列中，并且启动与数据相关的定时器。如果在定时器超时之前没有收到数据序列的确认，则会发生重传。</p>
<h3 id="TCP重传">TCP重传</h3>
<p>当TCP传输包含数据的报文段时，它会将副本放入重传队列中并启动计时器；当收到该数据的确认时，该段将从队列中删除。如果在定时器超时之前没有收到确认，则重新传输该段。</p>
<p>然而，原来的重传超时计算公式被认为不适用于不同的网络环境,最新的规范化规范可以从 RFC6298中找到。</p>
<p>基本算法相对简单。对于给定的 TCP 发送方，定义状态变量来计算超时：</p>
<ul>
<li><code>srtt</code>是平滑的往返时间，用于平均分段的往返时间 (RTT)</li>
<li><code>rttvar</code>保存往返时间变化</li>
<li><code>rto</code>最终保存重传超时，例如以毫秒为单位</li>
</ul>
<p>简而言之，srtt 充当连续 RTT 的低通滤波器。由于 RTT 可能存在较大的变化，rttvar 用于检测这些变化并防止它们影响平均函数。此外，假设时钟的粒度为 G 秒。</p>
<p>如RFC6298中所述，计算步骤如下：</p>
<ol>
<li>
<p>在第一次 RTT 测量之前：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rto = 1000ms</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在第一个 RTT 测量R上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">srtt = R</span><br><span class="line">rttvar = R/2</span><br><span class="line">rto = srtt + max(G, 4*rttvar)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>关于后续测量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alpha = 0.125</span><br><span class="line">beta = 0.25</span><br><span class="line">rttvar = (1 - beta) * rttvar + beta * abs(srtt - r)</span><br><span class="line">srtt = (1 - alpha) * srtt + alpha * r</span><br><span class="line">rto = srtt + max(g, 4*rttvar)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>计算后<code>rto</code>，如果小于1秒，则四舍五入为1秒。可以提供最大数量，但必须至少为 60 秒</p>
</li>
</ol>
<p>TCP 实现的时钟粒度传统上被估计为相当高，范围从 500 毫秒到 1 秒。然而，像 Linux 这样的现代系统使用的时钟粒度为 1 毫秒。</p>
<p>需要注意的一件事是，	建议 RTO 始终至少为 1 秒。这是为了防止虚假重传，即当某个数据段重传过快时，会导致<strong>网络拥塞</strong>。在实践中，许多实现选择亚秒级的四舍五入：Linux 使用 200 毫秒。</p>
<h3 id="Karn’s-Algorithm">Karn’s Algorithm</h3>
<p>Karn 算法是一种防止 RTT 测量给出错误结果的强制算法。它只是指出不应为重传的数据包获取 RTT 样本。</p>
<p>换句话说，TCP 发送方会跟踪其发送的分段是否为重传，并跳过这些确认的 RTT 例程。这是有道理的，因为否则发送方无法区分原始段和重传段之间的确认。</p>
<p>然而，当使用时间戳 TCP 选项时，可以测量每个 ACK 段的 RTT。</p>
<h3 id="管理-RTO-定时器">管理 RTO 定时器</h3>
<p>管理重传定时器相对简单。RFC6298推荐以下算法：</p>
<ol>
<li>当发送数据段且 RTO 定时器未运行时，将其激活，超时值为<code>rto</code></li>
<li>当所有未完成的数据段均被确认后，关闭 RTO 定时器</li>
<li>当收到新数据的 ACK 时，用以下值重新启动 RTO 定时器：<code>rto</code></li>
</ol>
<p>当 RTO 定时器到期时：</p>
<ol>
<li>重传最早的未确认段</li>
<li>将 RTO 定时器退后 2 倍，即 ( <code>rto = rto * 2</code>)</li>
<li>启动RTO定时器</li>
</ol>
<p>此外，当 RTO 值出现回退并且成功进行后续测量时，RTO 值可能会急剧缩小。在进行退避并等待确认时，TCP 实现可能会清除 srtt 和 rttvar。</p>
<h3 id="请求重传">请求重传</h3>
<p>TCP 通常不仅仅依靠 TCP 发送方的计时器来修复丢失的数据包。接收方还可以通知发送方需要重传分段。</p>
<p>重复确认是一种对无序段进行确认的算法，但按最新有序段的序列号进行确认。在三个重复确认之后，TCP 发送方应该意识到它需要重新传输由重复确认通告的段。</p>
<p>此外，选择性确认（SACK）是重复确认的更复杂版本。它是一个 TCP 选项，接收器能够将接收到的序列编码到其确认中。然后发送者立即注意到任何丢失的数据段并重新发送它们。</p>
<h2 id="代码走读">代码走读</h2>
<p>代码结构如下</p>
<img src="https://raw.githubusercontent.com/BlackForest1990/Mypic/img/img/image-20240123105753930.png" alt="image-20240123105753930" style="zoom:50%;">
<p>先看下makefile文件，看看程序是怎么编译出来的？</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">CPPFLAGS = -I <span class="keyword">include</span> -Wall -Werror -pthread</span><br><span class="line"></span><br><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> src/*.c)</span></span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> src/%.c, build/%.o, <span class="variable">$(src)</span>)</span></span><br><span class="line">headers = <span class="variable">$(<span class="built_in">wildcard</span> include/*.h)</span></span><br><span class="line">apps = apps/curl/curl</span><br><span class="line"></span><br><span class="line"><span class="section">lvl-ip: <span class="variable">$(obj)</span></span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> <span class="variable">$(obj)</span> -o lvl-ip</span><br><span class="line">	@echo</span><br><span class="line">	@echo <span class="string">&quot;lvl-ip needs CAP_NET_ADMIN:&quot;</span></span><br><span class="line">	sudo setcap cap_setpcap,cap_net_admin=ep lvl-ip</span><br><span class="line"></span><br><span class="line"><span class="section">build/%.o: src/%.c $&#123;headers&#125;</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">debug: CFLAGS+= -DDEBUG_SOCKET -DDEBUG_TCP -g -fsanitize=thread</span></span><br><span class="line"><span class="section">debug: lvl-ip</span></span><br><span class="line"></span><br><span class="line"><span class="section">apps: <span class="variable">$(apps)</span></span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C tools</span><br><span class="line">	<span class="variable">$(MAKE)</span> -C apps/curl</span><br><span class="line">	<span class="variable">$(MAKE)</span> -C apps/curl-poll</span><br><span class="line"></span><br><span class="line"><span class="section">all: lvl-ip apps</span></span><br><span class="line"></span><br><span class="line"><span class="section">test: debug apps</span></span><br><span class="line">	@echo</span><br><span class="line">	@echo <span class="string">&quot;Networking capabilites are required for test dependencies:&quot;</span></span><br><span class="line">	which arping | sudo xargs setcap cap_net_raw=ep</span><br><span class="line">	which tc | sudo xargs setcap cap_net_admin=ep</span><br><span class="line">	@echo</span><br><span class="line">	cd tests &amp;&amp; ./test-run-all</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm build/*.o lvl-ip</span><br></pre></td></tr></table></figure>
<ol>
<li><code>CPPFLAGS</code> 定义了一些编译选项，包括头文件目录、警告标志等。</li>
<li><code>src</code> 使用<code>wildcard</code>函数列举了<code>src</code>目录下所有的<code>.c</code>文件。</li>
<li><code>obj</code> 使用<code>patsubst</code>函数将<code>src</code>中的<code>.c</code>文件路径转换为<code>build</code>中的<code>.o</code>文件路径。</li>
<li><code>headers</code> 列举了<code>include</code>目录下所有的头文件。</li>
<li><code>apps</code> 定义了一个变量，包含了一个名为<code>curl</code>的应用程序。</li>
<li><code>lvl-ip</code> 是默认目标规则，依赖于<code>$(obj)</code>。它编译了所有的<code>.o</code>文件并生成可执行文件<code>lvl-ip</code>，然后使用<code>setcap</code>命令赋予了特定的权限。</li>
<li><code>build/%.o</code> 规则定义了如何将<code>.c</code>文件编译成<code>.o</code>文件。</li>
<li><code>debug</code> 目标规则用于构建带有调试信息和线程检测的<code>lvl-ip</code>。</li>
<li><code>apps</code> 目标规则用于构建额外的应用程序。</li>
<li><code>all</code> 是一个依赖于<code>lvl-ip</code>和<code>apps</code>的目标规则。</li>
<li><code>test</code> 目标规则用于运行测试，要求一些网络权限。</li>
<li><code>clean</code> 规则用于清理生成的<code>.o</code>文件和可执行文件。</li>
</ol>
<p>函数从main函数入口， 在链接阶段，链接器将编译生成的目标文件（例如，<code>.o</code>文件）合并成一个可执行文件。在这个过程中，链接器会解析<code>main</code>函数的地址，将其设置为程序的入口点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*1. argc（Argument Count）： 这是一个整数，表示命令行参数的数量（argument count）。它表示在运行程序时通过命令行			输入的参数的个数。`argc` 至少为 1，因为程序的名称通常被认为是一个参数。</span></span><br><span class="line"><span class="comment">	2. argv（Argument Vector）：这是一个字符指针数组，其中每个指针指向一个字符串，表示实际的命令行参数（argument `			vector）。`argv[0]` 是程序的名称，`argv[1]` 到 `argv[argc-1]` 是通过命令行输入的其他参数。每个参数都以字符串的形式表		示。*/</span></span><br><span class="line">    parse_cli(argc, argv);<span class="comment">//该函数可能用于解析命令行参数 argc 和 argv，以便你的程序可以接受和处理命令行输入</span></span><br><span class="line">    </span><br><span class="line">    init_signals();<span class="comment">//该函数可能用于初始化信号处理程序</span></span><br><span class="line">    init_stack();<span class="comment">//该函数可能用于初始化程序的堆栈</span></span><br><span class="line">    init_security();<span class="comment">//该函数可能用于执行一些与程序安全性相关的初始化操作</span></span><br><span class="line">    </span><br><span class="line">    run_threads();<span class="comment">//启动线程</span></span><br><span class="line">    wait_for_threads();<span class="comment">//该函数可能用于等待所有线程执行完毕或达到某种状态</span></span><br><span class="line"></span><br><span class="line">    free_stack();<span class="comment">//该函数可能用于释放之前初始化的堆栈或相关资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">init_stack</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    tun_init();</span><br><span class="line">    netdev_init();</span><br><span class="line">    route_init();</span><br><span class="line">    arp_init();</span><br><span class="line">    tcp_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>tun_init()</code>: 这个函数用于初始化TUN（网络隧道）设备。TUN设备是一种虚拟网络设备，用于在用户空间和内核空间之间传递网络数据包。</li>
<li><code>netdev_init()</code>: 这个函数用于初始化网络设备。网络设备是计算机网络中的硬件设备或虚拟设备，用于进行数据包的输入和输出。</li>
<li><code>route_init()</code>: 这个函数用于初始化路由表。路由表用于确定数据包从源地址到目标地址的传输路径。</li>
<li><code>arp_init()</code>: 这个函数用于初始化ARP（地址解析协议）。ARP协议用于将IP地址映射到物理硬件地址（如MAC地址）。</li>
<li><code>tcp_init()</code>: 这个函数用于初始化TCP协议。TCP是一种可靠的、面向连接的协议，用于在计算机网络中进行可靠的数据传输。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">run_threads</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    create_thread(THREAD_CORE, netdev_rx_loop);<span class="comment">// 创建并启动网络设备接收循环的线程</span></span><br><span class="line">    create_thread(THREAD_TIMERS, timers_start); <span class="comment">// 创建并启动定时器的线程</span></span><br><span class="line">    create_thread(THREAD_IPC, start_ipc_listener); <span class="comment">// 创建并启动 IPC 监听器的线程</span></span><br><span class="line">    create_thread(THREAD_SIGNAL, stop_stack_handler);<span class="comment">// 创建并启动处理停止事件的线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码定义了一个名为 <code>create_thread</code> 的函数，用于创建线程并启动执行指定的函数。以下是对代码的主要解释：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">create_thread</span><span class="params">(<span class="type">pthread_t</span> id, <span class="type">void</span> *(*func) (<span class="type">void</span> *))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用 pthread_create 函数创建线程</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;threads[id], <span class="literal">NULL</span>, func, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果创建线程失败，输出错误信息</span></span><br><span class="line">        print_err(<span class="string">&quot;Could not create core thread\n&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>}</p>
<ul>
<li><strong><code>pthread_create</code> 函数：</strong> 这是 POSIX 线程库中用于创建线程的函数。它接受四个参数：
<ul>
<li><code>&amp;threads[id]</code>：指向 <code>pthread_t</code> 类型的变量，用于存储新创建线程的标识符。</li>
<li><code>NULL</code>：线程的属性，这里设置为默认属性。</li>
<li><code>func</code>：指向线程执行的函数的指针。</li>
<li><code>NULL</code>：传递给线程执行函数的参数，这里设置为 <code>NULL</code>。</li>
</ul>
</li>
<li><strong><code>print_err</code> 函数：</strong> 如果创建线程失败，调用 <code>print_err</code> 函数输出错误信息。</li>
</ul>
<p>这个函数的作用是通过调用 <code>pthread_create</code> 创建线程，并将线程的标识符存储在全局数组 <code>threads</code> 的指定位置。如果创建线程失败，输出错误信息。这样的设计通常用于并发执行多个任务，提高程序的性能和响应性。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blackforest1990.github.io">BlackForest1990</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blackforest1990.github.io/2024/01/16/Tcp-ip/">https://blackforest1990.github.io/2024/01/16/Tcp-ip/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blackforest1990.github.io" target="_blank">黑暗森林</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/how-to-make/">how to make</a></div><div class="post_share"><div class="social-share" data-image="/image/blackforest.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>谢谢支持</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechatpay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechatpay.jpg"/></a><div class="post-qr-code-desc"></div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/01/18/%E4%BA%91%E8%AE%A1%E7%AE%97%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" title="云计算架构设计总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">云计算架构设计总结</div></div></a></div><div class="next-post pull-right"><a href="/2024/01/09/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" title="万历十五年读书笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">万历十五年读书笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-IP-%E5%8D%8F%E8%AE%AE%E5%B1%82"><span class="toc-number">1.</span> <span class="toc-text">TCP&amp;IP 协议层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ethernet-ARP"><span class="toc-number">2.</span> <span class="toc-text">Ethernet &amp; ARP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TAP%E8%AE%BE%E5%A4%87"><span class="toc-number">2.1.</span> <span class="toc-text">TAP设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">以太网帧格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E8%A7%A3%E6%9E%90"><span class="toc-number">2.3.</span> <span class="toc-text">以太网帧解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.4.</span> <span class="toc-text">地址解析协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">2.5.</span> <span class="toc-text">地址解析算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IPv4-and-ICMPv4"><span class="toc-number">3.</span> <span class="toc-text">IPv4 and ICMPv4</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IPv4"><span class="toc-number">3.1.</span> <span class="toc-text">IPv4</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Header"><span class="toc-number">3.1.1.</span> <span class="toc-text">Header</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Internet-Checksum"><span class="toc-number">3.1.2.</span> <span class="toc-text">Internet Checksum</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Internet-Control-Message-Protocol-version-4"><span class="toc-number">3.2.</span> <span class="toc-text">Internet Control Message Protocol version 4</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Header-2"><span class="toc-number">3.2.1.</span> <span class="toc-text">Header</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%8F%8A%E5%85%B6%E5%A4%84%E7%90%86"><span class="toc-number">3.2.2.</span> <span class="toc-text">消息及其处理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E6%8F%A1%E6%89%8B"><span class="toc-number">4.</span> <span class="toc-text">TCP 基础知识和握手</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%9C%BA%E5%88%B6"><span class="toc-number">4.1.</span> <span class="toc-text">可靠性机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">4.2.</span> <span class="toc-text">TCP 基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-Header"><span class="toc-number">4.3.</span> <span class="toc-text">TCP Header</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E6%8F%A1%E6%89%8B"><span class="toc-number">4.4.</span> <span class="toc-text">TCP握手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E9%80%89%E9%A1%B9"><span class="toc-number">4.5.</span> <span class="toc-text">TCP 选项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-Data-Flow-Socket-API"><span class="toc-number">5.</span> <span class="toc-text">TCP Data Flow &amp; Socket API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Transmission-Control-Block"><span class="toc-number">5.1.</span> <span class="toc-text">Transmission Control Block</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E6%95%B0%E6%8D%AE%E9%80%9A%E8%AE%AF"><span class="toc-number">5.2.</span> <span class="toc-text">TCP数据通讯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E8%BF%9E%E6%8E%A5%E7%BB%88%E6%AD%A2"><span class="toc-number">5.3.</span> <span class="toc-text">TCP 连接终止</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97API"><span class="toc-number">5.4.</span> <span class="toc-text">套接字API</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E9%87%8D%E4%BC%A0"><span class="toc-number">6.</span> <span class="toc-text">TCP 重传</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E9%87%8D%E5%A4%8D%E8%AF%B7%E6%B1%82"><span class="toc-number">6.1.</span> <span class="toc-text">自动重复请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E9%87%8D%E4%BC%A0"><span class="toc-number">6.2.</span> <span class="toc-text">TCP重传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Karn%E2%80%99s-Algorithm"><span class="toc-number">6.3.</span> <span class="toc-text">Karn’s Algorithm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%90%86-RTO-%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">6.4.</span> <span class="toc-text">管理 RTO 定时器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E9%87%8D%E4%BC%A0"><span class="toc-number">6.5.</span> <span class="toc-text">请求重传</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%B5%B0%E8%AF%BB"><span class="toc-number">7.</span> <span class="toc-text">代码走读</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By BlackForest1990</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">如果只允许一种声音存在，那么，唯一存在的那个声音就是谎言。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>