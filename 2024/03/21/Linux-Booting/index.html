<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux Booting | 黑暗森林</title><meta name="author" content="BlackForest1990"><meta name="copyright" content="BlackForest1990"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="大家好，我们要开始学习Linux kernel了，自从1991 年 linus Torvalds开发出最初的Linux，它作为一个适用于基于Intel 80386微处理器的IBM PC兼容机的操作系统，他是如何启动的，如何建立堆栈，如何利用内存的，如何设计的，如何应用，让我们从按下电源开始吧。 从引导加载程序内核 启动！ 按下笔记本电脑或台式电脑上的神奇电源按钮，它就会开始工作。主板向供电装置发送">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux Booting">
<meta property="og:url" content="https://blackforest1990.github.io/2024/03/21/Linux-Booting/index.html">
<meta property="og:site_name" content="黑暗森林">
<meta property="og:description" content="大家好，我们要开始学习Linux kernel了，自从1991 年 linus Torvalds开发出最初的Linux，它作为一个适用于基于Intel 80386微处理器的IBM PC兼容机的操作系统，他是如何启动的，如何建立堆栈，如何利用内存的，如何设计的，如何应用，让我们从按下电源开始吧。 从引导加载程序内核 启动！ 按下笔记本电脑或台式电脑上的神奇电源按钮，它就会开始工作。主板向供电装置发送">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blackforest1990.github.io/image/blackforest.jpg">
<meta property="article:published_time" content="2024-03-21T05:09:02.000Z">
<meta property="article:modified_time" content="2024-08-07T04:30:40.412Z">
<meta property="article:author" content="BlackForest1990">
<meta property="article:tag" content="Kernel">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blackforest1990.github.io/image/blackforest.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blackforest1990.github.io/2024/03/21/Linux-Booting/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux Booting',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-07 12:30:40'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="黑暗森林" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/image/blackforest.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="黑暗森林"><span class="site-name">黑暗森林</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux Booting</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-21T05:09:02.000Z" title="发表于 2024-03-21 13:09:02">2024-03-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-07T04:30:40.412Z" title="更新于 2024-08-07 12:30:40">2024-08-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux Booting"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>大家好，我们要开始学习Linux kernel了，自从1991 年 linus Torvalds开发出最初的Linux，它作为一个适用于基于Intel 80386微处理器的IBM PC兼容机的操作系统，他是如何启动的，如何建立堆栈，如何利用内存的，如何设计的，如何应用，让我们从按下电源开始吧。</p>
<h2 id="从引导加载程序内核">从引导加载程序内核</h2>
<h3 id="启动！">启动！</h3>
<p>按下笔记本电脑或台式电脑上的神奇电源按钮，它就会开始工作。主板向供电装置发送信号。电源接收到信号后，向计算机提供适量的电量。一旦主板收到电源良好信号，它就会尝试启动CPU。CPU 重置其寄存器中的所有剩余数据，并为每个寄存器设置预定义值。</p>
<p>80386及更高版本的在计算机复位后在CPU寄存器中定义以下预定义数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IP          0xfff0              //指令指针，它包含了CPU当前执行的指令的偏移地址</span><br><span class="line">CS selector 0xf000              //CS (Code Segment) selector代码段选择器，用于访问代码段寄存器</span><br><span class="line">CS base     0xffff0000          //代码段的基址，用于计算代码段的物理地址</span><br></pre></td></tr></table></figure>
<p>处理器开始在实模式工作。8086 处理器有一个20位寻址总线，这意味着它可以对0到 2^20 位地址空间（ 1MB ）进行操作。不过它只有16位的寄存器，所以最大寻址空间是 2^16 即 0xffff （64 KB）。实模式使用<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Memory_segmentation">段式内存管理</a> 来管理整个内存空间。<strong>所有内存被分成固定的65536字节（64 KB） 大小的小块</strong>。由于我们不能用16位寄存器寻址大于 64KB 的内存,  一个地址包括两个部分：<strong>数据段起始地址和从该数据段起的偏移量</strong>。为了得到内存中的物理地址，我们要让数据段乘16并加上偏移量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PhysicalAddress = Segment * 16 + Offset</span><br></pre></td></tr></table></figure>
<p>不过如果我们使用16位2进制能表示的最大值进行寻址：<code>0xffff:0xffff</code>，根据上面的公式，结果将会是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; hex((0xffff &lt;&lt; 4) + 0xffff)</span><br><span class="line">&#x27;0x10ffef&#x27;</span><br></pre></td></tr></table></figure>
<p>这个地址在 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Intel_8086">8086</a> 处理器下，将被转换成地址 <code>0x0ffef</code>, 原因是因为，8086 cpu 只有20位地址线，只能表示 <code>2^20 = 1MB</code> 的地址，而上面这个地址已经超出了 1MB 地址的范围，所以 CPU 就舍弃了最高位。</p>
<p>实模式下的 1MB 地址空间分配表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0x00000000 - 0x000003FF - Real Mode Interrupt Vector Table</span><br><span class="line">0x00000400 - 0x000004FF - BIOS Data Area</span><br><span class="line">0x00000500 - 0x00007BFF - Unused</span><br><span class="line">0x00007C00 - 0x00007DFF - Our Bootloader</span><br><span class="line">0x00007E00 - 0x0009FFFF - Unused</span><br><span class="line">0x000A0000 - 0x000BFFFF - Video RAM (VRAM) Memory</span><br><span class="line">0x000B0000 - 0x000B7777 - Monochrome Video Memory</span><br><span class="line">0x000B8000 - 0x000BFFFF - Color Video Memory</span><br><span class="line">0x000C0000 - 0x000C7FFF - Video ROM BIOS</span><br><span class="line">0x000C8000 - 0x000EFFFF - BIOS Shadow Area</span><br><span class="line">0x000F0000 - 0x000FFFFF - System BIOS</span><br></pre></td></tr></table></figure>
<p><code>CS</code> 寄存器包含两个部分：可视段选择器和隐含基址。 结合之前定义的 <code>CS</code> 基址和 <code>IP</code> 值，逻辑地址应该是：</p>
<p>可以参考：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/55330308/8086-reset-vector-above-20-bits-with-buses-of-20-bits">https://stackoverflow.com/questions/55330308/8086-reset-vector-above-20-bits-with-buses-of-20-bits</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xffff0000:0xfff0</span><br></pre></td></tr></table></figure>
<p>这种形式的起始地址为EIP寄存器里的值加上基址地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 0xffff0000 + 0xfff0</span><br><span class="line">&#x27;0xfffffff0&#x27;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>EIP 寄存器是 x86 架构中的一个 32 位寄存器，用于存储当前执行指令的地址，即指令指针。EIP 的含义是 “Extended Instruction Pointer”，它在程序执行期间不断更新，以指向下一条要执行的指令。 EIP 寄存器的值由 CPU 在执行指令时自动更新。</p>
</blockquote>
<p>得到的 <code>0xfffffff0</code> 是 4GB - 16 字节。 这个地方是 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Reset_vector">复位向量(Reset vector)</a> 。 这是CPU在重置后期望执行的第一条指令的内存地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xFFFE_0000 - 0xFFFF_FFFF: 128 kilobyte ROM mapped into address space</span><br></pre></td></tr></table></figure>
<p><code>0xFFFFFFF0</code> 这个地址被映射到了 ROM，因此 CPU 执行的第一条指令来自于 ROM，而不是 RAM。</p>
<p>它包含一个 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/JMP_(x86_instruction)">jump</a> 指令，<strong>这个指令通常指向BIOS入口点</strong>。举个例子，如果访问 <a target="_blank" rel="noopener" href="http://www.coreboot.org/">coreboot</a> 源代码，将看到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	.section &quot;.reset&quot;, &quot;ax&quot;, %progbits</span><br><span class="line">	.code16</span><br><span class="line">.globl	_start</span><br><span class="line">_start:</span><br><span class="line">	.byte  0xe9</span><br><span class="line">	.int   _start16bit - ( . + 2 )</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>上面的跳转指令（ opcode - 0xe9）跳转到地址  _start16bit - ( . + 2) 去执行代码。 reset 段是 16 字节代码段， 起始于地址 0xfffffff0，因此 CPU 复位之后，就会跳到这个地址来执行相应的代码 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">	/* Trigger an error if I have an unuseable start address */</span><br><span class="line"> 	_bogus = ASSERT(_start16bit &gt;= 0xffff0000, &quot;_start16bit too low. Please report.&quot;);</span><br><span class="line">	_ROMTOP = 0xfffffff0;</span><br><span class="line">	. = _ROMTOP;</span><br><span class="line">	.reset . : &#123;</span><br><span class="line">		*(.reset);</span><br><span class="line">		. = 15;</span><br><span class="line">		BYTE(0x00);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>现在BIOS已经开始工作了。在初始化和检查硬件之后，需要寻找到一个可引导设备</strong>。可引导设备列表存储在在 BIOS 配置中, BIOS 将根据其中配置的顺序，尝试从不同的设备上寻找引导程序。对于硬盘，BIOS 将尝试寻找引导扇区。如果在硬盘上存在一个MBR分区，那么引导扇区储存在第一个扇区(512字节)的头446字节，引导扇区的最后必须是 <code>0x55</code> 和 <code>0xaa</code> ，<strong>这2个字节称为魔术字节（Magic Bytes)</strong>，如果 BIOS 看到这2个字节，就知道这个设备是一个可引导设备。举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">;</span><br><span class="line">; Note: this example is written in Intel Assembly syntax</span><br><span class="line">;</span><br><span class="line">[BITS 16]</span><br><span class="line">[ORG  0x7c00]</span><br><span class="line"></span><br><span class="line">boot:</span><br><span class="line">    mov al, &#x27;!&#x27;</span><br><span class="line">    mov ah, 0x0e</span><br><span class="line">    mov bh, 0x00</span><br><span class="line">    mov bl, 0x07</span><br><span class="line"></span><br><span class="line">    int 0x10</span><br><span class="line">    jmp $</span><br><span class="line">r</span><br><span class="line">times 510-($-$$) db 0</span><br><span class="line"></span><br><span class="line">db 0x55</span><br><span class="line">db 0xaa</span><br></pre></td></tr></table></figure>
<p>构建并运行：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nasm -f bin boot.nasm &amp;&amp; qemu-system-x86_64 boot</span><br></pre></td></tr></table></figure>
<p>这让 <a target="_blank" rel="noopener" href="http://qemu.org/">QEMU</a> 使用刚才新建的 <code>boot</code> 二进制文件作为磁盘镜像。由于这个二进制文件是由上述汇编语言产生，它满足引导扇区(起始设为 <code>0x7c00</code>, 用Magic Bytes结束)的需求。QEMU将这个二进制文件作为磁盘镜像的主引导记录(MBR)。</p>
<img src="https://raw.githubusercontent.com/BlackForest1990/Mypic/img/img/image-20240322122843358.png" alt="image-20240322122843358" style="zoom:50%;">
<p>在这个例子中，这段代码被执行在16位的实模式，起始于内存0x7c00。之后调用 <a target="_blank" rel="noopener" href="http://www.ctyme.com/intr/rb-0106.htm">0x10</a> 中断打印 <code>!</code> 符号。用0填充剩余的510字节并用两个Magic Bytes <code>0xaa</code> 和 <code>0x55</code> 结束。</p>
<h3 id="引导程序">引导程序</h3>
<p>有多种引导程序可以选择, 比如 <a target="_blank" rel="noopener" href="https://www.gnu.org/software/grub/">GRUB 2</a> 和 <a target="_blank" rel="noopener" href="http://www.syslinux.org/wiki/index.php/The_Syslinux_Project">syslinux</a>。Linux内核通过 <a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/Documentation/x86/boot.txt?v=3.18">Boot protocol</a> 来定义应该如何实现引导程序。在这里我们将只介绍 GRUB 2。</p>
<p>现在 BIOS 已经选择了一个启动设备，并且将控制权转移给了启动扇区中的代码，在我们的例子中，启动扇区代码是 boot.img。因为这段代码只能占用一个扇区，因此非常简单，只做一些必要的初始化，然后就跳转到 GRUB 2’s core image 去执行。 Core image 的代码请参考 <a target="_blank" rel="noopener" href="http://git.savannah.gnu.org/gitweb/?p=grub.git;a=blob;f=grub-core/boot/i386/pc/diskboot.S;hb=HEAD">diskboot.img</a>，一般来说 core image 在磁盘上存储在启动扇区之后到第一个可用分区之前。core image 的初始化代码会把整个 core image （包括 GRUB 2的内核代码和文件系统驱动） <strong>引导到内存中</strong>。 引导完成之后，<a target="_blank" rel="noopener" href="http://git.savannah.gnu.org/gitweb/?p=grub.git;a=blob;f=grub-core/kern/main.c">grub_main</a>将被调用。</p>
<p><code>grub_main</code> 初始化控制台，计算模块基地址，设置 root 设备，读取 grub 配置文件，加载模块。最后，将 GRUB 置于 normal 模式，在这个模式中，<code>grub_normal_execute</code> (from <code>grub-core/normal/main.c</code>) 将被调用以完成最后的准备工作，然后显示一个菜单列出所用可用的操作系统。当某个操作系统被选择之后，<code>grub_menu_execute_entry</code> 开始执行，它将调用 GRUB 的 <code>boot</code> 命令，来引导被选中的操作系统。</p>
<p>引导程序必须填充 kernel setup header （位于 kernel setup code 偏移 <code>0x01f1</code> 处） 的必要字段。kernel setup header的定义开始于 <a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/arch/x86/boot/header.S?v=3.18">arch/x86/boot/header.S</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	.globl hdr</span><br><span class="line">hdr:</span><br><span class="line">	setup_sects: .byte 0</span><br><span class="line">	root_flags:  .word ROOT_RDONLY</span><br><span class="line">	syssize:     .long 0</span><br><span class="line">	ram_size:    .word 0</span><br><span class="line">	vid_mode:    .word SVGA_MODE</span><br><span class="line">	root_dev:    .word 0</span><br><span class="line">	boot_flag:   .word 0xAA55</span><br></pre></td></tr></table></figure>
<p>bootloader必须填充在 Linux boot protocol 中标记为 <code>write</code> 的头信息，比如 <a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/Documentation/x86/boot.txt?v=3.18#L354">type_of_loader</a>，这些头信息可能来自命令行，或者通过计算得到。在这里我们不会详细介绍所有的 kernel setup header，我们将在需要的时候逐个介绍。不过，你可以自己通过 <a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/Documentation/x86/boot.txt?v=3.18#L156">boot protocol</a> 来了解这些设置, 在内核被引导入内存后，内存使用情况将如下表所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">         | Protected-mode kernel  |</span><br><span class="line">100000   +------------------------+</span><br><span class="line">         | I/O memory hole        |</span><br><span class="line">0A0000   +------------------------+</span><br><span class="line">         | Reserved for BIOS      | Leave as much as possible unused</span><br><span class="line">         ~                        ~</span><br><span class="line">         | Command line           | (Can also be below the X+10000 mark)</span><br><span class="line">X+10000  +------------------------+</span><br><span class="line">         | Stack/heap             | For use by the kernel real-mode code.</span><br><span class="line">X+08000  +------------------------+</span><br><span class="line">         | Kernel setup           | The kernel real-mode code.</span><br><span class="line">         | Kernel boot sector     | The kernel legacy boot sector.</span><br><span class="line">       X +------------------------+</span><br><span class="line">         | Boot loader            | &lt;- Boot sector entry point 0x7C00</span><br><span class="line">001000   +------------------------+</span><br><span class="line">         | Reserved for MBR/BIOS  |</span><br><span class="line">000800   +------------------------+</span><br><span class="line">         | Typically used by MBR  |</span><br><span class="line">000600   +------------------------+</span><br><span class="line">         | BIOS use only          |</span><br><span class="line">000000   +------------------------+</span><br></pre></td></tr></table></figure>
<p>所以当 bootloader 完成任务，将执行权移交给 kernel，kernel 的代码从以下地址开始执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X + sizeof(KernelBootSector) + 1                 //`X` 是 kernel bootsector 被引导入内存的位置</span><br></pre></td></tr></table></figure>
<p>我们可以通过 memory dump 来检查这个地址, 到这里，引导程序完成它的使命，并将控制权移交给了 Linux kernel。下面我们就来看看 kernel setup code 都做了些什么。</p>
<h3 id="内核设置">内核设置</h3>
<p>经过上面的一系列操作，我们终于进入到内核了。不过从技术上说，内核还没有被运行起来，因为首先我们需要正确设置内核，启动内存管理，进程管理等等。内核设置代码的运行起点是 arch/x86/boot/header.S中定义的 _start函数。 在 <code>_start</code> 函数开始之前，还有很多的代码，那这些代码是做什么的呢？</p>
<p>实际上 <code>_start</code> 开始之前的代码是 kernel 自带的 bootloader。在很久以前，是可以使用这个 bootloader 来启动 Linux 的。不过在新的 Linux 中，这个 bootloader 代码已经不再启动 Linux 内核，而只是输出一个错误信息。</p>
<p>为了能够作为 bootloader 来使用, <code>header.S</code> 开始处定义了 [MZ] <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/DOS_MZ_executable">MZ</a> 魔术数字, 并且定义了 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Portable_Executable">PE</a> 头，在 PE 头中定义了输出的字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CONFIG_EFI_STUB</span><br><span class="line"># &quot;MZ&quot;, MS-DOS header</span><br><span class="line">.byte 0x4d</span><br><span class="line">.byte 0x5a</span><br><span class="line">#endif</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">pe_header:</span><br><span class="line">	.ascii &quot;PE&quot;</span><br><span class="line">	.word 0</span><br></pre></td></tr></table></figure>
<p>之所以代码需要这样写，这个是因为遵从 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface">UEFI</a> 的硬件需要这样的结构才能正常引导操作系统。</p>
<p>去除这些作为 bootloader 使用的代码，真正的内核代码就从 <code>_start</code> 开始了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// header.S line 292</span><br><span class="line">.globl _start</span><br><span class="line">_start:</span><br></pre></td></tr></table></figure>
<p>其他的 bootloader (grub2 and others) 知道 _start 所在的位置（ 从 <code>MZ</code> 头开始偏移 <code>0x200</code> 字节 ），所以这些 bootloader 就会忽略所有在这个位置前的代码（这些之前的代码位于 <code>.bstext</code> 段中）， 直接跳转到这个位置启动内核。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// arch/x86/boot/setup.ld</span><br><span class="line">//</span><br><span class="line">. = 0;                    // current position</span><br><span class="line">.bstext : &#123; *(.bstext) &#125;  // put .bstext section to position 0</span><br><span class="line">.bsdata : &#123; *(.bsdata) &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	.globl _start</span><br><span class="line">_start:</span><br><span class="line">	.byte 0xeb</span><br><span class="line">	.byte start_of_setup-1f</span><br><span class="line">1:</span><br><span class="line">	//</span><br><span class="line">	// rest of the header</span><br><span class="line">	//</span><br></pre></td></tr></table></figure>
<p><code>_start</code> 开始就是一个 <code>jmp</code> 语句（<code>jmp</code> 语句的 opcode 是 <code>0xeb</code> ），跟在后面的是一个相对地址 （ <code>start_of_setup - 1f </code> ）。在汇编代码中 <code>Nf</code> 代表了当前代码之后第一个标号为 <code>N</code> 的代码段的地址。回到我们的代码，在 <code>_start</code> 标号之后的第一个标号为 <code>1</code> 的代码段中包含了剩下的 setup header 结构。在标号为 <code>1</code> 的代码段结束之后，紧接着就是标号为 <code>start_of_setup</code> 的代码段 （这个代码段中的第一条指令实际上是内核开始执行之后的第一条指令） 。</p>
<p>下面让我们来看一下 GRUB2 的代码是如何跳转到 <code>_start</code> 标号处的。从 Linux 内核代码中，我们知道 <code>_start</code> 标号的代码位于偏移 <code>0x200</code> 处。在 GRUB2 的源代码中我们可以看到下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">state.gs = state.fs = state.es = state.ds = state.ss = segment;</span><br><span class="line">state.cs = segment + 0x20;</span><br></pre></td></tr></table></figure>
<p>在我的机器上，因为我的内核代码被加载到了内存地址 <code>0x10000</code> 处，所以在上面的代码执行完成之后 <code>cs = 0x1020</code> （ 因此第一条指令的内存地址将是 <code>cs &lt;&lt; 4 + 0 = 0x10200</code>，刚好是 <code>0x10000</code> 开始后的 <code>0x200</code> 处的指令）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fs = es = ds = ss = 0x1000</span><br><span class="line">cs = 0x1020</span><br></pre></td></tr></table></figure>
<p>从 <code>start_of_setup</code> 标号开始的代码需要完成下面这些事情：</p>
<ul>
<li>将所有段寄存器的值设置成一样的内容</li>
<li>设置堆栈</li>
<li>设置 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/.bss">bss</a> （静态变量区）</li>
<li>跳转到main.c</li>
</ul>
<h3 id="段寄存器设置">段寄存器设置</h3>
<p>首先，内核保证将 <code>ds</code> 和 <code>es</code> 段寄存器指向相同地址，随后，使用 <code>cld</code> 指令来清理方向标志位：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movw	%ds, %ax</span><br><span class="line">movw	%ax, %es</span><br><span class="line">cld</span><br></pre></td></tr></table></figure>
<p>为了能够跳转到 <code>_start</code> 标号出执行代码，grub2 将 <code>cs</code> 段寄存器的值设置成了 <code>0x1020</code>，<strong>这个值和其他段寄存器都是不一样的</strong>，因此下面的代码就是将 <code>cs</code> 段寄存器的值和其他段寄存器一致：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pushw	%ds</span><br><span class="line">pushw	$6f</span><br><span class="line">lretw</span><br></pre></td></tr></table></figure>
<p>上面的代码使用了一个小小的技巧lretw(“Load Return with Word Return”)来重置 <code>cs</code> 寄存器的内容，下面我们就来仔细分析。 这段代码首先将 <code>ds</code>寄存器的值入栈，然后将标号为 6的代码段地址入栈 ，接着执行 <code>lretw</code> 指令，这条指令，将把标号为 <code>6</code> 的内存地址放入 <code>ip</code> 寄存器 （<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Program_counter">instruction pointer</a>），将 <code>ds</code> 寄存器的值放入 <code>cs</code> 寄存器。 这样一来 <code>ds</code> 和 <code>cs</code> 段寄存器就拥有了相同的值。</p>
<h3 id="设置堆栈">设置堆栈</h3>
<p>绝大部分的 setup 代码都是为 C 语言运行环境做准备。在设置了 <code>ds</code> 和 <code>es</code> 寄存器之后，接下来step 的代码将检查 <code>ss</code> 寄存器的内容，如果寄存器的内容不对，那么将进行更正：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movw	%ss, %dx</span><br><span class="line">cmpw	%ax, %dx</span><br><span class="line">movw	%sp, %dx</span><br><span class="line">je	2f</span><br></pre></td></tr></table></figure>
<p>当进入这段代码的时候， <code>ss</code> 寄存器的值可能是一下三种情况之一：</p>
<ul>
<li><code>ss</code> 寄存器的值是 0x10000 ( 和其他除了 <code>cs</code> 寄存器之外的所有寄存器的一样）</li>
<li><code>ss</code> 寄存器的值不是 0x10000，但是 <code>CAN_USE_HEAP</code> 标志被设置了</li>
<li><code>ss</code> 寄存器的值不是 0x10000，同时 <code>CAN_USE_HEAP</code> 标志没有被设置</li>
</ul>
<p>下面我们就来分析在这三中情况下，代码都是如何工作的：</p>
<ul>
<li><code>ss</code> 寄存器的值是 0x10000，在这种情况下，代码将直接跳转到标号为 <code>2</code> 的代码处执行:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2: 	andw	$~3, %dx</span><br><span class="line">	jnz	3f</span><br><span class="line">	movw	$0xfffc, %dx</span><br><span class="line">3:  movw	%ax, %ss</span><br><span class="line">	movzwl %dx, %esp</span><br><span class="line">	sti</span><br></pre></td></tr></table></figure>
<p>这段代码首先将 <code>dx</code> 寄存器的值（就是当前<code>sp</code> 寄存器的值）4字节对齐，然后检查是否为0（如果是0，堆栈就不对了，因为堆栈是从大地址向小地址发展的），如果是0，那么就将 <code>dx</code> 寄存器的值设置成 <code>0xfffc</code> （64KB地址段的最后一个4字节地址）。如果不是0，那么就保持当前值不变。接下来，就将 <code>ax</code> 寄存器的值（ 0x10000 ）设置到 <code>ss</code> 寄存器，并根据 <code>dx</code> 寄存器的值设置正确的 <code>sp</code>。这样我们就得到了正确的堆栈设置，具体请参考下图：</p>
<img src="https://raw.githubusercontent.com/BlackForest1990/Mypic/img/img/image-20240322132349330.png" alt="image-20240322132349330" style="zoom:50%;">
<ul>
<li>下面让我们来看 <code>ss</code> != <code>ds</code>的情况，首先将 setup code 的结束地址_end写入 <code>dx</code> 寄存器。然后检查 <code>loadflags</code> 中是否设置了 <code>CAN_USE_HEAP</code> 标志。 根据 kernel boot protocol 的定义，loadflags是一个标志字段。这个字段的 <code>Bit 7</code> 就是 <code>CAN_USE_HEAP</code> 标志：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> Field name:	loadflags</span><br><span class="line"></span><br><span class="line"> This field is a bitmask.</span><br><span class="line"></span><br><span class="line"> Bit 7 (write): CAN_USE_HEAP</span><br><span class="line">Set this bit to 1 to indicate that the value entered in the</span><br><span class="line">heap_end_ptr is valid.  If this field is clear, some setup code</span><br><span class="line">functionality will be disabled.</span><br></pre></td></tr></table></figure>
<p><code>loadflags</code> 字段其他可以设置的标志包括：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOADED_HIGH	    (1&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUIET_FLAG	    (1&lt;&lt;5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEEP_SEGMENTS	(1&lt;&lt;6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAN_USE_HEAP	(1&lt;&lt;7)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">movw	$_end, %dx</span><br><span class="line">	testb	$CAN_USE_HEAP, loadflags</span><br><span class="line">	jz	1f</span><br><span class="line">	movw	heap_end_ptr, %dx</span><br><span class="line">1:	addw	$STACK_SIZE, %dx</span><br><span class="line">	jnc	2f</span><br><span class="line">	xorw	%dx, %dx	# Prevent wraparound</span><br><span class="line"></span><br><span class="line">2:	# Now %dx should point to the end of our stack space</span><br><span class="line">	andw	$~3, %dx	# dword align (might as well...)</span><br><span class="line">	jnz	3f</span><br><span class="line">	movw	$0xfffc, %dx	# Make sure we&#x27;re not zero</span><br><span class="line">3:	movw	%ax, %ss</span><br><span class="line">	movzwl	%dx, %esp	# Clear upper half of %esp</span><br><span class="line">	sti			# Now we should have a working stack</span><br></pre></td></tr></table></figure>
<p>如果 <code>CAN_USE_HEAP</code> 被置位，那么将 <code>heap_end_ptr</code> 放入 <code>dx</code> 寄存器，然后加上 <code>STACK_SIZE</code> （最小堆栈大小是 512 bytes）。在加法完成之后，如果结果没有溢出，那么就跳转到标号为 <code>2</code> 的代码处继续执行，接着我们就得到了如下图所示的堆栈：</p>
<img src="https://raw.githubusercontent.com/BlackForest1990/Mypic/img/img/image-20240322133703849.png" alt="image-20240322133703849" style="zoom:50%;">
<ul>
<li>最后一种情况就是 <code>CAN_USE_HEAP</code> 没有置位， 那么我们就将 <code>dx</code> 寄存器的值加上 <code>STACK_SIZE</code>，然后跳转到标号为 <code>2</code> 的代码处继续执行，接着我们就得到了如下图所示的堆栈：</li>
</ul>
<img src="https://raw.githubusercontent.com/BlackForest1990/Mypic/img/img/image-20240322134335050.png" alt="image-20240322134335050" style="zoom:50%;">
<h3 id="BSS段设置">BSS段设置</h3>
<p>在我们正式执行 C 代码之前，我们还有2件事情需要完成。1）设置正确的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/.bss">BSS</a>段 ；2）检查 <code>magic</code> 签名。接下来的代码，首先检查 <code>magic</code> 签名 setup_sig，如果签名不对，直接跳转到 <code>setup_bad</code> 部分执行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmpl	$0x5a5aaa55, setup_sig</span><br><span class="line">jne	setup_bad</span><br></pre></td></tr></table></figure>
<p>BSS 段用来存储那些没有被初始化的静态变量。对于这个段使用的内存， Linux 首先使用下面的代码将其全部清零：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">movw	$__bss_start, %di</span><br><span class="line">movw	$_end+3, %cx</span><br><span class="line">xorl	%eax, %eax</span><br><span class="line">subw	%di, %cx</span><br><span class="line">shrw	$2, %cx</span><br><span class="line">rep; stosl</span><br></pre></td></tr></table></figure>
<p>在这段代码中，首先将__bss_start地址放入 <code>di</code> 寄存器，然后将 <code>_end + 3</code> （4字节对齐） 地址放入 <code>cx</code>，接着使用 <code>xor</code> 指令将 <code>ax</code> 寄存器清零，接着计算 BSS 段的大小 （ <code>cx</code> - <code>di</code> ），然后将大小放入 <code>cx</code> 寄存器。接下来将 <code>cx</code> 寄存器除4，最后使用 <code>rep; stosl</code> 指令将 <code>ax</code> 寄存器的值（0）写入 寄存器整个 BSS 段。 代码执行完成之后，我们将得到如下图所示的 BSS 段:</p>
<img src="https://raw.githubusercontent.com/BlackForest1990/Mypic/img/img/image-20240322140107985.png" alt="image-20240322140107985" style="zoom:50%;">
<h3 id="跳转到-main-函数">跳转到 main 函数</h3>
<p>到目前为止，我们完成了堆栈和 BSS 的设置，现在我们可以正式跳入 <code>main()</code> 函数来执行 C 代码了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call main</span><br></pre></td></tr></table></figure>
<p><code>main()</code> 函数定义在 arch/x86/boot/main.c。</p>
<h2 id="在内核安装代码的第一步">在内核安装代码的第一步</h2>
<h3 id="保护模式">保护模式</h3>
<p>在操作系统可以使用Intel 64位CPU的<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Long_mode">长模式</a>之前，内核必须首先将CPU切换到保护模式运行。什么是<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Protected_mode">保护模式</a>？保护模式于1982年被引入到Intel CPU家族，并且从那之后，直到Intel 64出现，保护模式都是Intel CPU的主要运行模式。淘汰<a target="_blank" rel="noopener" href="http://wiki.osdev.org/Real_Mode">实模式</a>的主要原因是因为在实模式下，系统能够访问的内存非常有限。<strong>在实模式下，系统最多只能访问1M内存，而且在很多时候，实际能够访问的内存只有640K</strong>。</p>
<p>保护模式带来了很多的改变，不过主要的改变都集中在内存管理方法。在保护模式中，实模式的20位地址线被替换成32位地址线，因此系统可以访问多达4GB的地址空间。另外，在保护模式中引入了<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Paging">内存分页</a>功能。</p>
<p>保护模式提供了2种完全不同的内存管理机制：</p>
<ul>
<li>段式内存管理</li>
<li>内存分页</li>
</ul>
<p>在保护模式中，内存段的定义和实模式完全不同。在保护模式中，每个内存段不再是64K大小，段的大小和起始位置是通过一个叫做<code>段描述符</code>的数据结构进行描述。所有内存段的段描述符存储在一个叫做<code>全局描述符表</code>(GDT)的内存结构中。</p>
<p><code>全局描述符表</code>这个内存数据结构在内存中的位置并不是固定的，它的地址保存在一个特殊寄存器 <code>GDTR</code> 中。具体的汇编代码看起来是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lgdt gdt</span><br></pre></td></tr></table></figure>
<p><code>lgdt</code> 汇编代码将把全局描述符表的基地址和大小保存到 <code>GDTR</code> 寄存器中。<code>GDTR</code> 是一个48位的寄存器，这个寄存器中的保存了2部分的内容:</p>
<ul>
<li>全局描述符表的大小 (16位）</li>
<li>全局描述符表的基址 (32位)</li>
</ul>
<p>全局描述符表包含了所有内存段的<code>段描述符</code>。每个段描述符长度是64位，结构如下图描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">31          24        19      16              7            0</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">|             | |B| |A|       | |   | |0|E|W|A|            |</span><br><span class="line">| BASE 31:24  |G|/|L|V| LIMIT |P|DPL|S|  TYPE | BASE 23:16 | 4</span><br><span class="line">|             | |D| |L| 19:16 | |   | |1|C|R|A|            |</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">|                             |                            |</span><br><span class="line">|        BASE 15:0            |       LIMIT 15:0           | 0</span><br><span class="line">|                             |                            |</span><br><span class="line">------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>Limit[20位] 被保存在上述内存结构的0-15和48-51位</strong>。根据上述内存结构中<code>G</code>位的设置，这20位内存定义的内存长度是不一样的。下面是一些具体的例子：</li>
</ol>
<ul>
<li>如果<code>G</code> = 0, 并且Limit = 0， 那么表示段长度是1 byte</li>
<li>如果<code>G</code> = 1, 并且Limit = 0, 那么表示段长度是4K bytes</li>
<li>如果<code>G</code> = 0，并且Limit = 0xfffff，那么表示段长度是1M bytes</li>
<li>如果<code>G</code> = 1，并且Limit = 0xfffff，那么表示段长度是4G bytes</li>
</ul>
<p>从上面的例子我们可以看出：</p>
<ul>
<li>如果G = 0, 那么内存段的长度是按照1 byte进行增长的 ( Limit每增加1，段长度增加1 byte )，最大的内存段长度将是1M bytes；</li>
<li>如果G = 1, 那么内存段的长度是按照4K bytes进行增长的 ( Limit每增加1，段长度增加4K bytes )，最大的内存段长度将是4G bytes;</li>
<li>段长度的计算公式是 base_seg_length * ( LIMIT + 1)。</li>
</ul>
<ol start="2">
<li>Base[32-bits] 被保存在上述地址结构的0-15， 32-39以及56-63位。Base定义了段基址。</li>
<li>Type/Attribute (40-44 bits) 定义了内存段的类型以及支持的操作。</li>
</ol>
<ul>
<li><code>S</code> 标记（ 第44位 ）定义了段的类型，<code>S</code> = 0说明这个内存段是一个系统段；<code>S</code> = 1说明这个内存段是一个代码段或者是数据段（ 堆栈段是一种特殊类型的数据段，堆栈段必须是可以进行读写的段 ）。在<code>S</code> = 1的情况下，上述内存结构的第43位决定了内存段是数据段还是代码段。如果43位 = 0，说明是一个数据段，否则就是一个代码段</li>
</ul>
<p>对于数据段和代码段，下面的表格给出了段类型定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">|           Type Field        | Descriptor Type | Description</span><br><span class="line">|-----------------------------|-----------------|------------------</span><br><span class="line">| Decimal                     |                 |</span><br><span class="line">|             0    E    W   A |                 |</span><br><span class="line">| 0           0    0    0   0 | Data            | Read-Only</span><br><span class="line">| 1           0    0    0   1 | Data            | Read-Only, accessed</span><br><span class="line">| 2           0    0    1   0 | Data            | Read/Write</span><br><span class="line">| 3           0    0    1   1 | Data            | Read/Write, accessed</span><br><span class="line">| 4           0    1    0   0 | Data            | Read-Only, expand-down</span><br><span class="line">| 5           0    1    0   1 | Data            | Read-Only, expand-down, accessed</span><br><span class="line">| 6           0    1    1   0 | Data            | Read/Write, expand-down</span><br><span class="line">| 7           0    1    1   1 | Data            | Read/Write, expand-down, accessed</span><br><span class="line">|                  C    R   A |                 |</span><br><span class="line">| 8           1    0    0   0 | Code            | Execute-Only</span><br><span class="line">| 9           1    0    0   1 | Code            | Execute-Only, accessed</span><br><span class="line">| 10          1    0    1   0 | Code            | Execute/Read</span><br><span class="line">| 11          1    0    1   1 | Code            | Execute/Read, accessed</span><br><span class="line">| 12          1    1    0   0 | Code            | Execute-Only, conforming</span><br><span class="line">| 14          1    1    0   1 | Code            | Execute-Only, conforming, accessed</span><br><span class="line">| 13          1    1    1   0 | Code            | Execute/Read, conforming</span><br><span class="line">| 15          1    1    1   1 | Code            | Execute/Read, conforming, accessed</span><br></pre></td></tr></table></figure>
<p>从上面的表格我们可以看出，当第43位是<code>0</code>的时候，这个段描述符对应的是一个数据段，如果该位是<code>1</code>，那么表示这个段描述符对应的是一个代码段。对于数据段，第42，41，40位表示的是(<em>E</em>扩展，<em>W</em>可写，<em>A</em>可访问）；对于代码段，第42，41，40位表示的是(<em>C</em>一致，<em>R</em>可读，<em>A</em>可访问）。</p>
<ul>
<li>如果<code>E</code> = 0，数据段是向上扩展数据段，反之为向下扩展数据段。关于向上扩展和向下扩展数据段，可以参考下面的<a target="_blank" rel="noopener" href="http://www.sudleyplace.com/dpmione/expanddown.html">链接</a>。在一般情况下，应该是不会使用向下扩展数据段的。</li>
<li>如果<code>W</code> = 1，说明这个数据段是可写的，否则不可写。所有数据段都是可读的。</li>
<li>A位表示该内存段是否已经被CPU访问。</li>
<li>如果<code>C</code> = 1，说明这个代码段可以被低优先级的代码访问，比如可以被用户态代码访问。反之如果<code>C</code> = 0，说明只能同优先级的代码段可以访问。</li>
<li>如果<code>R</code> = 1，说明该代码段可读。代码段是永远没有写权限的。</li>
</ul>
<ol start="4">
<li>DPL（2-bits, bit 45 和 46）定义了该段的优先级。具体数值是0-3。</li>
<li>P 标志(bit 47) - 说明该内存段是否已经存在于内存中。如果<code>P</code> = 0，那么在访问这个内存段的时候将报错。</li>
<li>AVL 标志(bit 52) - 这个位在Linux内核中没有被使用。</li>
<li>L 标志(bit 53) - 只对代码段有意义，如果<code>L</code> = 1，说明该代码段需要运行在64位模式下。</li>
<li>D/B flag(bit 54) - 根据段描述符描述的是一个可执行代码段、下扩数据段还是一个堆栈段，这个标志具有不同的功能。（对于32位代码和数据段，这个标志应该总是设置为1；对于16位代码和数据段，这个标志被设置为0。）。
<ul>
<li>可执行代码段。此时这个标志称为D标志并用于指出该段中的指令引用有效地址和操作数的默认长度。如果该标志置位，则默认值是32位地址和32位或8位的操作数；如果该标志为0，则默认值是16位地址和16位或8位的操作数。指令前缀0x66可以用来选择非默认值的操作数大小；前缀0x67可用来选择非默认值的地址大小。</li>
<li>栈段（由SS寄存器指向的数据段）。此时该标志称为B（Big）标志，用于指明隐含堆栈操作（如PUSH、POP或CALL）时的栈指针大小。如果该标志置位，则使用32位栈指针并存放在ESP寄存器中；如果该标志为0，则使用16位栈指针并存放在SP寄存器中。如果堆栈段被设置成一个下扩数据段，这个B标志也同时指定了堆栈段的上界限。</li>
<li>下扩数据段。此时该标志称为B标志，用于指明堆栈段的上界限。如果设置了该标志，则堆栈段的上界限是0xFFFFFFFF（4GB）；如果没有设置该标志，则堆栈段的上界限是0xFFFF（64KB）。</li>
</ul>
</li>
</ol>
<p>在保护模式下，段寄存器保存的不再是一个内存段的基地址，而是一个称为<code>段选择子</code>的结构。每个段描述符都对应一个<code>段选择子</code>。<code>段选择子</code>是一个16位的数据结构，下图显示了这个数据结构的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------</span><br><span class="line">|       Index    | TI | RPL |</span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure>
<p>其中，</p>
<ul>
<li><strong>Index</strong> 表示在GDT中，对应段描述符的索引号。</li>
<li><strong>TI</strong> 表示要在GDT还是LDT中查找对应的段描述符</li>
<li><strong>RPL</strong> 表示请求者优先级。这个优先级将和段描述符中的优先级协同工作，共同确定访问是否合法。</li>
</ul>
<p>在保护模式下，每个段寄存器实际上包含下面2部分内容：</p>
<ul>
<li>可见部分 - 段选择子</li>
<li>隐藏部分 - 段描述符</li>
</ul>
<p>在保护模式中，cpu是通过下面的步骤来找到一个具体的物理地址的：</p>
<ul>
<li>代码必须将相应的<code>段选择子</code>装入某个段寄存器</li>
<li>CPU根据<code>段选择子</code>从GDT中找到一个匹配的段描述符，然后将段描述符放入段寄存器的隐藏部分</li>
<li>在没有使用向下扩展段的时候，那么内存段的基地址就是<code>段描述符中的基地址</code>，段描述符的<code>limit + 1</code>就是内存段的长度。如果你知道一个内存地址的<code>偏移</code>，那么在没有开启分页机制的情况下，这个内存的物理地址就是<code>基地址+偏移</code></li>
</ul>
<img src="/2024/03/21/Linux-Booting/Users\Micheal\AppData\Roaming\Typora\typora-user-images\image-20240401135815674.png" alt="image-20240401135815674" style="zoom:50%;">
<p>当代码要从实模式进入保护模式的时候，需要执行下面的操作：</p>
<ul>
<li>禁止中断发生</li>
<li>使用命令 <code>lgdt</code> 将GDT表装入 <code>GDTR</code> 寄存器</li>
<li>设置CR0寄存器的PE位为1，使CPU进入保护模式</li>
<li>跳转开始执行保护模式代码</li>
</ul>
<h3 id="将启动参数拷贝到-zeropage">将启动参数拷贝到&quot;zeropage&quot;</h3>
<p>让我们从<code>main</code>函数开始看起，这个函数中，首先调用了<code>copy_boot_params(void)</code>。</p>
<p>这个函数将内核设置信息拷贝到<code>boot_params</code>结构的相应字段。大家可以在arch/x86/include/uapi/asm/bootparam.h找到<code>boot_params</code>结构的定义。</p>
<p><code>boot_params</code>结构中包含<code>struct setup_header hdr</code>字段。这个结构包含了<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/x86/boot.txt">linux boot protocol</a>中定义的相同字段，并且由boot loader填写。在内核编译的时候<code>copy_boot_params</code>完成两个工作：</p>
<ol>
<li>将header.S中定义的 <code>hdr</code> 结构中的内容拷贝到 <code>boot_params</code> 结构的字段 <code>struct setup_header hdr</code> 中。</li>
<li>如果内核是通过老的命令行协议运行起来的，那么就更新内核的命令行指针。</li>
</ol>
<p>这里需要注意的是拷贝 <code>hdr</code> 数据结构的 <code>memcpy</code> 函数不是C语言中的函数，而是定义在 copy.S。让我们来具体分析一下这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GLOBAL(memcpy)</span><br><span class="line">	pushw	%si          ;push si to stack</span><br><span class="line">	pushw	%di          ;push di to stack</span><br><span class="line">	movw	%ax, %di     ;move &amp;boot_param.hdr to di</span><br><span class="line">	movw	%dx, %si     ;move &amp;hdr to si</span><br><span class="line">	pushw	%cx          ;push cx to stack ( sizeof(hdr) )</span><br><span class="line">	shrw	$2, %cx    </span><br><span class="line">	rep; movsl           ;copy based on 4 bytes</span><br><span class="line">	popw	%cx          ;pop cx</span><br><span class="line">	andw	$3, %cx      ;cx = cx % 4</span><br><span class="line">	rep; movsb           ;copy based on one byte</span><br><span class="line">	popw	%di</span><br><span class="line">	popw	%si</span><br><span class="line">	retl</span><br><span class="line">ENDPROC(memcpy)</span><br></pre></td></tr></table></figure>
<p>在<code>copy.S</code>文件中，你可以看到所有的方法都开始于 <code>GLOBAL</code> 宏定义，而结束于 <code>ENDPROC</code> 宏定义。</p>
<p>你可以在 arch/x86/include/asm/linkage.h中找到 <code>GLOBAL</code> 宏定义。这个宏给代码段分配了一个名字标签，并且让这个名字全局可用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define GLOBAL(name)	\</span><br><span class="line">	.globl name;	\</span><br><span class="line">	name:</span><br></pre></td></tr></table></figure>
<p>你可以在include/linux/linkage.h中找到 <code>ENDPROC</code> 宏的定义。 这个宏通过 <code>END(name)</code> 代码标识了汇编函数的结束，同时将函数名输出，从而静态分析工具可以找到这个函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define ENDPROC(name) \</span><br><span class="line">	.type name, @function ASM_NL \</span><br><span class="line">	END(name)</span><br></pre></td></tr></table></figure>
<p><code>memcpy</code> 的实现代码是很容易理解的。首先，代码将 <code>si</code> 和 <code>di</code> 寄存器的值压入堆栈进行保存，这么做的原因是因为后续的代码将修改 <code>si</code> 和 <code>di</code> 寄存器的值。<code>memcpy</code> 函数（也包括其他定义在copy.s中的其他函数）使用了 <code>fastcall</code> 调用规则，意味着所有的函数调用参数是通过 <code>ax</code>, <code>dx</code>, <code>cx</code>寄存器传入的，而不是传统的通过堆栈传入。因此在使用下面的代码调用 <code>memcpy</code> 函数的时候</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(&amp;boot_params.hdr, &amp;hdr, <span class="keyword">sizeof</span> hdr);</span><br></pre></td></tr></table></figure>
<p>函数的参数是这样传递的</p>
<ul>
<li><code>ax</code> 寄存器指向 <code>boot_param.hdr</code> 的内存地址</li>
<li><code>dx</code> 寄存器指向 <code>hdr</code> 的内存地址</li>
<li><code>cx</code> 寄存器包含 <code>hdr</code> 结构的大小</li>
</ul>
<p><code>memcpy</code> 函数在将 <code>si</code> 和 <code>di</code> 寄存器压栈之后，将 <code>boot_param.hdr</code> 的地址放入 <code>di</code> 寄存器，将 <code>hdr</code> 的地址放入 <code>si</code> 寄存器，并且将 <code>hdr</code> 数据结构的大小压栈。 接下来代码首先以4个字节为单位，将 <code>si</code> 寄存器指向的内存内容拷贝到 <code>di</code> 寄存器指向的内存。当剩下的字节数不足4字节的时候，代码将原始的 <code>hdr</code> 数据结构大小出栈放入 <code>cx</code> ，<strong>然后对 <code>cx</code> 的值对4求模，接下来就是根据 <code>cx</code> 的值，以字节为单位将 <code>si</code> 寄存器指向的内存内容拷贝到 <code>di</code> 寄存器指向的内存</strong>。当拷贝操作完成之后，将保留的 <code>si</code> 以及 <code>di</code> 寄存器值出栈，函数返回。</p>
<h3 id="控制台初始化">控制台初始化</h3>
<p>在 <code>hdr</code> 结构体被拷贝到 <code>boot_params.hdr</code> 成员之后，系统接下来将进行控制台的初始化。控制台初始化时通过调用arch/x86/boot/early_serial_console.c中定义的 <code>console_init</code> 函数实现的。</p>
<p>这个函数首先查看命令行参数是否包含 <code>earlyprintk</code> 选项。如果命令行参数包含该选项，那么函数将分析这个选项的内容。得到控制台将使用的串口信息，然后进行串口的初始化。以下是 <code>earlyprintk</code> 选项可能的取值：</p>
<ul>
<li>serial,0x3f8,115200</li>
<li>serial,ttyS0,115200</li>
<li>ttyS0,115200</li>
</ul>
<p>当串口初始化成功之后，如果命令行参数包含 <code>debug</code> 选项，我们将看到如下的输出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cmdline_find_option_bool(<span class="string">&quot;debug&quot;</span>))</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;early console in setup code\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><code>puts</code> 函数定义在tty.c。这个函数只是简单的调用 <code>putchar</code> 函数将输入字符串中的内容按字节输出。下面让我们来看看 <code>putchar</code>函数的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __attribute__((section(<span class="string">&quot;.inittext&quot;</span>))) <span class="built_in">putchar</span>(<span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\r&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    bios_putchar(ch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (early_serial_base != <span class="number">0</span>)</span><br><span class="line">        serial_putchar(ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>__attribute__((section(&quot;.inittext&quot;)))</code> 说明这段代码将被放入 <code>.inittext</code> 代码段。关于 <code>.inittext</code> 代码段的定义你可以在 setup.ld中找到。</p>
<p>如果需要输出的字符是 <code>\n</code> ，那么 <code>putchar</code> 函数将调用自己首先输出一个字符 <code>\r</code>。接下来，就调用 <code>bios_putchar</code> 函数将字符输出到显示器（使用bios int10中断）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __attribute__((section(<span class="string">&quot;.inittext&quot;</span>))) bios_putchar(<span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">biosregs</span> <span class="title">ireg</span>;</span></span><br><span class="line"></span><br><span class="line">    initregs(&amp;ireg);</span><br><span class="line">    ireg.bx = <span class="number">0x0007</span>;</span><br><span class="line">    ireg.cx = <span class="number">0x0001</span>;</span><br><span class="line">    ireg.ah = <span class="number">0x0e</span>;</span><br><span class="line">    ireg.al = ch;</span><br><span class="line">    intcall(<span class="number">0x10</span>, &amp;ireg, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中 <code>initreg</code> 函数接受一个 <code>biosregs</code> 结构的地址作为输入参数，该函数首先调用 <code>memset</code> 函数将 <code>biosregs</code> 结构体所有成员清0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(reg, <span class="number">0</span>, <span class="keyword">sizeof</span> *reg);</span><br><span class="line">   reg-&gt;eflags |= X86_EFLAGS_CF;</span><br><span class="line">   reg-&gt;ds = ds();</span><br><span class="line">   reg-&gt;es = ds();</span><br><span class="line">   reg-&gt;fs = fs();</span><br><span class="line">   reg-&gt;gs = gs();</span><br></pre></td></tr></table></figure>
<p>下面让我们来看看memset函数的实现 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GLOBAL(memset)</span><br><span class="line">    pushw   %di</span><br><span class="line">    movw    %ax, %di</span><br><span class="line">    movzbl  %dl, %eax</span><br><span class="line">    imull   $0x01010101,%eax</span><br><span class="line">    pushw   %cx</span><br><span class="line">    shrw    $2, %cx</span><br><span class="line">    rep; stosl</span><br><span class="line">    popw    %cx</span><br><span class="line">    andw    $3, %cx</span><br><span class="line">    rep; stosb</span><br><span class="line">    popw    %di</span><br><span class="line">    retl</span><br><span class="line">ENDPROC(memset)</span><br></pre></td></tr></table></figure>
<p>首先你会发现，<code>memset</code> 函数和 <code>memcpy</code> 函数一样使用了 <code>fastcall</code> 调用规则，因此函数的参数是通过 <code>ax</code>，<code>dx</code> 以及 <code>cx</code> 寄存器传入函数内部的。</p>
<p>就像memcpy函数一样，<code>memset</code> 函数一开始将 <code>di</code> 寄存器入栈，然后将 <code>biosregs</code> 结构的地址从 <code>ax</code> 寄存器拷贝到<code>di</code>寄存器。接下来，使用 <code>movzbl</code> 指令将 <code>dl</code> 寄存器的内容拷贝到 <code>ax</code> 寄存器的低字节，到这里 <code>ax</code> 寄存器就包含了需要拷贝到 <code>di</code> 寄存器所指向的内存的值。</p>
<p>接下来的 <code>imull</code> 指令将 <code>eax</code> 寄存器的值乘上 <code>0x01010101</code>。这么做的原因是代码每次将尝试拷贝4个字节内存的内容。下面让我们来看一个具体的例子，假设我们需要将 <code>0x7</code> 这个数值放到内存中，在执行 <code>imull</code> 指令之前，<code>eax</code> 寄存器的值是 <code>0x7</code>，在 <code>imull</code> 指令被执行之后，<strong><code>eax</code> 寄存器的内容变成了 <code>0x07070707</code>（4个字节的 <code>0x7</code>）</strong>。在 <code>imull</code> 指令之后，代码使用 <code>rep; stosl</code> 指令将 <code>eax</code> 寄存器的内容拷贝到 <code>es:di</code> 指向的内存。</p>
<p>在 <code>bisoregs</code> 结构体被 <code>initregs</code> 函数正确填充之后，<code>bios_putchar</code> 调用中断 <a target="_blank" rel="noopener" href="http://www.ctyme.com/intr/rb-0106.htm">0x10</a> 在显示器上输出一个字符。接下来 <code>putchar</code> 函数检查是否初始化了串口，如果串口被初始化了，那么将调用serial_putchar将字符输出到串口。</p>
<h3 id="堆初始化">堆初始化</h3>
<p>当堆栈和bss段在header.S中被初始化之后， 内核需要初始化全局堆，全局堆的初始化是通过 <code>init_heap</code> 函数实现的。</p>
<p>代码首先检查内核设置头中的<code>loadflags</code>是否设置了 <code>CAN_USE_HEAP</code>标志。 如果该标记被设置了，那么代码将计算堆栈的结束地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *stack_end;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//%P1 is (-STACK_SIZE)</span></span><br><span class="line">    <span class="keyword">if</span> (boot_params.hdr.loadflags &amp; CAN_USE_HEAP) &#123;</span><br><span class="line">        <span class="keyword">asm</span>(<span class="string">&quot;leal %P1(%%esp),%0&quot;</span></span><br><span class="line">            : <span class="string">&quot;=r&quot;</span> (stack_end) : <span class="string">&quot;i&quot;</span> (-STACK_SIZE));</span><br></pre></td></tr></table></figure>
<p>换言之<code>stack_end = esp - STACK_SIZE</code>.</p>
<p>在计算了堆栈结束地址之后，代码计算了堆的结束地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//heap_end = heap_end_ptr + 512</span></span><br><span class="line">    heap_end = (<span class="type">char</span> *)((<span class="type">size_t</span>)boot_params.hdr.heap_end_ptr + <span class="number">0x200</span>);</span><br></pre></td></tr></table></figure>
<p>接下来代码判断 <code>heap_end</code> 是否大于 <code>stack_end</code>，如果条件成立，将 <code>stack_end</code> 设置成 <code>heap_end</code>（这么做是因为在大部分系统中全局堆和堆栈是相邻的，但是增长方向是相反的）。</p>
<p>到这里为止，全局堆就被正确初始化了。在全局堆被初始化之后，我们就可以使用 <code>GET_HEAP</code> 方法。</p>
<h3 id="检查CPU类型">检查CPU类型</h3>
<p>在堆栈初始化之后，内核代码通过调用arch/x86/boot/cpu.c提供的 <code>validate_cpu</code> 方法检查CPU级别以确定系统是否能够在当前的CPU上运行。<code>validate_cpu</code> 调用了<code>check_cpu</code>方法得到当前系统的CPU级别，并且和系统预设的最低CPU级别进行比较。如果不满足条件，则不允许系统运行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*from cpu.c*/</span></span><br><span class="line">check_cpu(&amp;cpu_level, &amp;req_level, &amp;err_flags);</span><br><span class="line"><span class="comment">/*after check_cpu call, req_level = req_level defined in cpucheck.c*/</span></span><br><span class="line"><span class="keyword">if</span> (cpu_level &lt; req_level) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This kernel requires an %s CPU, &quot;</span>, cpu_name(req_level)); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;but only detected an %s CPU.\n&quot;</span>, cpu_name(cpu_level));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，<code>check_cpu</code> 方法还做了大量的其他检测和设置工作，下面就简单介绍一些：1）检查cpu标志，如果cpu是64位cpu，那么就设置<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Long_mode">long mode</a>, 2) 检查CPU的制造商，根据制造商的不同，设置不同的CPU选项。比如对于AMD出厂的cpu，如果不支持 <code>SSE+SSE2</code>，那么就禁止这些选项。</p>
<h3 id="内存分布侦测">内存分布侦测</h3>
<p>接下来，内核调用 <code>detect_memory</code> 方法进行内存侦测，以得到系统当前内存的使用分布。该方法使用多种编程接口，包括 <code>0xe820</code>（获取全部内存分配），<code>0xe801</code> 和 <code>0x88</code>（获取临近内存大小），进行内存分布侦测。在这里我们只介绍arch/x86/boot/memory.c中提供的 <code>detect_memory_e820</code> 方法。</p>
<p>该方法首先调用 <code>initregs</code> 方法初始化 <code>biosregs</code> 数据结构，然后向该数据结构填入 <code>0xe820</code> 编程接口所要求的参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">initregs(&amp;ireg);</span><br><span class="line">ireg.ax  = <span class="number">0xe820</span>;</span><br><span class="line">ireg.cx  = <span class="keyword">sizeof</span> buf;</span><br><span class="line">ireg.edx = SMAP;</span><br><span class="line">ireg.di  = (<span class="type">size_t</span>)&amp;buf;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ax</code> 固定为 <code>0xe820</code></li>
<li><code>cx</code> 包含数据缓冲区的大小，该缓冲区将包含系统内存的信息数据</li>
<li><code>edx</code> 必须是 <code>SMAP</code> 这个魔术数字，就是 <code>0x534d4150</code></li>
<li><code>es:di</code> 包含数据缓冲区的地址</li>
<li><code>ebx</code> 必须为0.</li>
</ul>
<p>接下来就是通过一个循环来收集内存信息了。每个循环都开始于一个 <code>0x15</code> 中断调用，这个中断调用返回地址分配表中的一项，接着程序将返回的 <code>ebx</code> 设置到 <code>biosregs</code> 数据结构中，然后进行下一次的 <code>0x15</code> 中断调用。那么循环什么时候结束呢？直到 <code>0x15</code> 调用返回的eflags包含标志 <code>X86_EFLAGS_CF</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">intcall(<span class="number">0x15</span>, &amp;ireg, &amp;oreg);</span><br><span class="line">ireg.ebx = oreg.ebx;</span><br></pre></td></tr></table></figure>
<p>在循环结束之后，整个内存分配信息将被写入到 <code>e820entry</code> 数组中，这个数组的每个元素包含下面3个信息:</p>
<ul>
<li>内存段的起始地址</li>
<li>内存段的大小</li>
<li>内存段的类型（类型可以是reserved, usable等等)。</li>
</ul>
<p>你可以在 <code>dmesg</code> 输出中看到这个数组的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[    0.000000] e820: BIOS-provided physical RAM map:</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x0000000000000000-0x000000000009fbff] usable</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x000000000009fc00-0x000000000009ffff] reserved</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x00000000000f0000-0x00000000000fffff] reserved</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x0000000000100000-0x000000003ffdffff] usable</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x000000003ffe0000-0x000000003fffffff] reserved</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x00000000fffc0000-0x00000000ffffffff] reserved</span><br></pre></td></tr></table></figure>
<h3 id="键盘初始化">键盘初始化</h3>
<p>接下来内核调用<code>keyboard_init()</code>方法进行键盘初始化操作。 首先，方法调用<code>initregs</code>初始化寄存器结构，然后调用<a target="_blank" rel="noopener" href="http://www.ctyme.com/intr/rb-1756.htm">0x16</a>中断来获取键盘状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">initregs(&amp;ireg);</span><br><span class="line">ireg.ah = <span class="number">0x02</span>;     <span class="comment">/* Get keyboard status */</span></span><br><span class="line">intcall(<span class="number">0x16</span>, &amp;ireg, &amp;oreg);</span><br><span class="line">boot_params.kbd_status = oreg.al;</span><br></pre></td></tr></table></figure>
<p>在获取了键盘状态之后，代码再次调用<a target="_blank" rel="noopener" href="http://www.ctyme.com/intr/rb-1757.htm">0x16</a>中断来设置键盘的按键检测频率。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ireg.ax = <span class="number">0x0305</span>;   <span class="comment">/* Set keyboard repeat rate */</span></span><br><span class="line">intcall(<span class="number">0x16</span>, &amp;ireg, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<h2 id="显示模式初始化和进入保护模式">显示模式初始化和进入保护模式</h2>
<p>就像我们前面所说的，我们将从 <code>set_video</code> 函数开始我们这章的内容，你可以在 arch/x86/boot/video.c找到这个函数的定义。 这个函数首先从 <code>boot_params.hdr</code> 数据结构获取显示模式设置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u16 mode = boot_params.hdr.vid_mode;</span><br></pre></td></tr></table></figure>
<p>至于 <code>boot_params.hdr</code> 数据结构中的内容，是通过 <code>copy_boot_params</code> 函数实现的 ，<code>boot_params.hdr</code> 中的 <code>vid_mode</code> 是引导程序必须填入的字段。你可以在 <code>kernel boot protocol</code> 文档中找到关于 <code>vid_mode</code> 的详细信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Offset	Proto	Name		Meaning</span><br><span class="line">/Size</span><br><span class="line">01FA/2	ALL	    vid_mode	Video mode control</span><br></pre></td></tr></table></figure>
<p>而在 <code>linux kernel boot protocol</code> 文档中定义了如何通过命令行参数的方式为 <code>vid_mode</code> 字段传入相应的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">**** SPECIAL COMMAND LINE OPTIONS</span><br><span class="line">vga=&lt;mode&gt;</span><br><span class="line">	&lt;mode&gt; here is either an integer (in C notation, either</span><br><span class="line">	decimal, octal, or hexadecimal) or one of the strings</span><br><span class="line">	&quot;normal&quot; (meaning 0xFFFF), &quot;ext&quot; (meaning 0xFFFE) or &quot;ask&quot;</span><br><span class="line">	(meaning 0xFFFD).  This value should be entered into the</span><br><span class="line">	vid_mode field, as it is used by the kernel before the command</span><br><span class="line">	line is parsed.</span><br></pre></td></tr></table></figure>
<p>根据上面的描述，我们可以通过将 <code>vga</code> 选项写入 grub 或者写到引导程序的配置文件，从而让内核命令行得到相应的显示模式设置信息。这个选项可以接受不同类型的值来表示相同的意思。比如你可以传入 0XFFFD 或者 ask，这2个值都表示需要显示一个菜单让用户选择想要的显示模式。下面的链接就给出了这个菜单：</p>
<img src="/2024/03/21/Linux-Booting/Users\Micheal\AppData\Roaming\Typora\typora-user-images\image-20240402112025623.png" alt="image-20240402112025623" style="zoom:50%;">
<p>通过这个菜单，用户可以选择想要进入的显示模式。不过在我们进一步了解显示模式的设置过程之前，让我们先回头了解一些重要的概念。</p>
<h3 id="内核数据类型">内核数据类型</h3>
<table>
<thead>
<tr>
<th>Type</th>
<th>char</th>
<th>short</th>
<th>int</th>
<th>long</th>
<th>u8</th>
<th>u16</th>
<th>u32</th>
<th>u64</th>
</tr>
</thead>
<tbody>
<tr>
<td>Size</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>8</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>8</td>
</tr>
</tbody>
</table>
<h3 id="堆操作API">堆操作API</h3>
<p>在 <code>set_video</code> 函数将 <code>vid_mod</code> 的值设置完成之后，将调用 <code>RESET_HEAP</code> 宏将 HEAP 头指向 <code>_end</code> 符号。<code>RESET_HEAP</code> 宏定义在 boot.h：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RESET_HEAP() ((void *)( HEAP = _end ))</span></span><br></pre></td></tr></table></figure>
<p>这个宏只是简单的将 HEAP 头设置到 <code>_end</code> 标号。在 <code>boot.h</code> 中通过 <code>extern char _end[];</code> 来引用（从这里可以看出，在内核初始化的时候堆和栈是共享内存空间的）：</p>
<p>下面一个是 <code>GET_HEAP</code> 宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GET_HEAP(type, n) \</span></span><br><span class="line"><span class="meta">	((type *)__get_heap(sizeof(type),__alignof__(type),(n)))</span></span><br></pre></td></tr></table></figure>
<p>可以看出这个宏调用了 <code>__get_heap</code> 函数来进行内存的分配。<code>__get_heap</code> 需要下面3个参数来进行内存分配操作：</p>
<ul>
<li>某个数据类型所占用的字节数</li>
<li><code>__alignof__(type)</code> 返回对于请求的数据类型需要怎样的对齐方式 (  gcc 提供的一个功能 ）</li>
<li><code>n</code> 需要分配多少个对应数据类型的对象</li>
</ul>
<p>下面是 <code>__get_heap</code> 函数的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">char</span> *__get_heap(<span class="type">size_t</span> s, <span class="type">size_t</span> a, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *tmp;</span><br><span class="line"></span><br><span class="line">	HEAP = (<span class="type">char</span> *)(((<span class="type">size_t</span>)HEAP+(a<span class="number">-1</span>)) &amp; ~(a<span class="number">-1</span>));</span><br><span class="line">	tmp = HEAP;</span><br><span class="line">	HEAP += s*n;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在让我们来了解这个函数是如何工作的。 这个函数首先根据对齐方式要求（参数 <code>a</code> ）调整 <code>HEAP</code> 的值，然后将 <code>HEAP</code> 值赋值给一个临时变量 <code>tmp</code>。接下来根据需要分配的对象的个数（参数 <code>n</code> ），预留出所需要的内存，然后将 <code>tmp</code> 返回给调用端。</p>
<p>最后一个关于 HEAP 的操作是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">heap_free</span><span class="params">(<span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">int</span>)(heap_end - HEAP) &gt;= (<span class="type">int</span>)n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数简单做了一个减法 <code>heap_end - HEAP</code>，如果相减的结果大于请求的内存，那么就返回真，否则返回假。</p>
<h3 id="设置显示模式">设置显示模式</h3>
<p>在我们分析了内核数据类型以及和 HEAP 相关的操作之后，让我们回来继续分析显示模式的初始化。在 <code>RESET_HEAP()</code> 函数被调用之后，<code>set_video</code> 函数接着调用 <code>store_mode_params</code> 函数将对应显示模式的相关参数写入 <code>boot_params.screen_info</code> 字段。这个字段的结构定义可以在 include/uapi/linux/screen_info.h中找到。</p>
<p><code>store_mode_params</code> 函数将调用 <code>store_cursor_position</code> 函数将当前屏幕上光标的位置保存起来。下面让我们来看 <code>store_cursor_poistion</code> 函数是如何实现的。</p>
<p>首先函数初始化一个类型为 <code>biosregs</code> 的变量，将其中的 <code>AH</code> 寄存器内容设置成 <code>0x3</code>，然后调用 <code>0x10</code> BIOS 中断。当中断调用返回之后，<code>DL</code> 和 <code>DH</code> 寄存器分别包含了当前光标的行和列信息。接着，这2个信息将被保存到 <code>boot_params.screen_info</code> 字段的 <code>orig_x</code> 和 <code>orig_y</code>字段。</p>
<p>在 <code>store_cursor_position</code> 函数执行完毕之后，<code>store_mode_params</code> 函数将调用 <code>store_video_mode</code> 函数将当前使用的显示模式保存到 <code>boot_params.screen_info.orig_video_mode</code>。</p>
<p>接下來 <code>store_mode_params</code> 函数将根据当前显示模式的设定，给 <code>video_segment</code> 变量设置正确的值（实际上就是设置显示内存的起始地址）。在 BIOS 将控制权转移到引导扇区的时候，显示内存地址和显示模式的对应关系如下表所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0xB000:0x0000 	32 Kb 	Monochrome Text Video Memory</span><br><span class="line">0xB800:0x0000 	32 Kb 	Color Text Video Memory</span><br></pre></td></tr></table></figure>
<p>根据上表，如果当前显示模式是 MDA, HGC 或者单色 VGA 模式，那么 <code>video_sgement</code> 的值将被设置成 <code>0xB000</code>；如果当前显示模式是彩色模式，那么 <code>video_segment</code> 的值将被设置成 <code>0xB800</code>。在这之后，<code>store_mode_params</code> 函数将保存字体大小信息到 <code>boot_params.screen_info.orig_video_points</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存字体大小信息</span></span><br><span class="line">set_fs(<span class="number">0</span>);</span><br><span class="line">font_size = rdfs16(<span class="number">0x485</span>);</span><br><span class="line">boot_params.screen_info.orig_video_points = font_size;</span><br></pre></td></tr></table></figure>
<p>这段代码首先调用 <code>set_fs</code> 函数（在 boot.h中定义了许多类似的函数进行寄存器操作）将数字 <code>0</code> 放入 <code>FS</code> 寄存器。接着从内存地址 <code>0x485</code> 处获取字体大小信息并保存到 <code>boot_params.screen_info.orig_video_points</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = rdfs16(<span class="number">0x44a</span>);</span><br><span class="line">y = (adapter == ADAPTER_CGA) ? <span class="number">25</span> : rdfs8(<span class="number">0x484</span>)+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>接下来代码将从地址 <code>0x44a</code> 处获得屏幕列信息，从地址 <code>0x484</code> 处获得屏幕行信息，并将它们保存到 <code>boot_params.screen_info.orig_video_cols</code> 和 <code>boot_params.screen_info.orig_video_lines</code>。到这里，<code>store_mode_params</code> 的执行就结束了。</p>
<p>接下来，<code>set_video</code> 函数将调用 <code>save_screen</code> 函数将当前屏幕上的所有信息保存到 HEAP 中。这个函数首先获得当前屏幕的所有信息（包括屏幕大小，当前光标位置，屏幕上的字符信息），并且保存到 <code>saved_screen</code> 结构体中。这个结构体的定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">saved_screen</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line">	<span class="type">int</span> curx, cury;</span><br><span class="line">	u16 *data;</span><br><span class="line">&#125; saved;</span><br></pre></td></tr></table></figure>
<p>接下来函数将检查 HEAP 中是否有足够的空间保存这个结构体的数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!heap_free(saved.x*saved.y*<span class="keyword">sizeof</span>(u16)+<span class="number">512</span>))</span><br><span class="line">		<span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<p>如果 HEAP 有足够的空间，代码将在 HEAP 中分配相应的空间并且将 <code>saved_screen</code> 保存到 HEAP。</p>
<p>接下来 <code>set_video</code> 函数将调用 <code>probe_cards(0)</code>（这个函数定义在 arch/x86/boot/video-mode.c）。 这个函数简单遍历所有的显卡，并通过调用驱动程序设置显卡所支持的显示模式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (card = video_cards; card &lt; video_cards_end; card++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (card-&gt;unsafe == unsafe) &#123;</span><br><span class="line">			<span class="keyword">if</span> (card-&gt;probe)</span><br><span class="line">				card-&gt;nmodes = card-&gt;probe();</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				card-&gt;nmodes = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你仔细看上面的代码，你会发现 <code>video_cards</code> 这个变量并没有被声明，那么程序怎么能够正常编译执行呢？实际上很简单，它指向了一个在 arch/x86/boot/setup.ld 中定义的叫做 <code>.videocards</code> 的内存段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.videocards	: &#123;</span><br><span class="line">		video_cards = .;</span><br><span class="line">		*(.videocards)</span><br><span class="line">		video_cards_end = .;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>那么这段内存里面存放的数据是什么呢，下面我们就来详细分析。在内核初始化代码中，对于每个支持的显示模式都是使用下面的代码进行定义的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static __videocard video_vga = &#123;</span><br><span class="line">	.card_name	= &quot;VGA&quot;,</span><br><span class="line">	.probe		= vga_probe,</span><br><span class="line">	.set_mode	= vga_set_mode,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>__videocard</code> 是一个宏定义，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __videocard struct card_info __attribute__((used,section(<span class="string">&quot;.videocards&quot;</span>)))</span></span><br></pre></td></tr></table></figure>
<p>因此 <code>__videocard</code> 是一个 <code>card_info</code> 结构，这个结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">card_info</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *card_name;</span><br><span class="line">	<span class="type">int</span> (*set_mode)(<span class="keyword">struct</span> mode_info *mode);</span><br><span class="line">	<span class="type">int</span> (*probe)(<span class="type">void</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mode_info</span> *<span class="title">modes</span>;</span></span><br><span class="line">	<span class="type">int</span> nmodes;</span><br><span class="line">	<span class="type">int</span> unsafe;</span><br><span class="line">	u16 xmode_first;</span><br><span class="line">	u16 xmode_n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 <code>.videocards</code> 内存段实际上存放的就是所有被内核初始化代码定义的 <code>card_info</code> 结构（可以看成是一个数组），所以 <code>probe_cards</code> 函数可以使用 <code>video_cards</code>，通过循环遍历所有的 <code>card_info</code>。</p>
<p>在 <code>probe_cards</code> 执行完成之后，我们终于进入 <code>set_video</code> 函数的主循环了。在这个循环中，如果 <code>vid_mode=ask</code>，那么将显示一个菜单让用户选择想要的显示模式，然后代码将根据用户的选择或者 <code>vid_mod</code> 的值 ，通过调用 <code>set_mode</code> 函数来设置正确的显示模式。如果设置成功，循环结束，否则显示菜单让用户选择显示模式，继续进行设置显示模式的尝试。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mode == ASK_VGA)</span><br><span class="line">          mode = mode_menu();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!set_mode(mode))</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Undefined video mode number: %x\n&quot;</span>, mode);</span><br><span class="line">      mode = ASK_VGA;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>你可以在 video-mode.c 中找到 <code>set_mode</code> 函数的定义。这个函数只接受一个参数，这个参数是对应的显示模式的数字表示（这个数字来自于显示模式选择菜单，或者从内核命令行参数获得）。</p>
<p><code>set_mode</code> 函数首先检查传入的 <code>mode</code> 参数，然后调用 <code>raw_set_mode</code> 函数。而后者将遍历内核知道的所有 <code>card_info</code> 信息，如果发现某张显卡支持传入的模式，这调用 <code>card_info</code> 结构中保存的 <code>set_mode</code> 函数地址进行显卡显示模式的设置。以 <code>video_vga</code> 这个 <code>card_info</code> 结构来说，保存在其中的 <code>set_mode</code> 函数就指向了 <code>vga_set_mode</code> 函数。下面的代码就是 <code>vga_set_mode</code> 函数的实现，这个函数根据输入的 vga 显示模式，调用不同的函数完成显示模式的设置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">vga_set_mode</span><span class="params">(<span class="keyword">struct</span> mode_info *mode)</span></span><br><span class="line">&#123;</span><br><span class="line">	vga_set_basic_mode();</span><br><span class="line"></span><br><span class="line">	force_x = mode-&gt;x;</span><br><span class="line">	force_y = mode-&gt;y;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (mode-&gt;mode) &#123;</span><br><span class="line">	<span class="keyword">case</span> VIDEO_80x25:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> VIDEO_8POINT:</span><br><span class="line">		vga_set_8font();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> VIDEO_80x43:</span><br><span class="line">		vga_set_80x43();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> VIDEO_80x28:</span><br><span class="line">		vga_set_14font();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> VIDEO_80x30:</span><br><span class="line">		vga_set_80x30();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> VIDEO_80x34:</span><br><span class="line">		vga_set_80x34();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> VIDEO_80x60:</span><br><span class="line">		vga_set_80x60();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，每个 <code>vga_set***</code> 函数只是简单调用 <code>0x10</code> BIOS 中断来进行显示模式的设置。</p>
<p>在显卡的显示模式被正确设置之后，这个最终的显示模式被写回 <code>boot_params.hdr.vid_mode</code>。</p>
<p>接下来 <code>set_video</code> 函数将调用 <code>vesa_store_edid</code> 函数， 这个函数只是简单的将 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Extended_Display_Identification_Data">EDID</a> (<strong>E</strong>xtended <strong>D</strong>isplay <strong>I</strong>dentification <strong>D</strong>ata) 写入内存，以便于内核访问。最后， <code>set_video</code> 将调用 <code>do_restore</code> 函数将前面保存的当前屏幕信息还原到屏幕上。</p>
<p>到这里为止，显示模式的设置完成，接下来我们可以切换到保护模式了。</p>
<h3 id="在切换到保护模式之前的最后准备工作。">在切换到保护模式之前的最后准备工作。</h3>
<p>在进入保护模式之前的最后一个函数调用发生在 main.c中的 <code>go_to_protected_mode</code> 函数，就像这个函数的注释说的，这个函数将进行最后的准备工作然后进入保护模式，下面就让我们来具体看看最后的准备工作是什么，以及系统是如何切换到保护模式的。</p>
<p><code>go_to_protected_mode</code> 函数本身定义在 arch/x86/boot/pm.c。 这个函数调用了一些其他的函数进行最后的准备工作，下面就让我们来具体看看这些函数。</p>
<p><code>go_to_protected_mode</code> 函数首先调用的是 <code>realmode_switch_hook</code> 函数，后者如果发现 <code>realmode_switch</code> hook， 那么将调用它并禁止 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Non-maskable_interrupt">NMI</a> 中断，反之将直接禁止 NMI 中断。只有当 bootloader 运行在宿主环境下（比如在 DOS 下运行 ）， hook 才会被使用。你可以在 <a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/x86/boot.txt">boot protocol</a> (see <strong>ADVANCED BOOT LOADER HOOKS</strong>) 中详细了解 hook 函数的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Invoke the realmode switch hook if present; otherwise</span></span><br><span class="line"><span class="comment"> * disable all interrupts.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">realmode_switch_hook</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (boot_params.hdr.realmode_swtch) &#123;</span><br><span class="line">		<span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;lcallw *%0&quot;</span></span></span><br><span class="line"><span class="params">			     : : <span class="string">&quot;m&quot;</span> (boot_params.hdr.realmode_swtch)</span></span><br><span class="line"><span class="params">			     : <span class="string">&quot;eax&quot;</span>, <span class="string">&quot;ebx&quot;</span>, <span class="string">&quot;ecx&quot;</span>, <span class="string">&quot;edx&quot;</span>)</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">asm</span> <span class="keyword">volatile</span>(<span class="string">&quot;cli&quot;</span>);</span><br><span class="line">		outb(<span class="number">0x80</span>, <span class="number">0x70</span>); <span class="comment">/* Disable NMI */</span></span><br><span class="line">		io_delay();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>realmode_switch</code> 指向了一个16 位实模式代码地址（远跳转指针），这个16位代码将禁止 NMI 中断。所以在上述代码中，如果 <code>realmode_swtch</code> hook 存在，代码是用了 <code>lcallw</code> 指令进行远函数调用。在我的环境中，因为不存在这个 hook ，所以代码是直接进入 <code>else</code> 部分进行了 NMI(Non-Maskable Interrupt)的禁止：代码首先调用 <code>cli</code> 汇编指令清除了中断标志 <code>IF</code>，这条指令执行之后，外部中断就被禁止了，紧接着的下一行代码就禁止了 NMI 中断。</p>
<p>这里简单介绍一下中断。中断是由硬件或者软件产生的，<strong>当中断产生的时候， CPU 将得到通知</strong>。这个时候， <strong>CPU 将停止当前指令的执行，保存当前代码的环境，然后将控制权移交到中断处理程序</strong>。当中断处理程序完成之后，将恢复中断之前的运行环境，从而被中断的代码将继续运行。 NMI 中断是一类特殊的中断，往往预示着系统发生了不可恢复的错误，所以在正常运行的操作系统中，NMI 中断是不会被禁止的，但是在进入保护模式之前，由于特殊需求，代码禁止了这类中断。</p>
<p>现在让我们回到上面的代码，在 NMI 中断被禁止之后（通过写 <code>0x80</code> 进 CMOS 地址寄存器 <code>0x70</code> ），函数接着调用了 <code>io_delay</code> 函数进行了短暂的延时以等待 I/O 操作完成。下面就是 <code>io_delay</code> 函数的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">io_delay</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> u16 DELAY_PORT = <span class="number">0x80</span>;</span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;outb %%al,%0&quot;</span> : : <span class="string">&quot;dN&quot;</span> (DELAY_PORT))</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对 I/O 端口 <code>0x80</code> 写入任何的字节都将得到 1 ms 的延时。在上面的代码中，代码将 <code>al</code> 寄存器中的值写到了这个端口。在这个 <code>io_delay</code> 调用完成之后， <code>realmode_switch_hook</code> 函数就完成了所有工作，下面让我们进入下一个函数。</p>
<p>下一个函数调用是 <code>enable_a20</code>，这个函数使能 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/A20_line">A20 line</a>，你可以在 arch/x86/boot/a20.c找到这个函数的定义，这个函数会尝试使用不同的方式来使能 A20 地址线。首先这个函数将调用 <code>a20_test_short</code>（该函数将调用 <code>a20_test</code> 函数） 来检测 A20 地址线是否已经被激活了:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">a20_test</span><span class="params">(<span class="type">int</span> loops)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ok = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> saved, ctr;</span><br><span class="line"></span><br><span class="line">	set_fs(<span class="number">0x0000</span>);</span><br><span class="line">	set_gs(<span class="number">0xffff</span>);</span><br><span class="line"></span><br><span class="line">	saved = ctr = rdfs32(A20_TEST_ADDR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (loops--) &#123;</span><br><span class="line">		wrfs32(++ctr, A20_TEST_ADDR);</span><br><span class="line">		io_delay();	<span class="comment">/* Serialize and make delay constant */</span></span><br><span class="line">		ok = rdgs32(A20_TEST_ADDR+<span class="number">0x10</span>) ^ ctr;</span><br><span class="line">		<span class="keyword">if</span> (ok)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wrfs32(saved, A20_TEST_ADDR);</span><br><span class="line">	<span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数首先将 <code>0x0000</code> 放入 <code>FS</code> 寄存器，将 <code>0xffff</code> 放入 <code>GS</code> 寄存器。然后通过 <code>rdfs32</code> 函数调用，将 <code>A20_TEST_ADDR</code> 内存地址的内容放入 <code>saved</code> 和 <code>ctr</code> 变量。</p>
<p>接下来我们使用 <code>wrfs32</code> 函数将更新过的 <code>ctr</code> 的值写入 <code>fs:gs</code> ，接着延时 1ms， 然后从 <code>GS:A20_TEST_ADDR+0x10</code> 读取内容，如果该地址内容不为0，那么 A20 已经被激活。如果 A20 没有被激活，代码将尝试使用多种方法进行 A20 地址激活。其中的一种方法就是调用 BIOS <code>0X15</code> 中断激活 A20 地址线。</p>
<p>如果 <code>enabled_a20</code> 函数调用失败，显示一个错误消息并且调用 <code>die</code> 函数结束操作系统运行。<code>die</code> 函数定义在 arch/x86/boot/header.S</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">die:</span><br><span class="line">	hlt</span><br><span class="line">	jmp	die</span><br><span class="line">	.size	die, .-die</span><br></pre></td></tr></table></figure>
<p>A20 地址线被激活之后，<code>reset_coprocessor</code> 函数被调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">outb(<span class="number">0</span>, <span class="number">0xf0</span>);</span><br><span class="line">outb(<span class="number">0</span>, <span class="number">0xf1</span>);</span><br></pre></td></tr></table></figure>
<p>这个函数非常简单，通过将 <code>0</code> 写入 I/O 端口 <code>0xf0</code> 和 <code>0xf1</code> 以复位数字协处理器。</p>
<p>接下来 <code>mask_all_interrupts</code> 函数将被调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">outb(0xff, 0xa1);       /* Mask all interrupts on the secondary PIC */</span><br><span class="line">outb(0xfb, 0x21);       /* Mask all but cascade on the primary PIC */</span><br></pre></td></tr></table></figure>
<p>这个函数调用屏蔽了从中断控制器 (注：中断控制器的原文是 Programmable Interrupt Controller) 的所有中断，和主中断控制器上除IRQ2以外的所有中断（IRQ2是主中断控制器上的级联中断，所有从中断控制器的中断将通过这个级联中断报告给 CPU ）。</p>
<p>到这里位置，我们就完成了所有的准备工作，下面我们就将正式开始从实模式转换到保护模式。</p>
<h3 id="设置中断描述符表">设置中断描述符表</h3>
<p>现在内核将调用 <code>setup_idt</code> 方法来设置中断描述符表（ IDT ）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">setup_idt</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">gdt_ptr</span> <span class="title">null_idt</span> =</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;lidtl %0&quot;</span> : : <span class="string">&quot;m&quot;</span> (null_idt))</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码使用 <code>lidtl</code> 指令将 <code>null_idt</code> 所指向的中断描述符表引入寄存器 IDT。由于 <code>null_idt</code> 没有设定中断描述符表的长度（长度为 0 ），所以这段指令执行之后，实际上没有任何中断调用被设置成功（所有中断调用都是空的）。<code>null_idt</code> 是一个 <code>gdt_ptr</code> 结构的数据，这个结构的定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gdt_ptr</span> &#123;</span></span><br><span class="line">	u16 len;</span><br><span class="line">	u32 ptr;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<p>在上面的定义中，我们可以看到上面这个结构包含一个 16 bit 的长度字段，和一个 32 bit 的指针字段。<code>__attribute__((packed))</code> 意味着这个结构就只包含 48 bit 信息（没有字节对齐优化）。</p>
<h3 id="设置全局描述符表">设置全局描述符表</h3>
<p>在设置完中断描述符表之后，我们将使用 <code>setup_gdt</code> 函数来设置全局描述符表。在 <code>setup_gdt</code> 函数中，使用 <code>boot_gdt</code> 数组定义了需要引入 GDTR 寄存器的段描述符信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> u64 boot_gdt[] __attribute__((aligned(<span class="number">16</span>))) = &#123;</span><br><span class="line">	[GDT_ENTRY_BOOT_CS] = GDT_ENTRY(<span class="number">0xc09b</span>, <span class="number">0</span>, <span class="number">0xfffff</span>),</span><br><span class="line">	[GDT_ENTRY_BOOT_DS] = GDT_ENTRY(<span class="number">0xc093</span>, <span class="number">0</span>, <span class="number">0xfffff</span>),</span><br><span class="line">	[GDT_ENTRY_BOOT_TSS] = GDT_ENTRY(<span class="number">0x0089</span>, <span class="number">4096</span>, <span class="number">103</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上面的 <code>boot_gdt</code> 数组中，我们定义了代码，数据和 TSS 段(Task State Segment, 任务状态段)的段描述符，因为我们并没有设置任何的中断调用（记得上面说的 <code>null_idt</code>吗？），所以 TSS 段并不会被使用到。TSS 段存在的唯一目的就是让 Intel 处理器能够正确进入保护模式。下面让我们详细了解一下 <code>boot_gdt</code> 这个数组，首先，这个数组被 <code>__attribute__((aligned(16)))</code> 修饰，这就意味着这个数组将以 16 字节为单位对齐。</p>
<p>因为在 <code>boot_gdt</code> 的定义中， <code>GDT_ENTRY_BOOT_CS = 2</code>，所以在数组中有2个空项，第一项是一个空的描述符，第二项在代码中没有使用。在没有 <code>align 16</code> 之前，整个结构占用了（8*5=40）个字节，加了 <code>align 16</code> 之后，结构就占用了 48 字节 。</p>
<p>上面代码中出现的 <code>GDT_ENTRY</code> 是一个宏定义，这个宏接受 3 个参数（标志，基地址，段长度）来产生段描述符结构。让我们来具体分析上面数组中的代码段描述符（ <code>GDT_ENTRY_BOOT_CS</code> ）来看看这个宏是如何工作的，对于这个段，<code>GDT_ENTRY</code> 接受了下面 3 个参数：</p>
<ul>
<li>基地址 - 0</li>
<li>段长度 - 0xfffff</li>
<li>标志 - 0xc09b</li>
</ul>
<p>上面这些数字表明，这个段的基地址是 0， 段长度是 <code>0xfffff</code> （ 1 MB ），而标志字段展开之后是下面的二进制数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1100 0000 1001 1011</span><br></pre></td></tr></table></figure>
<p>这些二进制数据的具体含义如下:</p>
<ul>
<li>1 - (G) 这里为 1，表示段的实际长度是 <code>0xfffff * 4kb </code> = <code>4GB</code></li>
<li>1 - (D) 表示这个段是一个32位段</li>
<li>0 - (L) 这个代码段没有运行在 long mode</li>
<li>0 - (AVL) Linux 没有使用</li>
<li>0000 - 段长度的4个位</li>
<li>1 - (P) 段已经位于内存中</li>
<li>00 - (DPL) - 段优先级为0</li>
<li>1 - (S) 说明这个段是一个代码或者数据段</li>
<li>101 - 段类型为可执行/可读</li>
<li>1 - 段可访问</li>
</ul>
<p>你也可以阅读 <a target="_blank" rel="noopener" href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">Intel® 64 and IA-32 Architectures Software Developer’s Manuals 3A</a>获取全部信息。</p>
<p>在定义了数组之后，代码将获取 GDT 的长度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdt.len = <span class="keyword">sizeof</span>(boot_gdt)<span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<p>接下来是将 GDT 的地址放入 gdt.ptr 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdt.ptr = (u32)&amp;boot_gdt + (ds() &lt;&lt; <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>这里的地址计算很简单，因为我们还在实模式，所以就是 （ ds &lt;&lt; 4 + 数组起始地址）。</p>
<p>最后通过执行 <code>lgdtl</code> 指令将 GDT 信息写入 GDTR 寄存器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;lgdtl %0&quot;</span> : : <span class="string">&quot;m&quot;</span> (gdt))</span>;</span><br></pre></td></tr></table></figure>
<p>切换进入保护模式</p>
<p><code>go_to_protected_mode</code> 函数在完成 IDT, GDT 初始化，并禁止了 NMI 中断之后，将调用 <code>protected_mode_jump</code> 函数完成从实模式到保护模式的跳转：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected_mode_jump(boot_params.hdr.code32_start, (u32)&amp;boot_params + (ds() &lt;&lt; <span class="number">4</span>));</span><br></pre></td></tr></table></figure>
<p><code>protected_mode_jump</code> 函数定义在 arch/x86/boot/pmjump.S，它接受下面2个参数:</p>
<ul>
<li>保护模式代码的入口</li>
<li><code>boot_params</code> 结构的地址</li>
</ul>
<p>第一个参数保存在 <code>eax</code> 寄存器，而第二个参数保存在 <code>edx</code> 寄存器。</p>
<p>代码首先在 <code>boot_params</code> 地址放入 <code>esi</code> 寄存器，然后将 <code>cs</code> 寄存器内容放入 <code>bx</code> 寄存器，接着执行 <code>bx &lt;&lt; 4 + 标号为2的代码的地址</code>，这样一来 <code>bx</code> 寄存器就包含了标号为2的代码的地址。接下来代码将把数据段索引放入 <code>cx</code> 寄存器，将 TSS 段索引放入 <code>di</code> 寄存器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movw	$__BOOT_DS, %cx</span><br><span class="line">movw	$__BOOT_TSS, %di</span><br></pre></td></tr></table></figure>
<p>就像前面我们看到的 <code>GDT_ENTRY_BOOT_CS</code> 的值为2，每个段描述符都是 8 字节，所以 <code>cx</code> 寄存器的值将是 <code>2*8 = 16</code>，<code>di</code> 寄存器的值将是 <code>4*8 =32</code></p>
<p>接下来，我们通过设置 <code>CR0</code> 寄存器相应的位使 CPU 进入保护模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl	%cr0, %edx</span><br><span class="line">orb	$X86_CR0_PE, %dl</span><br><span class="line">movl	%edx, %cr0</span><br></pre></td></tr></table></figure>
<p>在进入保护模式之后，通过一个长跳转进入 32 位代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">	.byte	0x66, 0xea</span><br><span class="line">2:	.long	in_pm32</span><br><span class="line">	.word	__BOOT_CS ;(GDT_ENTRY_BOOT_CS*8) = 16，段描述符表索引</span><br></pre></td></tr></table></figure>
<p>这段代码中</p>
<ul>
<li><code>0x66</code> 操作符前缀允许我们混合执行 16 位和 32 位代码</li>
<li><code>0xea</code> - 跳转指令的操作符</li>
<li><code>in_pm32</code> 跳转地址偏移</li>
<li><code>__BOOT_CS</code> 代码段描述符索引</li>
</ul>
<p>在执行了这个跳转命令之后，我们就在保护模式下执行代码了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.code32</span><br><span class="line">.section &quot;.text32&quot;,&quot;ax&quot;</span><br></pre></td></tr></table></figure>
<p>保护模式代码的第一步就是重置所有的段寄存器（除了 <code>CS</code> 寄存器）:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GLOBAL(in_pm32)</span><br><span class="line">movl	%ecx, %ds</span><br><span class="line">movl	%ecx, %es</span><br><span class="line">movl	%ecx, %fs</span><br><span class="line">movl	%ecx, %gs</span><br><span class="line">movl	%ecx, %ss</span><br></pre></td></tr></table></figure>
<p>还记得我们在实模式代码中将 <code>$__BOOT_DS</code> （数据段描述符索引）放入了 <code>cx</code> 寄存器，所以上面的代码设置所有段寄存器（除了 <code>CS</code> 寄存器）指向数据段。接下来代码将所有的通用寄存器清 0 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xorl	%ecx, %ecx</span><br><span class="line">xorl	%edx, %edx</span><br><span class="line">xorl	%ebx, %ebx</span><br><span class="line">xorl	%ebp, %ebp</span><br><span class="line">xorl	%edi, %edi</span><br></pre></td></tr></table></figure>
<p>最后使用长跳转跳入正在的 32 位代码（通过参数传入的地址）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmpl	*%eax ;</span><br></pre></td></tr></table></figure>
<p>到这里，我们就进入了保护模式开始执行代码了</p>
<h2 id="切换到64位模式">切换到64位模式</h2>
<h3 id="32位入口点">32位入口点</h3>
<p>回忆一下， <code>eax</code> 寄存器包含了 32 位入口点的地址。我们可以在 <a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/x86/boot.txt">x86 linux 内核引导协议</a> 中找到相关内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">When using bzImage, the protected-mode kernel was relocated to 0x100000</span><br></pre></td></tr></table></figure>
<p>我们可以在汇编源码 arch/x86/boot/compressed/head_64.S 中找到 32 位入口点的定义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__HEAD</span><br><span class="line">	.code32</span><br><span class="line">ENTRY(startup_32)</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">ENDPROC(startup_32)</span><br></pre></td></tr></table></figure>
<p>首先，为什么目录名叫做 <code>被压缩的 (compressed)</code> ？实际上 <code>bzimage</code> 是由 <code>vmlinux + 头文件 + 内核启动代码</code> 被 gzip 压缩之后获得的。所以， <code>head_64.S</code> 的主要目的就是做好进入长模式的准备之后进入长模式，进入以后再解压内核。</p>
<p>在 <code>arch/x86/boot/compressed</code> 目录下有两个文件：</p>
<ul>
<li>head_32.S</li>
<li>head_64.S</li>
</ul>
<p>让我们看一下 arch/x86/boot/compressed/Makefile。在那里我们可以看到以下目标：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vmlinux-objs-y := <span class="variable">$(obj)</span>/vmlinux.lds <span class="variable">$(obj)</span>/head_<span class="variable">$(BITS)</span>.o <span class="variable">$(obj)</span>/misc.o \</span><br><span class="line">	<span class="variable">$(obj)</span>/string.o <span class="variable">$(obj)</span>/cmdline.o \</span><br><span class="line">	<span class="variable">$(obj)</span>/piggy.o <span class="variable">$(obj)</span>/cpuflags.o</span><br></pre></td></tr></table></figure>
<p>注意 <code>$(obj)/head_$(BITS).o</code> 。这意味着我们将会选择基于 <code>$(BITS)</code> 所设置的文件执行链接操作，即 head_32.o 或者 head_64.o。<code>$(BITS)</code> 在 arch/x86/Makefile之中根据 .config 文件另外定义：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ifeq ($(CONFIG_X86_32),y)</span><br><span class="line">        BITS := 32</span><br><span class="line">        ...</span><br><span class="line">		...</span><br><span class="line">else</span><br><span class="line">        BITS := 64</span><br><span class="line">		...</span><br><span class="line">		...</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<h3 id="必要时加载内存段寄存器">必要时加载内存段寄存器</h3>
<p>正如上面阐述的，我们先从 arch/x86/boot/compressed/head_64.S这个汇编文件开始。首先我们看到了在 <code>startup_32</code> 之前的特殊段属性定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    __HEAD</span><br><span class="line">	.code32</span><br><span class="line">ENTRY(startup_32)</span><br></pre></td></tr></table></figure>
<p>这个 <code>__HEAD</code> 是一个定义在头文件 include/linux/init.h 中的宏，展开后就是下面这个段的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __HEAD		.section	<span class="string">&quot;.head.text&quot;</span>,<span class="string">&quot;ax&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>其拥有 <code>.head.text</code> 的命名和 <code>ax</code> 标记。在这里，这些标记告诉我们这个段是<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Executable">可执行的</a>或者换种说法，包含了代码。我们可以在 arch/x86/boot/compressed/vmlinux.lds.S这个链接脚本里找到这个段的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">	. = 0;</span><br><span class="line">	.head.text : &#123;</span><br><span class="line">		_head = . ;</span><br><span class="line">		HEAD_TEXT</span><br><span class="line">		_ehead = . ;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>如果你不熟悉 <code>GNU LD</code> 这个链接脚本语言的语法，你可以在<a target="_blank" rel="noopener" href="https://sourceware.org/binutils/docs/ld/Scripts.html#Scripts">这个文档</a>中找到更多信息。简单来说，这个 <code>.</code> 符号是一个链接器的特殊变量 - 位置计数器。其被赋值为相对于该段的偏移。在这里，我们将位置计数器赋值为0，这意味着我们的代码被链接到内存的 <code>0</code> 偏移处。此外，我们可以从注释里找到更多信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Be careful parts of head_64.S assume startup_32 is at address 0.</span><br></pre></td></tr></table></figure>
<p>好了，现在我们知道我们在哪里了，接下来就是深入 <code>startup_32</code> 函数的最佳时机。</p>
<p>在 <code>startup_32</code> 函数的开始，我们可以看到 <code>cld</code> 指令将<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/1845107.htm">标志寄存器</a>的 <code>DF</code> （方向标志）位清空。当方向标志被清空，所有的串操作指令像stos， scas等等将会增加索引寄存器 <code>esi</code> 或者 <code>edi</code> 的值。我们需要清空方向标志是因为接下来我们会使用汇编的串操作指令来做为页表腾出空间等工作。</p>
<p>在我们清空 <code>DF</code> 标志后，下一步就是从内核加载头中的 <code>loadflags</code> 字段来检查 <code>KEEP_SEGMENTS</code> 标志。这些标记在 linux 的<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/x86/boot.txt">引导协议</a>文档中有描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 1Bit 6 (write): KEEP_SEGMENTS</span><br><span class="line"> Protocol: 2.07+</span><br><span class="line"> - If 0, reload the segment registers in the 32bit entry point.</span><br><span class="line"> - If 1, do not reload the segment registers in the 32bit entry point.</span><br><span class="line">   Assume that %cs %ds %ss %es are all set to flat segments with</span><br><span class="line">a base of 0 (or the equivalent for their environment).</span><br></pre></td></tr></table></figure>
<p>所以，如果 <code>KEEP_SEGMENTS</code> 位在 <code>loadflags</code> 中没有被设置，我们需要重置 <code>ds</code> , <code>ss</code> 和 <code>es</code> 段寄存器到一个基地址为 <code>0</code> 的普通段中。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   testb $(1 &lt;&lt; 6), BP_loadflags(%esi)</span><br><span class="line">jnz 1f</span><br><span class="line"></span><br><span class="line">cli</span><br><span class="line">movl	$(__BOOT_DS), %eax</span><br><span class="line">movl	%eax, %ds</span><br><span class="line">movl	%eax, %es</span><br><span class="line">movl	%eax, %ss</span><br></pre></td></tr></table></figure>
<p>记住 <code>__BOOT_DS</code> 是 <code>0x18</code> （位于<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Global_Descriptor_Table">全局描述符表</a>中数据段的索引）。如果设置了 <code>KEEP_SEGMENTS</code> ，我们就跳转到最近的 <code>1f</code> 标签，或者当没有 <code>1f</code> 标签，则用 <code>__BOOT_DS</code> 更新段寄存器。这非常简单，但是这是一个有趣的操作。我们在 arch/x86/boot/pmjump.S 中切换到<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BF%9D%E8%AD%B7%E6%A8%A1%E5%BC%8F">保护模式</a>的时候已经更新了这些段寄存器。那么为什么我们还要去关心这些段寄存器的值呢？答案很简单，Linux 内核也有32位的引导协议，如果一个引导程序之前使用32位协议引导内核，那么在 <code>startup_32</code> 之前的代码就会被忽略。在这种情况下 <code>startup_32</code> 将会变成引导程序之后的第一个入口点，不保证段寄存器会不会处于未知状态。</p>
<p>在我们检查了 <code>KEEP_SEGMENTS</code> 标记并且给段寄存器设置了正确的值之后，下一步就是计算我们代码的加载和编译运行之间的位置偏差了。记住 <code>setup.ld.S</code> 包含了以下定义：在 <code>.head.text</code> 段的开始 <code>. = 0</code> 。这意味着这一段代码被编译成从 <code>0</code> 地址运行。我们可以在 <code>objdump</code> 工具的输出中看到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arch/x86/boot/compressed/vmlinux:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .head.text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;startup_32&gt;:</span><br><span class="line">   0:   fc                      cld</span><br><span class="line">   1:   f6 86 11 02 00 00 40    testb  $0x40,0x211(%rsi)</span><br></pre></td></tr></table></figure>
<p><code>objdump</code> 工具告诉我们 <code>startup_32</code> 的地址是 <code>0</code> 。但实际上并不是。我们当前的目标是获知我们实际上在哪里。在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%95%BF%E6%A8%A1%E5%BC%8F">长模式</a>下，这非常简单，因为其支持 <code>rip</code> 相对寻址，但是我们当前处于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BF%9D%E8%AD%B7%E6%A8%A1%E5%BC%8F">保护模式</a>下。我们将会使用一个常用的方法来确定 <code>startup_32</code> 的地址。我们需要定义一个标签并且跳转到它，然后把栈顶抛出到一个寄存器中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call label</span><br><span class="line">label: pop %reg</span><br></pre></td></tr></table></figure>
<p>在这之后，那个寄存器将会包含标签的地址，让我们看看在 Linux 内核中类似的寻找 <code>startup_32</code> 地址的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	leal	(BP_scratch+4)(%esi), %esp</span><br><span class="line">	call	1f</span><br><span class="line">1:  popl	%ebp</span><br><span class="line">	subl	$1b, %ebp</span><br></pre></td></tr></table></figure>
<p><code>esi</code> 寄存器包含了<code>bootparams</code> 结构的地址，这个结构在我们切换到保护模式之前已经被填充了。<code>bootparams</code> 这个结构体包含了一个特殊的字段 <code>scratch</code> ，其偏移量为 <code>0x1e4</code> 。这个 4 字节的区域将会成为 <code>call</code> 指令的临时栈。我们把 <code>scratch</code> 的地址加 4 存入 <code>esp</code> 寄存器。我们之所以在 <code>BP_scratch</code> 基础上加 <code>4</code> 是因为，如之前所说的，这将成为一个临时的栈，而在 <code>x86_64</code> 架构下，栈是自顶向下生长的。所以我们的栈指针就会指向栈顶。接下来我们就可以看到我上面描述的过程。我们跳转到 <code>1f</code> 标签并且把该标签的地址放入 <code>ebp</code> 寄存器，因为在执行 <code>call</code> 指令之后我们把返回地址放到了栈顶。那么，目前我们拥有 <code>1f</code> 标签的地址，也能够很容易得到 <code>startup_32</code> 的地址。我们只需要把我们从栈里得到的地址减去标签的地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">startup_32 (0x0)     +-----------------------+</span><br><span class="line">                     |                       |</span><br><span class="line">                     |                       |</span><br><span class="line">                     |                       |</span><br><span class="line">                     |                       |</span><br><span class="line">                     |                       |</span><br><span class="line">                     |                       |</span><br><span class="line">                     |                       |</span><br><span class="line">                     |                       |</span><br><span class="line">1f (0x0 + 1f offset) +-----------------------+ %ebp - 实际物理地址</span><br><span class="line">                     |                       |</span><br><span class="line">                     |                       |</span><br><span class="line">                     +-----------------------+</span><br></pre></td></tr></table></figure>
<p><code>startup_32</code> 被链接为在 <code>0x0</code> 地址运行，这意味着 <code>1f</code> 的地址为 <code>0x0 + 1f 的偏移量</code> 。实际上偏移量大概是 <code>0x22</code> 字节。 <code>ebp</code> 寄存器包含了 <code>1f</code> 标签的实际物理地址。所以如果我们从 <code>ebp</code> 中减去 <code>1f</code> ，我们就会得到 <code>startup_32</code> 的实际物理地址。Linux 内核的<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/x86/boot.txt">引导协议</a>描述了保护模式下的内核基地址是 <code>0x100000</code> 。我们可以用 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/GNU%E4%BE%A6%E9%94%99%E5%99%A8">gdb</a> 来验证。</p>
<p><code>startup_32</code> 的地址是 <code>0x100000</code> 。在我们知道了 <code>startup_32</code> 的地址之后，我们可以开始准备切换到<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%95%BF%E6%A8%A1%E5%BC%8F">长模式</a>了。</p>
<h3 id="栈的建立和-CPU-的确认">栈的建立和 CPU 的确认</h3>
<p>如果不知道 <code>startup_32</code> 标签的地址，我们就无法建立栈。我们可以把栈看作是一个数组，并且栈指针寄存器 <code>esp</code> 必须指向数组的底部。当然我们可以在自己的代码里定义一个数组，但是我们需要知道其真实地址来正确配置栈指针。让我们看一下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   movl	$boot_stack_end, %eax</span><br><span class="line">addl	%ebp, %eax</span><br><span class="line">movl	%eax, %esp</span><br></pre></td></tr></table></figure>
<p><code>boots_stack_end</code> 标签被定义在同一个汇编文件 arch/x86/boot/compressed/head_64.S中，位于 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/.bss">.bss</a> 段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	.bss</span><br><span class="line">	.balign 4</span><br><span class="line">boot_heap:</span><br><span class="line">	.fill BOOT_HEAP_SIZE, 1, 0</span><br><span class="line">boot_stack:</span><br><span class="line">	.fill BOOT_STACK_SIZE, 1, 0</span><br><span class="line">boot_stack_end:</span><br></pre></td></tr></table></figure>
<p>首先，我们把 <code>boot_stack_end</code> 放到 <code>eax</code> 寄存器中。那么 <code>eax</code> 寄存器将包含 <code>boot_stack_end</code> 链接后的地址或者说 <code>0x0 + boot_stack_end</code> 。为了得到 <code>boot_stack_end</code> 的实际地址，我们需要加上 <code>startup_32</code> 的实际地址。回忆一下，前面我们找到了这个地址并且把它存到了 <code>ebp</code> 寄存器中。最后，<code>eax</code> 寄存器将会包含 <code>boot_stack_end</code> 的实际地址，我们只需要将其加到栈指针上。</p>
<p>在外面建立了栈之后，下一步是 CPU 的确认。既然我们将要切换到 <code>长模式</code> ，我们需要检查 CPU 是否支持 <code>长模式</code> 和 <code>SSE</code>。我们将会在跳转到 <code>verify_cpu</code> 函数之后执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call	verify_cpu</span><br><span class="line">testl	%eax, %eax</span><br><span class="line">jnz	no_longmode</span><br></pre></td></tr></table></figure>
<p>这个函数定义在 arch/x86/kernel/verify_cpu.S 中，只是包含了几个对 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/CPUID">cpuid</a> 指令的调用。该指令用于获取处理器的信息。在我们的情况下，它检查了对 <code>长模式</code> 和 <code>SSE</code> 的支持，通过 <code>eax</code> 寄存器返回0表示成功，1表示失败。</p>
<p>如果 <code>eax</code> 的值不是 0 ，我们就跳转到 <code>no_longmode</code> 标签，用 <code>hlt</code> 指令停止 CPU ，期间不会发生硬件中断：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">no_longmode:</span><br><span class="line">1:</span><br><span class="line">	hlt</span><br><span class="line">	jmp     1b</span><br></pre></td></tr></table></figure>
<p>如果 <code>eax</code> 的值为0，万事大吉，我们可以继续。</p>
<h3 id="计算重定位地址">计算重定位地址</h3>
<p>下一步是在必要的时候计算解压缩之后的地址。首先，我们需要知道内核重定位的意义。我们已经知道 Linux 内核的32位入口点地址位于 <code>0x100000</code> 。但是那是一个32位的入口。默认的内核基地址由内核配置项 <code>CONFIG_PHYSICAL_START</code> 的值所确定，其默认值为 <code>0x1000000</code> 或 <code>16 MB</code> 。这里的主要问题是如果内核崩溃了，内核开发者需要一个配置于不同地址加载的 <code>救援内核</code> 来进行 <a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/kdump/kdump.txt">kdump</a>。Linux 内核提供了特殊的配置选项以解决此问题 - <code>CONFIG_RELOCATABLE</code> 。我们可以在内核文档中找到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">This builds a kernel image that retains relocation information</span><br><span class="line">so it can be loaded someplace besides the default 1MB.</span><br><span class="line"></span><br><span class="line">Note: If CONFIG_RELOCATABLE=y, then the kernel runs from the address</span><br><span class="line">it has been loaded at and the compile time physical address</span><br><span class="line">(CONFIG_PHYSICAL_START) is used as the minimum location.</span><br></pre></td></tr></table></figure>
<p>简单来说，这意味着相同配置下的 Linux 内核可以从不同地址被启动。这是通过将程序以 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E6%97%A0%E5%85%B3%E4%BB%A3%E7%A0%81">位置无关代码</a> 的形式编译来达到的。如果我们参考 /arch/x86/boot/compressed/Makefile，我们将会看到解压器的确是用 <code>-fPIC</code> 标记编译的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KBUILD_CFLAGS += -fno-strict-aliasing -fPIC</span><br></pre></td></tr></table></figure>
<p>当我们使用位置无关代码时，一段代码的地址是由一个控制地址加上程序计数器计算得到的。我们可以从任意一个地址加载使用这种方式寻址的代码。这就是为什么我们需要获得 <code>startup_32</code> 的实际地址。现在让我们回到 Linux 内核代码。我们目前的目标是计算出内核解压的地址。这个地址的计算取决于内核配置项 <code>CONFIG_RELOCATABLE</code> 。让我们看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CONFIG_RELOCATABLE</span><br><span class="line">	movl	%ebp, %ebx</span><br><span class="line">	movl	BP_kernel_alignment(%esi), %eax</span><br><span class="line">	decl	%eax</span><br><span class="line">	addl	%eax, %ebx</span><br><span class="line">	notl	%eax</span><br><span class="line">	andl	%eax, %ebx</span><br><span class="line">	cmpl	$LOAD_PHYSICAL_ADDR, %ebx</span><br><span class="line">	jge	1f</span><br><span class="line">#endif</span><br><span class="line">	movl	$LOAD_PHYSICAL_ADDR, %ebx</span><br><span class="line">1:</span><br><span class="line">	addl	$z_extract_offset, %ebx</span><br></pre></td></tr></table></figure>
<p>记住 <code>ebp</code> 寄存器的值就是 <code>startup_32</code> 标签的物理地址。如果在内核配置中 <code>CONFIG_RELOCATABLE</code> 内核配置项开启，我们就把这个地址放到 <code>ebx</code> 寄存器中，对齐到 <code>2M</code> 的整数倍 ，然后和 <code>LOAD_PHYSICAL_ADDR</code> 的值比较。 <code>LOAD_PHYSICAL_ADDR</code> 宏定义在头文件 arch/x86/include/asm/boot.h中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOAD_PHYSICAL_ADDR ((CONFIG_PHYSICAL_START \</span></span><br><span class="line"><span class="meta">				+ (CONFIG_PHYSICAL_ALIGN - 1)) \</span></span><br><span class="line"><span class="meta">				&amp; ~(CONFIG_PHYSICAL_ALIGN - 1))</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到该宏只是展开成对齐的 <code>CONFIG_PHYSICAL_ALIGN</code> 值，其表示了内核加载位置的物理地址。在比较了 <code>LOAD_PHYSICAL_ADDR</code> 和 <code>ebx</code> 的值之后，我们给 <code>startup_32</code> 加上偏移来获得解压内核镜像的地址。如果 <code>CONFIG_RELOCATABLE</code> 选项在内核配置时没有开启，我们就直接将默认的地址加上 <code>z_extract_offset</code> 。</p>
<p>在前面的操作之后，<code>ebp</code> 包含了我们加载时的地址，<code>ebx</code> 被设为内核解压缩的目标地址。</p>
<h3 id="进入长模式前的准备工作">进入长模式前的准备工作</h3>
<p>在我们得到了重定位内核镜像的基地址之后，我们需要做切换到64位模式之前的最后准备。首先，我们需要更新<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Global_Descriptor_Table">全局描述符表</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   leal	gdt(%ebp), %eax</span><br><span class="line">movl	%eax, gdt+2(%ebp)</span><br><span class="line">lgdt	gdt(%ebp)</span><br></pre></td></tr></table></figure>
<p>在这里我们把 <code>ebp</code> 寄存器加上 <code>gdt</code> 的偏移存到 <code>eax</code> 寄存器。接下来我们把这个地址放到 <code>ebp</code> 加上 <code>gdt+2</code> 偏移的位置上，并且用 <code>lgdt</code> 指令载入 <code>全局描述符表</code> 。为了理解这个神奇的 <code>gdt</code> 偏移量，我们需要关注 <code>全局描述符表</code> 的定义。我们可以在同一个源文件中找到其定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">	.data</span><br><span class="line">gdt:</span><br><span class="line">	.word	gdt_end - gdt</span><br><span class="line">	.long	gdt</span><br><span class="line">	.word	0</span><br><span class="line">	.quad	0x0000000000000000	/* NULL descriptor */</span><br><span class="line">	.quad	0x00af9a000000ffff	/* __KERNEL_CS */</span><br><span class="line">	.quad	0x00cf92000000ffff	/* __KERNEL_DS */</span><br><span class="line">	.quad	0x0080890000000000	/* TS descriptor */</span><br><span class="line">	.quad   0x0000000000000000	/* TS continued */</span><br><span class="line">gdt_end:</span><br></pre></td></tr></table></figure>
<p>我们可以看到其位于 <code>.data</code> 段，并且包含了5个描述符： <code>null</code> 、内核代码段、内核数据段和其他两个任务描述符。将描述符改为 <code>CS.L = 1</code> <code>CS.D = 0</code> 从而在 <code>64</code> 位模式下执行。我们可以看到， <code>gdt</code> 的定义从两个字节开始： <code>gdt_end - gdt</code> ，代表了 <code>gdt</code> 表的最后一个字节，或者说表的范围。接下来的4个字节包含了 <code>gdt</code> 的基地址。记住 <code>全局描述符表</code> 保存在 <code>48位 GDTR-全局描述符表寄存器</code> 中，由两个部分组成：</p>
<ul>
<li>全局描述符表的大小 (16位）</li>
<li>全局描述符表的基址 (32位)</li>
</ul>
<p>所以，我们把 <code>gdt</code> 的地址放到 <code>eax</code> 寄存器，然后存到 <code>.long	gdt</code> 或者 <code>gdt+2</code>。现在我们已经建立了 <code>GDTR</code> 寄存器的结构，并且可以用 <code>lgdt</code> 指令载入 <code>全局描述符表</code> 了。</p>
<p>在我们载入 <code>全局描述符表</code> 之后，我们必须启用 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Physical_Address_Extension">PAE</a> 模式。方法是将 <code>cr4</code> 寄存器的值传入 <code>eax</code> ，将第5位置1，然后再写回 <code>cr4</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   movl	%cr4, %eax</span><br><span class="line">orl	$X86_CR4_PAE, %eax</span><br><span class="line">movl	%eax, %cr4</span><br></pre></td></tr></table></figure>
<p>现在我们已经接近完成进入64位模式前的所有准备工作了。最后一步是建立页表.</p>
<h3 id="长模式">长模式</h3>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%95%BF%E6%A8%A1%E5%BC%8F">长模式</a>是 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> 系列处理器的原生模式。首先让我们看一看 <code>x86_64</code> 和 <code>x86</code> 的一些区别。</p>
<p><code>64位</code> 模式提供了一些新特性，比如：</p>
<ul>
<li>从 <code>r8</code> 到 <code>r15</code> 8个新的通用寄存器，并且所有通用寄存器都是64位的了。</li>
<li>64位指令指针 - <code>RIP</code> ;</li>
<li>新的操作模式 - 长模式;</li>
<li>64位地址和操作数;</li>
<li>RIP 相对寻址 .</li>
</ul>
<p>长模式是一个传统保护模式的扩展，其由两个子模式构成：</p>
<ul>
<li>64位模式</li>
<li>兼容模式</li>
</ul>
<p>为了切换到 <code>64位</code> 模式，我们需要完成以下操作：</p>
<ul>
<li>启用 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Physical_Address_Extension">PAE</a>;</li>
<li>建立页表并且将顶级页表的地址放入 <code>cr3</code> 寄存器;</li>
<li>启用 <code>EFER.LME</code> ;</li>
<li>启用分页;</li>
</ul>
<p>我们已经通过设置 <code>cr4</code> 控制寄存器中的 <code>PAE</code> 位启动 <code>PAE</code> 了。</p>
<h3 id="初期页表初始化">初期页表初始化</h3>
<p>Linux 内核使用 <code>4级</code> 页表，通常我们会建立6个页表：</p>
<ul>
<li>1 个 <code>PML4</code> 或称为 <code>4级页映射</code> 表，包含 1 个项；</li>
<li>1 个 <code>PDP</code> 或称为 <code>页目录指针</code> 表，包含 4 个项；</li>
<li>4 个 页目录表，一共包含 <code>2048</code> 个项；</li>
</ul>
<p>让我们看看其实现方式。首先我们在内存中为页表清理一块缓存。每个表都是 <code>4096</code> 字节，所以我们需要 <code>24</code> KB 的空间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   leal	pgtable(%ebx), %edi</span><br><span class="line">xorl	%eax, %eax</span><br><span class="line">movl	$((4096*6)/4), %ecx</span><br><span class="line">rep	stosl</span><br></pre></td></tr></table></figure>
<p>我们把和 <code>ebx</code> 相关的 <code>pgtable</code> 的地址放到 <code>edi</code> 寄存器中，清空 <code>eax</code> 寄存器，并将 <code>ecx</code> 赋值为 <code>6144</code> 。 <code>rep stosl</code> 指令将会把 <code>eax</code> 的值写到 <code>edi</code> 指向的地址，然后给 <code>edi</code> 加 4 ， <code>ecx</code> 减 4 ，重复直到 <code>ecx</code> 小于等于 0 。所以我们才把 <code>6144</code> 赋值给 <code>ecx</code> 。</p>
<p><code>pgtable</code> 定义在 arch/x86/boot/compressed/head_64.S的最后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	.section &quot;.pgtable&quot;,&quot;a&quot;,@nobits</span><br><span class="line">	.balign 4096</span><br><span class="line">pgtable:</span><br><span class="line">	.fill 6*4096, 1, 0</span><br></pre></td></tr></table></figure>
<p>我们可以看到，其位于 <code>.pgtable</code> 段，大小为 <code>24KB</code> 。</p>
<p>在我们为 <code>pgtable</code> 分配了空间之后，我们可以开始构建顶级页表 - <code>PML4</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   leal	pgtable + 0(%ebx), %edi</span><br><span class="line">leal	0x1007 (%edi), %eax</span><br><span class="line">movl	%eax, 0(%edi)</span><br></pre></td></tr></table></figure>
<p>还是在这里，我们把和 <code>ebx</code> 相关的，或者说和 <code>startup_32</code> 相关的 <code>pgtable</code> 的地址放到 <code>edi</code> 寄存器。接下来我们把相对此地址偏移 <code>0x1007</code> 的地址放到 <code>eax</code> 寄存器中。 <code>0x1007</code> 是 <code>PML4</code> 的大小 <code>4096</code> 加上 <code>7</code> 。这里的 <code>7</code> 代表了 <code>PML4</code> 的项标记。在我们这里，这些标记是 <code>PRESENT+RW+USER</code> 。在最后我们把第一个 <code>PDP（页目录指针）</code> 项的地址写到 <code>PML4</code> 中。</p>
<p>在接下来的一步，我们将会在 <code>页目录指针（PDP）</code> 表（3级页表）建立 4 个带有 <code>PRESENT+RW+USE</code> 标记的 <code>Page Directory （2级页表）</code> 项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	leal	pgtable + 0x1000(%ebx), %edi</span><br><span class="line">	leal	0x1007(%edi), %eax</span><br><span class="line">	movl	$4, %ecx</span><br><span class="line">1:  movl	%eax, 0x00(%edi)</span><br><span class="line">	addl	$0x00001000, %eax</span><br><span class="line">	addl	$8, %edi</span><br><span class="line">	decl	%ecx</span><br><span class="line">	jnz	1b</span><br></pre></td></tr></table></figure>
<p>我们把 3 级页目录指针表的基地址（从 <code>pgtable</code> 表偏移 <code>4096</code> 或者 <code>0x1000</code> ）放到 <code>edi</code> ，把第一个 2 级页目录指针表的首项的地址放到 <code>eax</code> 寄存器。把 <code>4</code> 赋值给 <code>ecx</code> 寄存器，其将会作为接下来循环的计数器，然后将第一个页目录指针项写到 <code>edi</code> 指向的地址。之后， <code>edi</code> 将会包含带有标记 <code>0x7</code> 的第一个页目录指针项的地址。接下来我们就计算后面的几个页目录指针项的地址，每个占 8 字节，把地址赋值给 <code>eax</code> ，然后回到循环开头将其写入 <code>edi</code> 所在地址。建立页表结构的最后一步就是建立 <code>2048</code> 个 <code>2MB</code> 页的页表项。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	leal	pgtable + 0x2000(%ebx), %edi</span><br><span class="line">	movl	$0x00000183, %eax</span><br><span class="line">	movl	$2048, %ecx</span><br><span class="line">1:  movl	%eax, 0(%edi)</span><br><span class="line">	addl	$0x00200000, %eax</span><br><span class="line">	addl	$8, %edi</span><br><span class="line">	decl	%ecx</span><br><span class="line">	jnz	1b</span><br></pre></td></tr></table></figure>
<p>在这里我们做的几乎和上面一样，所有的表项都带着标记 - <code>$0x00000183</code> - <code>PRESENT + WRITE + MBZ</code> 。最后我们将会拥有 <code>2048</code> 个 <code>2MB</code> 大的页，或者说：一个4G页表，现在我们可以把高级页表 <code>PML4</code> 的地址放到 <code>cr3</code> 寄存器中了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   leal	pgtable(%ebx), %eax</span><br><span class="line">movl	%eax, %cr3</span><br></pre></td></tr></table></figure>
<p>这样就全部结束了。所有的准备工作都已经完成，我们可以开始看如何切换到长模式了。</p>
<h3 id="切换到长模式">切换到长模式</h3>
<p>首先我们需要设置 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Model-specific_register">MSR</a> 中的 <code>EFER.LME</code> 标记为 <code>0xC0000080</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   movl	$MSR_EFER, %ecx</span><br><span class="line">rdmsr</span><br><span class="line">btsl	$_EFER_LME, %eax</span><br><span class="line">wrmsr</span><br></pre></td></tr></table></figure>
<p>在这里我们把 <code>MSR_EFER</code> 标记（在 arch/x86/include/uapi/asm/msr-index.h 中定义）放到 <code>ecx</code> 寄存器中，然后调用 <code>rdmsr</code> 指令读取 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Model-specific_register">MSR</a> 寄存器。在 <code>rdmsr</code> 执行之后，我们将会获得 <code>edx:eax</code> 中的结果值，其取决于 <code>ecx</code> 的值。我们通过 <code>btsl</code> 指令检查 <code>EFER_LME</code> 位，并且通过 <code>wrmsr</code> 指令将 <code>eax</code> 的数据写入 <code>MSR</code> 寄存器。</p>
<p>下一步我们将内核段代码地址入栈（我们在 GDT 中定义了），然后将 <code>startup_64</code> 的地址导入 <code>eax</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   pushl	$__KERNEL_CS</span><br><span class="line">leal	startup_64(%ebp), %eax</span><br></pre></td></tr></table></figure>
<p>在这之后我们把这个地址入栈然后通过设置 <code>cr0</code> 寄存器中的 <code>PG</code> 和 <code>PE</code> 启用分页：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   movl	$(X86_CR0_PG | X86_CR0_PE), %eax</span><br><span class="line">movl	%eax, %cr0</span><br></pre></td></tr></table></figure>
<p>然后执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lret</span><br></pre></td></tr></table></figure>
<p>记住前一步我们已经将 <code>startup_64</code> 函数的地址入栈，在 <code>lret</code> 指令之后，CPU 取出了其地址跳转到那里</p>
<p>这些步骤之后我们最后来到了64位模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.code64</span><br><span class="line">	.org 0x200</span><br><span class="line">ENTRY(startup_64)</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<h2 id="内核解压">内核解压</h2>
<p>我们停在了跳转到<code>64位</code>入口点——<code>startup_64</code>的跳转之前，它在源文件 arch/x86/boot/compressed/head_64.S里面。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   pushl	$__KERNEL_CS</span><br><span class="line">leal	startup_64(%ebp), %eax</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">pushl	%eax</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">lret</span><br></pre></td></tr></table></figure>
<p>由于我们加载了新的<code>全局描述符表</code>并且在其他模式有CPU的模式转换（在我们这里是<code>64位</code>模式），我们可以在<code>startup_64</code>的开头看到数据段的建立：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	.code64</span><br><span class="line">	.org 0x200</span><br><span class="line">ENTRY(startup_64)</span><br><span class="line">	xorl	%eax, %eax</span><br><span class="line">	movl	%eax, %ds</span><br><span class="line">	movl	%eax, %es</span><br><span class="line">	movl	%eax, %ss</span><br><span class="line">	movl	%eax, %fs</span><br><span class="line">	movl	%eax, %gs</span><br></pre></td></tr></table></figure>
<p>除<code>cs</code>之外的段寄存器在我们进入<code>长模式</code>时已经重置。</p>
<p>下一步是计算内核编译时的位置和它被加载的位置的差：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CONFIG_RELOCATABLE</span><br><span class="line">	leaq	startup_32(%rip), %rbp</span><br><span class="line">	movl	BP_kernel_alignment(%rsi), %eax</span><br><span class="line">	decl	%eax</span><br><span class="line">	addq	%rax, %rbp</span><br><span class="line">	notq	%rax</span><br><span class="line">	andq	%rax, %rbp</span><br><span class="line">	cmpq	$LOAD_PHYSICAL_ADDR, %rbp</span><br><span class="line">	jge	1f</span><br><span class="line">#endif</span><br><span class="line">	movq	$LOAD_PHYSICAL_ADDR, %rbp</span><br><span class="line">1:</span><br><span class="line">	movl	BP_init_size(%rsi), %ebx</span><br><span class="line">	subl	$_end, %ebx</span><br><span class="line">	addq	%rbp, %rbx</span><br></pre></td></tr></table></figure>
<p><code>rbp</code>包含了解压后内核的起始地址，在这段代码执行之后<code>rbx</code>会包含用于解压的重定位内核代码的地址。我们已经在<code>startup_32</code>看到类似的代码，但是我们需要再做这个计算，因为引导加载器可以用64位引导协议，而<code>startup_32</code>在这种情况下不会执行。</p>
<p>下一步，我们可以看到栈指针的设置和标志寄存器的重置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   leaq	boot_stack_end(%rbx), %rsp</span><br><span class="line"></span><br><span class="line">pushq	$0</span><br><span class="line">popfq</span><br></pre></td></tr></table></figure>
<p>如上所述，<code>rbx</code>寄存器包含了内核解压代码的起始地址，我们把这个地址的<code>boot_stack_entry</code>偏移地址相加放到表示栈顶指针的<code>rsp</code>寄存器。在这一步之后，栈就是正确的。你可以在汇编源码文件 arch/x86/boot/compressed/head_64.S的末尾找到<code>boot_stack_end</code>的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	.bss</span><br><span class="line">	.balign 4</span><br><span class="line">boot_heap:</span><br><span class="line">	.fill BOOT_HEAP_SIZE, 1, 0</span><br><span class="line">boot_stack:</span><br><span class="line">	.fill BOOT_STACK_SIZE, 1, 0</span><br><span class="line">boot_stack_end:</span><br></pre></td></tr></table></figure>
<p>它在<code>.bss</code>节的末尾，就在<code>.pgtable</code>前面。如果你查看 arch/x86/boot/compressed/vmlinux.lds.S 链接脚本，你会找到<code>.bss</code>和<code>.pgtable</code>的定义。</p>
<p>由于我们设置了栈，在我们计算了解压了的内核的重定位地址后，我们可以复制压缩了的内核到以上地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   pushq	%rsi</span><br><span class="line">leaq	(_bss-8)(%rip), %rsi</span><br><span class="line">leaq	(_bss-8)(%rbx), %rdi</span><br><span class="line">movq	$_bss, %rcx</span><br><span class="line">shrq	$3, %rcx</span><br><span class="line">std</span><br><span class="line">rep	movsq</span><br><span class="line">cld</span><br><span class="line">popq	%rsi</span><br></pre></td></tr></table></figure>
<p>首先我们把<code>rsi</code>压进栈。我们需要保存<code>rsi</code>的值，因为这个寄存器现在存放指向<code>boot_params</code>的指针，这是包含引导相关数据的实模式结构体。在代码的结尾，我们会重新恢复指向<code>boot_params</code>的指针到<code>rsi</code>.</p>
<p>接下来两个<code>leaq</code>指令用<code>_bss - 8</code>偏移和<code>rip</code>和<code>rbx</code>计算有效地址并存放到<code>rsi</code>和<code>rdi</code>. 我们为什么要计算这些地址？实际上，压缩了的代码镜像存放在这份复制了的代码（从<code>startup_32</code>到当前的代码）和解压了的代码之间。你可以通过查看链接脚本 arch/x86/boot/compressed/vmlinux.lds.S 验证</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">. = 0;</span><br><span class="line">	.head.text : &#123;</span><br><span class="line">		_head = . ;</span><br><span class="line">		HEAD_TEXT</span><br><span class="line">		_ehead = . ;</span><br><span class="line">	&#125;</span><br><span class="line">	.rodata..compressed : &#123;</span><br><span class="line">		*(.rodata..compressed)</span><br><span class="line">	&#125;</span><br><span class="line">	.text :	&#123;</span><br><span class="line">		_text = .; 	/* Text */</span><br><span class="line">		*(.text)</span><br><span class="line">		*(.text.*)</span><br><span class="line">		_etext = . ;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>注意<code>.head.text</code>节包含了<code>startup_32</code>. 你可以从之前的部分回忆起它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	__HEAD</span><br><span class="line">	.code32</span><br><span class="line">ENTRY(startup_32)</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><code>.text</code>节包含解压代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	.text</span><br><span class="line">relocated:</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">/*</span><br><span class="line"> * Do the decompression, and jump to the new kernel..</span><br><span class="line"> */</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><code>.rodata..compressed</code>包含了压缩了的内核镜像。所以<code>rsi</code>包含<code>_bss - 8</code>的绝对地址，<code>rdi</code>包含<code>_bss - 8</code>的重定位的相对地址。在我们把这些地址放入寄存器时，我们把<code>_bss</code>的地址放到了<code>rcx</code>寄存器。正如你在<code>vmlinux.lds.S</code>链接脚本中看到了一样，它和设置/内核代码一起在所有节的末尾。现在我们可以开始用<code>movsq</code>指令每次8字节地从<code>rsi</code>到<code>rdi</code>复制代码。</p>
<p>注意在数据复制前有<code>std</code>指令：它设置<code>DF</code>标志，意味着<code>rsi</code>和<code>rdi</code>会递减。换句话说，我们会从后往前复制这些字节。最后，我们用<code>cld</code>指令清除<code>DF</code>标志，并恢复<code>boot_params</code>到<code>rsi</code>.</p>
<p>现在我们有<code>.text</code>节的重定位后的地址，我们可以跳到那里：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   leaq	relocated(%rbx), %rax</span><br><span class="line">jmp	*%rax</span><br></pre></td></tr></table></figure>
<h3 id="在内核解压前的最后准备">在内核解压前的最后准备</h3>
<p>在上一段我们看到了<code>.text</code>节从<code>relocated</code>标签开始。它做的第一件事是清空<code>.bss</code>节：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   xorl	%eax, %eax</span><br><span class="line">leaq    _bss(%rip), %rdi</span><br><span class="line">leaq    _ebss(%rip), %rcx</span><br><span class="line">subq	%rdi, %rcx</span><br><span class="line">shrq	$3, %rcx</span><br><span class="line">rep	stosq</span><br></pre></td></tr></table></figure>
<p>我们要初始化<code>.bss</code>节，因为我们很快要跳转到C代码。这里我们就清空<code>eax</code>，把<code>_bss</code>的地址放到<code>rdi</code>，把<code>_ebss</code>放到<code>rcx</code>，然后用<code>rep stosq</code>填零。</p>
<p>最后，我们可以调用<code>extract_kernel</code>函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   pushq	%rsi</span><br><span class="line">movq	%rsi, %rdi</span><br><span class="line">leaq	boot_heap(%rip), %rsi</span><br><span class="line">leaq	input_data(%rip), %rdx</span><br><span class="line">movl	$z_input_len, %ecx</span><br><span class="line">movq	%rbp, %r8</span><br><span class="line">movq	$z_output_len, %r9</span><br><span class="line">call	extract_kernel</span><br><span class="line">popq	%rsi</span><br></pre></td></tr></table></figure>
<p>我们再一次设置<code>rdi</code>为指向<code>boot_params</code>结构体的指针并把它保存到栈中。同时我们设置<code>rsi</code>指向用于内核解压的区域。最后一步是准备<code>extract_kernel</code>的参数并调用这个解压内核的函数。<code>extract_kernel</code>函数在 arch/x86/boot/compressed/misc.c源文件定义并有六个参数：</p>
<ul>
<li><code>rmode</code> - 指向 <a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973//arch/x86/include/uapi/asm/bootparam.h#L114">boot_params</a> 结构体的指针，<code>boot_params</code>被引导加载器填充或在早期内核初始化时填充</li>
<li><code>heap</code> - 指向早期启动堆的起始地址 <code>boot_heap</code> 的指针</li>
<li><code>input_data</code> - 指向压缩的内核，即 <code>arch/x86/boot/compressed/vmlinux.bin.bz2</code> 的指针</li>
<li><code>input_len</code> - 压缩的内核的大小</li>
<li><code>output</code> - 解压后内核的起始地址</li>
<li><code>output_len</code> - 解压后内核的大小</li>
</ul>
<p>所有参数根据 <a target="_blank" rel="noopener" href="http://www.x86-64.org/documentation/abi.pdf">System V Application Binary Interface</a> 通过寄存器传递。我们已经完成了所有的准备工作，现在我们可以看内核解压的过程。</p>
<h3 id="内核解压-2">内核解压</h3>
<p>就像我们在之前的段落中看到了那样，<code>extract_kernel</code>函数在源文件 arch/x86/boot/compressed/misc.c定义并有六个参数。正如我们在之前的部分看到的，这个函数从图形/控制台初始化开始。我们要再次做这件事，因为我们不知道我们是不是从<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Real_mode">实模式</a>开始，或者是使用了引导加载器，或者引导加载器用了32位还是64位启动协议。</p>
<p>在最早的初始化步骤后，我们保存空闲内存的起始和末尾地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">free_mem_ptr     = heap;</span><br><span class="line">free_mem_end_ptr = heap + BOOT_HEAP_SIZE;</span><br></pre></td></tr></table></figure>
<p>在这里 <code>heap</code> 是我们在 arch/x86/boot/compressed/head_64.S 得到的 <code>extract_kernel</code> 函数的第二个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">leaq	boot_heap(%rip), %rsi</span><br></pre></td></tr></table></figure>
<p>如上所述，<code>boot_heap</code>定义为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boot_heap:</span><br><span class="line">	.fill BOOT_HEAP_SIZE, 1, 0</span><br></pre></td></tr></table></figure>
<p>在这里<code>BOOT_HEAP_SIZE</code>是一个展开为<code>0x10000</code>(对<code>bzip2</code>内核是<code>0x400000</code>)的宏，代表堆的大小。</p>
<p>在堆指针初始化后，下一步是从 arch/x86/boot/compressed/kaslr.c 调用<code>choose_random_location</code>函数。我们可以从函数名猜到，它选择内核镜像解压到的内存地址。看起来很奇怪，我们要寻找甚至是<code>选择</code>内核解压的地址，但是Linux内核支持<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">kASLR</a>，为了安全，它允许解压内核到随机的地址。</p>
<p>现在我们回头看 misc.c. 在获得内核镜像的地址后，需要有一些检查以确保获得的随机地址是正确对齐的，并且地址没有错误：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)output &amp; (MIN_KERNEL_ALIGN - <span class="number">1</span>))</span><br><span class="line">	error(<span class="string">&quot;Destination physical address inappropriately aligned&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (virt_addr &amp; (MIN_KERNEL_ALIGN - <span class="number">1</span>))</span><br><span class="line">	error(<span class="string">&quot;Destination virtual address inappropriately aligned&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (heap &gt; <span class="number">0x3fffffffffff</span>UL)</span><br><span class="line">	error(<span class="string">&quot;Destination address too large&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (virt_addr + max(output_len, kernel_total_size) &gt; KERNEL_IMAGE_SIZE)</span><br><span class="line">	error(<span class="string">&quot;Destination virtual address is beyond the kernel mapping area&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)output != LOAD_PHYSICAL_ADDR)</span><br><span class="line">    error(<span class="string">&quot;Destination address does not match LOAD_PHYSICAL_ADDR&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (virt_addr != LOAD_PHYSICAL_ADDR)</span><br><span class="line">	error(<span class="string">&quot;Destination virtual address changed when not relocatable&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>在所有这些检查后，我们可以看到熟悉的消息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Decompressing Linux... </span><br></pre></td></tr></table></figure>
<p>然后调用解压内核的<code>__decompress</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__decompress(input_data, input_len, <span class="literal">NULL</span>, <span class="literal">NULL</span>, output, output_len, <span class="literal">NULL</span>, error);</span><br></pre></td></tr></table></figure>
<p><code>__decompress</code>函数的实现取决于在内核编译期间选择什么压缩算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KERNEL_GZIP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../../../../lib/decompress_inflate.c&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KERNEL_BZIP2</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../../../../lib/decompress_bunzip2.c&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KERNEL_LZMA</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../../../../lib/decompress_unlzma.c&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KERNEL_XZ</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../../../../lib/decompress_unxz.c&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KERNEL_LZO</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../../../../lib/decompress_unlzo.c&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KERNEL_LZ4</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../../../../lib/decompress_unlz4.c&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>在内核解压之后，最后两个函数是<code>parse_elf</code>和<code>handle_relocations</code>.这些函数的主要用途是把解压后的内核移动到正确的位置。事实上，解压过程会<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/In-place_algorithm">原地</a>解压，我们还是要把内核移动到正确的地址。我们已经知道，内核镜像是一个<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">ELF</a>可执行文件，所以<code>parse_elf</code>的主要目标是移动可加载的段到正确的地址。我们可以在<code>readelf</code>的输出看到可加载的段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">readelf -l vmlinux</span><br><span class="line"></span><br><span class="line">Elf file type is EXEC (Executable file)</span><br><span class="line">Entry point 0x1000000</span><br><span class="line">There are 5 program headers, starting at offset 64</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset             VirtAddr           PhysAddr</span><br><span class="line">                 FileSiz            MemSiz              Flags  Align</span><br><span class="line">  LOAD           0x0000000000200000 0xffffffff81000000 0x0000000001000000</span><br><span class="line">                 0x0000000000893000 0x0000000000893000  R E    200000</span><br><span class="line">  LOAD           0x0000000000a93000 0xffffffff81893000 0x0000000001893000</span><br><span class="line">                 0x000000000016d000 0x000000000016d000  RW     200000</span><br><span class="line">  LOAD           0x0000000000c00000 0x0000000000000000 0x0000000001a00000</span><br><span class="line">                 0x00000000000152d8 0x00000000000152d8  RW     200000</span><br><span class="line">  LOAD           0x0000000000c16000 0xffffffff81a16000 0x0000000001a16000</span><br><span class="line">                 0x0000000000138000 0x000000000029b000  RWE    200000</span><br></pre></td></tr></table></figure>
<p><code>parse_elf</code>函数的目标是加载这些段到从<code>choose_random_location</code>函数得到的<code>output</code>地址。这个函数从检查ELF签名标志开始：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Elf64_Ehdr ehdr;</span><br><span class="line">Elf64_Phdr *phdrs, *phdr;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(&amp;ehdr, output, <span class="keyword">sizeof</span>(ehdr));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ehdr.e_ident[EI_MAG0] != ELFMAG0 ||</span><br><span class="line">    ehdr.e_ident[EI_MAG1] != ELFMAG1 ||</span><br><span class="line">    ehdr.e_ident[EI_MAG2] != ELFMAG2 ||</span><br><span class="line">    ehdr.e_ident[EI_MAG3] != ELFMAG3) &#123;</span><br><span class="line">        error(<span class="string">&quot;Kernel is not a valid ELF file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是无效的，它会打印一条错误消息并停机。如果我们得到一个有效的<code>ELF</code>文件，我们从给定的<code>ELF</code>文件遍历所有程序头，并用正确的地址复制所有可加载的段到输出缓冲区：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ehdr.e_phnum; i++) &#123;</span><br><span class="line">		phdr = &amp;phdrs[i];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (phdr-&gt;p_type) &#123;</span><br><span class="line">		<span class="keyword">case</span> PT_LOAD:</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_RELOCATABLE</span></span><br><span class="line">			dest = output;</span><br><span class="line">			dest += (phdr-&gt;p_paddr - LOAD_PHYSICAL_ADDR);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">			dest = (<span class="type">void</span> *)(phdr-&gt;p_paddr);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			memmove(dest, output + phdr-&gt;p_offset, phdr-&gt;p_filesz);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这就是全部的工作。</p>
<p>从现在开始，所有可加载的段都在正确的位置。</p>
<p>在<code>parse_elf</code>函数之后是调用<code>handle_relocations</code>函数。这个函数的实现依赖于<code>CONFIG_X86_NEED_RELOCS</code>内核配置选项，如果它被启用，这个函数调整内核镜像的地址，只有在内核配置时启用了<code>CONFIG_RANDOMIZE_BASE</code>配置选项才会调用。<code>handle_relocations</code>函数的实现足够简单。这个函数从基准内核加载地址的值减掉<code>LOAD_PHYSICAL_ADDR</code>的值，从而我们获得内核链接后要加载的地址和实际加载地址的差值。在这之后我们可以进行内核重定位，因为我们知道内核加载的实际地址、它被链接的运行的地址和内核镜像末尾的重定位表。</p>
<p>在内核重定位后，我们从<code>extract_kernel</code>回来，到 arch/x86/boot/compressed/head_64.S</p>
<p>内核的地址在<code>rax</code>寄存器，我们跳到那里：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp	*%rax</span><br></pre></td></tr></table></figure>
<p>就是这样。现在我们就在内核里！</p>
<h2 id="内核地址随机化">内核地址随机化</h2>
<p>你可能还记得，Linux内核的入口点是 main.c 的<code>start_kernel</code>函数，它在<code>LOAD_PHYSICAL_ADDR</code>地址开始执行。这个地址依赖于<code>CONFIG_PHYSICAL_START</code>内核配置选项，默认为<code>0x1000000</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">config PHYSICAL_START</span><br><span class="line">	hex <span class="string">&quot;Physical address where the kernel is loaded&quot;</span> <span class="keyword">if</span> (EXPERT || CRASH_DUMP)</span><br><span class="line">	<span class="keyword">default</span> <span class="string">&quot;0x1000000&quot;</span></span><br><span class="line">	---help---</span><br><span class="line">	  This gives the physical address where the kernel is loaded.</span><br><span class="line">      ...</span><br><span class="line">      ...</span><br><span class="line">      ...</span><br></pre></td></tr></table></figure>
<p>这个选项在内核配置时可以修改，但是加载地址可以选择为一个随机值。为此，<code>CONFIG_RANDOMIZE_BASE</code>内核配置选项在内核配置时应该启用。在这种情况下，Linux内核镜像解压和加载的物理地址会被随机化。</p>
<h3 id="页表的初始化">页表的初始化</h3>
<p>在内核解压器要开始找随机的内核解压和加载地址之前，应该初始化恒等映射（identity mapped,虚拟地址和物理地址相同）页表。如果<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Booting">引导加载器</a>使用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/master/Documentation/x86/boot.txt">16位或32位引导协议</a>，那么我们已经有了页表。但在任何情况下，如果内核解压器选择它们之外的内存区域，我们需要新的页。这就是为什么我们需要建立新的恒等映射页表。是的，建立恒等映射页表是随机化加载地址的最早的步骤之一。</p>
<p>内核解压器的入口点——<code>extract_kernel</code>函数。随机化从调用这个函数开始：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">choose_random_location</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> input,</span></span><br><span class="line"><span class="params">                            <span class="type">unsigned</span> <span class="type">long</span> input_size,</span></span><br><span class="line"><span class="params">			                <span class="type">unsigned</span> <span class="type">long</span> *output,</span></span><br><span class="line"><span class="params">                            <span class="type">unsigned</span> <span class="type">long</span> output_size,</span></span><br><span class="line"><span class="params">			                <span class="type">unsigned</span> <span class="type">long</span> *virt_addr)</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>你可以看到，这个函数有五个参数：</p>
<ul>
<li><code>input</code>;</li>
<li><code>input_size</code>;</li>
<li><code>output</code>;</li>
<li><code>output_isze</code>;</li>
<li><code>virt_addr</code>.</li>
</ul>
<p>让我们试着理解一下这些参数是什么。第一个<code>input</code>参数来自源文件 arch/x86/boot/compressed/misc.c 里的<code>extract_kernel</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage __visible <span class="type">void</span> *<span class="title function_">extract_kernel</span><span class="params">(<span class="type">void</span> *rmode, memptr heap,</span></span><br><span class="line"><span class="params">				                          <span class="type">unsigned</span> <span class="type">char</span> *input_data,</span></span><br><span class="line"><span class="params">				                          <span class="type">unsigned</span> <span class="type">long</span> input_len,</span></span><br><span class="line"><span class="params">				                          <span class="type">unsigned</span> <span class="type">char</span> *output,</span></span><br><span class="line"><span class="params">				                          <span class="type">unsigned</span> <span class="type">long</span> output_len)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  choose_random_location((<span class="type">unsigned</span> <span class="type">long</span>)input_data, input_len,</span><br><span class="line">                         (<span class="type">unsigned</span> <span class="type">long</span> *)&amp;output,</span><br><span class="line">				         max(output_len, kernel_total_size),</span><br><span class="line">				         &amp;virt_addr);</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个参数由 arch/x86/boot/compressed/head_64.S的汇编代码传递：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">leaq	input_data(%rip), %rdx</span><br></pre></td></tr></table></figure>
<p><code>input_data</code>由 mkpiggy.c程序生成。如果你亲手编译过Linux内核源码，你会找到这个程序生成的文件，它应该位于 <code>linux/arch/x86/boot/compressed/piggy.S</code>. 在我这里，这个文件是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.section &quot;.rodata..compressed&quot;,&quot;a&quot;,@progbits</span><br><span class="line">.globl z_input_len</span><br><span class="line">z_input_len = 6988196</span><br><span class="line">.globl z_output_len</span><br><span class="line">z_output_len = 29207032</span><br><span class="line">.globl input_data, input_data_end</span><br><span class="line">input_data:</span><br><span class="line">.incbin &quot;arch/x86/boot/compressed/vmlinux.bin.gz&quot;</span><br><span class="line">input_data_end:</span><br></pre></td></tr></table></figure>
<p>你能看到它有四个全局符号。前两个<code>z_input_len</code>和<code>z_output_len</code>是压缩的和解压后的<code>vmlinux.bin.gz</code>的大小。第三个是我们的<code>input_data</code>，你可以看到，它指向二进制格式（去掉所有调试符号、注释和重定位信息）的Linux内核镜像。最后的<code>input_data_end</code>指向压缩的Linux镜像的末尾。</p>
<p>所以我们<code>choose_random_location</code>函数的第一个参数是指向嵌入在<code>piggy.o</code>目标文件的压缩的内核镜像的指针。</p>
<p><code>choose_random_location</code>函数的第二个参数是我们刚刚看到的<code>z_input_len</code>.</p>
<p><code>choose_random_location</code>函数的第三和第四个参数分别是解压后的内核镜像的位置和长度。放置解压后内核的地址来自 arch/x86/boot/compressed/head_64.S，并且它是<code>startup_32</code>对齐到 2MB 边界的地址。解压后的内核的大小来自同样的<code>piggy.S</code>，并且它是<code>z_output_len</code>.</p>
<p><code>choose_random_location</code>函数的最后一个参数是内核加载地址的虚拟地址。我们可以看到，它和默认的物理加载地址相同：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> virt_addr = LOAD_PHYSICAL_ADDR;</span><br></pre></td></tr></table></figure>
<p>它依赖于内核配置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOAD_PHYSICAL_ADDR ((CONFIG_PHYSICAL_START \</span></span><br><span class="line"><span class="meta">				+ (CONFIG_PHYSICAL_ALIGN - 1)) \</span></span><br><span class="line"><span class="meta">				&amp; ~(CONFIG_PHYSICAL_ALIGN - 1))</span></span><br></pre></td></tr></table></figure>
<p>现在，由于我们考虑<code>choose_random_location</code>函数的参数，让我们看看它的实现。这个函数从检查内核命令行的<code>nokaslr</code>选项开始：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cmdline_find_option_bool(<span class="string">&quot;nokaslr&quot;</span>)) &#123;</span><br><span class="line">	warn(<span class="string">&quot;KASLR disabled: &#x27;nokaslr&#x27; on cmdline.&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有这个选项，那么我们就退出<code>choose_random_location</code>函数，并且内核的加载地址不会随机化。相关的命令行选项可以在<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/Documentation/kernel-parameters.txt">内核文档</a>找到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kaslr/nokaslr [X86]</span><br><span class="line"></span><br><span class="line">Enable/disable kernel and module base offset ASLR</span><br><span class="line">(Address Space Layout Randomization) if built into</span><br><span class="line">the kernel. When CONFIG_HIBERNATION is selected,</span><br><span class="line">kASLR is disabled by default. When kASLR is enabled,</span><br><span class="line">hibernation will be disabled.</span><br></pre></td></tr></table></figure>
<p>假设我们没有把<code>nokaslr</code>传到内核命令行，并且<code>CONFIG_RANDOMIZE_BASE</code>启用了内核配置选项。</p>
<p>下一步是以下函数的调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">initialize_identity_maps();</span><br></pre></td></tr></table></figure>
<p>它在 arch/x86/boot/compressed/pagetable.c源码文件定义。这个函数从初始化<code>mapping_info</code>,<code>x86_mapping_info</code>结构体的一个实例开始。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mapping_info.alloc_pgt_page = alloc_pgt_page;</span><br><span class="line">mapping_info.context = &amp;pgt_data;</span><br><span class="line">mapping_info.page_flag = __PAGE_KERNEL_LARGE_EXEC | sev_me_mask;</span><br><span class="line">mapping_info.kernpg_flag = _KERNPG_TABLE | sev_me_mask;</span><br></pre></td></tr></table></figure>
<p><code>x86_mapping_info</code>结构体在 arch/x86/include/asm/init.h头文件定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">x86_mapping_info</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> *(*alloc_pgt_page)(<span class="type">void</span> *);</span><br><span class="line">	<span class="type">void</span> *context;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> page_flag;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> offset;</span><br><span class="line">	<span class="type">bool</span> direct_gbpages;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> kernpg_flag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个结构体提供了关于内存映射的信息。你可能还记得，在前面的部分，我们已经建立了初始的从0到<code>4G</code>的页表。现在我们可能需要访问<code>4G</code>以上的内存来在随机的位置加载内核。所以，<code>initialize_identity_maps</code>函数初始化一个内存区域，它用于可能需要的新页表。首先，让我们尝试查看<code>x86_mapping_info</code>结构体的定义。</p>
<p><code>alloc_pgt_page</code>是一个会在为一个页表项分配空间时调用的回调函数。<code>context</code>域是一个用于跟踪已分配页表的<code>alloc_pgt_data</code>结构体的实例。<code>page_flag</code>和<code>kernpg_flag</code>是页标志。第一个代表<code>PMD</code>或<code>PUD</code>表项的标志。第二个<code>kernpg_flag</code>域代表会在之后被覆盖的内核页的标志。<code>direct_gbpages</code>域代表对大页的支持。最后的<code>offset</code>域代表内核虚拟地址到<code>PMD</code>级物理地址的偏移。</p>
<p><code>alloc_pgt_page</code>回调函数检查有一个新页的空间，从缓冲区分配新页并返回新页的地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">entry = pages-&gt;pgt_buf + pages-&gt;pgt_buf_offset;</span><br><span class="line">pages-&gt;pgt_buf_offset += PAGE_SIZE;</span><br></pre></td></tr></table></figure>
<p>缓冲区在此结构体中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_pgt_data</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *pgt_buf;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> pgt_buf_size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> pgt_buf_offset;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>initialize_identity_maps</code>函数最后的目标是初始化<code>pgdt_buf_size</code>和<code>pgt_buf_offset</code>. 由于我们只是在初始化阶段，<code>initialize_identity_maps</code>函数设置<code>pgt_buf_offset</code>为0:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pgt_data.pgt_buf_offset = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>而<code>pgt_data.pgt_buf_size</code>会根据引导加载器所用的引导协议（64位或32位）被设置为<code>77824</code>或<code>69632</code>. <code>pgt_data.pgt_buf</code>也是一样。如果引导加载器在<code>startup_32</code>引导内核，<code>pgdt_data.pgdt_buf</code>会指向已经在 arch/x86/boot/compressed/head_64.S初始化的页表的末尾：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pgt_data.pgt_buf = _pgtable + BOOT_INIT_PGT_SIZE;</span><br></pre></td></tr></table></figure>
<p>其中<code>_pgtable</code>指向这个页表 _pgtable的开头。另一方面，如果引导加载器用64位引导协议并在<code>startup_64</code>加载内核，早期页表应该由引导加载器建立，并且<code>_pgtable</code>会被重写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pgt_data.pgt_buf = _pgtable</span><br></pre></td></tr></table></figure>
<p>在新页表的缓冲区被初始化之下，我们回到<code>choose_random_location</code>函数。</p>
<h3 id="避开保留的内存范围">避开保留的内存范围</h3>
<p>在恒等映射页表相关的数据被初始化之后，我们可以开始选择放置解压后内核的随机位置。但是正如你猜的那样，我们不能选择任意地址。在内存的范围中，有一些保留的地址。这些地址被重要的东西占用，如<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Initial_ramdisk">initrd</a>, 内核命令行等等。这个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mem_avoid_init(input, input_size, *output);</span><br></pre></td></tr></table></figure>
<p>会帮我们做这件事。所有不安全的内存区域会收集到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_vector</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> start;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mem_vector</span> <span class="title">mem_avoid</span>[<span class="title">MEM_AVOID_MAX</span>];</span></span><br></pre></td></tr></table></figure>
<p>数组。其中<code>MEM_AVOID_MAX</code>来自枚举类型<code>mem_avoid_index</code>, 它代表不同类型的保留内存区域：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">mem_avoid_index</span> &#123;</span></span><br><span class="line">	MEM_AVOID_ZO_RANGE = <span class="number">0</span>,</span><br><span class="line">	MEM_AVOID_INITRD,</span><br><span class="line">	MEM_AVOID_CMDLINE,</span><br><span class="line">	MEM_AVOID_BOOTPARAMS,</span><br><span class="line">	MEM_AVOID_MEMMAP_BEGIN,</span><br><span class="line">	MEM_AVOID_MEMMAP_END = MEM_AVOID_MEMMAP_BEGIN + MAX_MEMMAP_REGIONS - <span class="number">1</span>,</span><br><span class="line">	MEM_AVOID_MAX,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>它们都定义在源文件 arch/x86/boot/compressed/kaslr.c 中。</p>
<p>让我们看看<code>mem_avoid_init</code>函数的实现。这个函数的主要目标是在<code>mem_avoid</code>数组存放关于被<code>mem_avoid_index</code>枚举类型描述的保留内存区域的信息，并且在我们新的恒等映射缓冲区为这样的区域创建新页。<code>mem_avoid_index</code>函数的几个部分很相似，但是先看看其中一个：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mem_avoid[MEM_AVOID_ZO_RANGE].start = input;</span><br><span class="line">mem_avoid[MEM_AVOID_ZO_RANGE].size = (output + init_size) - input;</span><br><span class="line">add_identity_map(mem_avoid[MEM_AVOID_ZO_RANGE].start,</span><br><span class="line">		 mem_avoid[MEM_AVOID_ZO_RANGE].size);</span><br></pre></td></tr></table></figure>
<p><code>mem_avoid_init</code>函数的开头尝试避免用于当前内核解压的内存区域。我们用这个区域的起始地址和大小填写<code>mem_avoid</code>数组的一项，并调用<code>add_identity_map</code>函数，它会为这个区域建立恒等映射页。<code>add_identity_map</code>函数在源文件 arch/x86/boot/compressed/kaslr.c定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add_identity_map</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> start, <span class="type">unsigned</span> <span class="type">long</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> end = start + size;</span><br><span class="line"></span><br><span class="line">	start = round_down(start, PMD_SIZE);</span><br><span class="line">	end = round_up(end, PMD_SIZE);</span><br><span class="line">	<span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	kernel_ident_mapping_init(&amp;mapping_info, (<span class="type">pgd_t</span> *)top_level_pgt,</span><br><span class="line">				  start, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以看到，它对齐内存到 2MB 边界并检查给定的起始地址和终止地址。</p>
<p>最后它调用<code>kernel_ident_mapping_init</code>函数，它在源文件 arch/x86/mm/ident_map.c中，并传入以上初始化好的<code>mapping_info</code>实例、顶层页表的地址和建立新的恒等映射的内存区域的地址。</p>
<p><code>kernel_ident_mapping_init</code>函数为新页设置默认的标志，如果它们没有被给出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!info-&gt;kernpg_flag)</span><br><span class="line">	info-&gt;kernpg_flag = _KERNPG_TABLE;</span><br></pre></td></tr></table></figure>
<p>并且开始建立新的2MB (因为<code>mapping_info.page_flag</code>中的<code>PSE</code>位) 给定地址相关的页表项（<a target="_blank" rel="noopener" href="https://lwn.net/Articles/717293/">五级页表</a>中的<code>PGD -&gt; P4D -&gt; PUD -&gt; PMD</code>或者<a target="_blank" rel="noopener" href="https://lwn.net/Articles/117749/">四级页表</a>中的<code>PGD -&gt; PUD -&gt; PMD</code>）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (; addr &lt; end; addr = next) &#123;</span><br><span class="line">	<span class="type">p4d_t</span> *p4d;</span><br><span class="line"></span><br><span class="line">	next = (addr &amp; PGDIR_MASK) + PGDIR_SIZE;</span><br><span class="line">	<span class="keyword">if</span> (next &gt; end)</span><br><span class="line">		next = end;</span><br><span class="line"></span><br><span class="line">    p4d = (<span class="type">p4d_t</span> *)info-&gt;alloc_pgt_page(info-&gt;context);</span><br><span class="line">	result = ident_p4d_init(info, p4d, addr, next);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们找给定地址在 <code>页全局目录</code> 的下一项，如果它大于给定的内存区域的末地址<code>end</code>，我们把它设为<code>end</code>.之后，我们用之前看过的<code>x86_mapping_info</code>回调函数分配一个新页，然后调用<code>ident_p4d_init</code>函数。<code>ident_p4d_init</code>函数做同样的事情，但是用于低层的页目录 (<code>p4d</code> -&gt; <code>pud</code> -&gt; <code>pmd</code>).</p>
<p>和保留地址相关的新页表项已经在我们的页表中。这不是<code>mem_avoid_init</code>函数的末尾，但是其他部分类似。它建立用于 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Initial_ramdisk">initrd</a>、内核命令行等数据的页。</p>
<p>现在我们可以回到<code>choose_random_location</code>函数。</p>
<h3 id="物理地址随机化">物理地址随机化</h3>
<p>在保留内存区域存储在<code>mem_avoid</code>数组并且为它们建立了恒等映射页之后，我们选择最小可用的地址作为解压内核的随机内存区域</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min_addr = min(*output, <span class="number">512UL</span> &lt;&lt; <span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<p>你可以看到，它应该小于512MB. 选择这个512MB的值只是避免低内存区域中未知的东西。</p>
<p>下一步是选择随机的物理和虚拟地址来加载内核。首先是物理地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">random_addr = find_random_phys_addr(min_addr, output_size);</span><br></pre></td></tr></table></figure>
<p><code>find_random_phys_addr</code>函数在kaslr.c源文件中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">find_random_phys_addr</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> minimum,</span></span><br><span class="line"><span class="params">                                           <span class="type">unsigned</span> <span class="type">long</span> image_size)</span></span><br><span class="line">&#123;</span><br><span class="line">	minimum = ALIGN(minimum, CONFIG_PHYSICAL_ALIGN);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (process_efi_entries(minimum, image_size))</span><br><span class="line">		<span class="keyword">return</span> slots_fetch_random();</span><br><span class="line"></span><br><span class="line">	process_e820_entries(minimum, image_size);</span><br><span class="line">	<span class="keyword">return</span> slots_fetch_random();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>process_efi_entries</code>函数的主要目标是在整个可用的内存找到所有的合适的内存区域来加载内核。如果内核没有在支持<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface">EFI</a>的系统中编译和运行，我们继续在<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/E820">e820</a>区域中找这样的内存区域。所有找到的内存区域会存储在</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slot_area</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> addr;</span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SLOT_AREA 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">slot_area</span> <span class="title">slot_areas</span>[<span class="title">MAX_SLOT_AREA</span>];</span></span><br></pre></td></tr></table></figure>
<p>数组中。内核解压器应该选择这个数组随机的索引，并且它会是内核解压的随机位置。这个选择会被<code>slots_fetch_random</code>函数执行。<code>slots_fetch_random</code>函数的主要目标是通过<code>kaslr_get_random_long</code>函数从<code>slot_areas</code>数组选择随机的内存范围：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slot = kaslr_get_random_long(<span class="string">&quot;Physical&quot;</span>) % slot_max;</span><br></pre></td></tr></table></figure>
<p><code>kaslr_get_random_long</code>函数在源文件 arch/x86/lib/kaslr.c中定义，它返回一个随机数。注意这个随机数会通过不同的方式得到，取决于内核配置、系统机会（基于<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">时间戳计数器</a>的随机数、<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/RdRand">rdrand</a>等等）。</p>
<p>这就是随机内存范围的选择方法。</p>
<h3 id="虚拟地址随机化">虚拟地址随机化</h3>
<p>在内核解压器选择了随机内存区域后，新的恒等映射页会为这个区域按需建立：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">random_addr = find_random_phys_addr(min_addr, output_size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*output != random_addr) &#123;</span><br><span class="line">		add_identity_map(random_addr, output_size);</span><br><span class="line">		*output = random_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时，<code>output</code>会存放内核将会解压的一个内存区域的基地址。但是现在，正如你还记得的那样，我们只是随机化了物理地址。在<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/X86-64">x86_64</a>架构，虚拟地址也应该被随机化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_X86_64))</span><br><span class="line">	random_addr = find_random_virt_addr(LOAD_PHYSICAL_ADDR, output_size);</span><br><span class="line"></span><br><span class="line">*virt_addr = random_addr;</span><br></pre></td></tr></table></figure>
<p>正如你所看到的，对于非<code>x86_64</code>架构，随机化的虚拟地址和随机化的物理地址相同。<code>find_random_virt_addr</code>函数计算可以保存内存镜像的虚拟内存范围的数量并且调用我们在尝试找到随机的<code>物理</code>地址的时候，之前已经看到的<code>kaslr_get_random_long</code>函数。</p>
<p>这时，我们同时有了用于解压内核的随机化的物理(<code>*output</code>)和虚拟(<code>*virt_addr</code>)基地址。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blackforest1990.github.io">BlackForest1990</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blackforest1990.github.io/2024/03/21/Linux-Booting/">https://blackforest1990.github.io/2024/03/21/Linux-Booting/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blackforest1990.github.io" target="_blank">黑暗森林</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Kernel/">Kernel</a></div><div class="post_share"><div class="social-share" data-image="/image/blackforest.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>谢谢支持</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechatpay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechatpay.jpg"/></a><div class="post-qr-code-desc"></div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/03/26/virtual-memory/" title="virtual memory"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">virtual memory</div></div></a></div><div class="next-post pull-right"><a href="/2024/03/19/mainmemory/" title="main memory"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">main memory</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/04/19/Initialization/" title="Initialization"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-08-04</div><div class="title">Initialization</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%BC%95%E5%AF%BC%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F%E5%86%85%E6%A0%B8"><span class="toc-number">1.</span> <span class="toc-text">从引导加载程序内核</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%EF%BC%81"><span class="toc-number">1.1.</span> <span class="toc-text">启动！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%AF%BC%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.2.</span> <span class="toc-text">引导程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.3.</span> <span class="toc-text">内核设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.4.</span> <span class="toc-text">段寄存器设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%A0%86%E6%A0%88"><span class="toc-number">1.5.</span> <span class="toc-text">设置堆栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BSS%E6%AE%B5%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.6.</span> <span class="toc-text">BSS段设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%BD%AC%E5%88%B0-main-%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.</span> <span class="toc-text">跳转到 main 函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E5%86%85%E6%A0%B8%E5%AE%89%E8%A3%85%E4%BB%A3%E7%A0%81%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AD%A5"><span class="toc-number">2.</span> <span class="toc-text">在内核安装代码的第一步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">保护模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0%E6%8B%B7%E8%B4%9D%E5%88%B0-zeropage"><span class="toc-number">2.2.</span> <span class="toc-text">将启动参数拷贝到&quot;zeropage&quot;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.3.</span> <span class="toc-text">控制台初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.4.</span> <span class="toc-text">堆初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5CPU%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.5.</span> <span class="toc-text">检查CPU类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E4%BE%A6%E6%B5%8B"><span class="toc-number">2.6.</span> <span class="toc-text">内存分布侦测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%AE%E7%9B%98%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.7.</span> <span class="toc-text">键盘初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">显示模式初始化和进入保护模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">内核数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%93%8D%E4%BD%9CAPI"><span class="toc-number">3.2.</span> <span class="toc-text">堆操作API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.3.</span> <span class="toc-text">设置显示模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%88%87%E6%8D%A2%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%89%8D%E7%9A%84%E6%9C%80%E5%90%8E%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%E3%80%82"><span class="toc-number">3.4.</span> <span class="toc-text">在切换到保护模式之前的最后准备工作。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8"><span class="toc-number">3.5.</span> <span class="toc-text">设置中断描述符表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8"><span class="toc-number">3.6.</span> <span class="toc-text">设置全局描述符表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E5%88%B064%E4%BD%8D%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">切换到64位模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#32%E4%BD%8D%E5%85%A5%E5%8F%A3%E7%82%B9"><span class="toc-number">4.1.</span> <span class="toc-text">32位入口点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%85%E8%A6%81%E6%97%B6%E5%8A%A0%E8%BD%BD%E5%86%85%E5%AD%98%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">4.2.</span> <span class="toc-text">必要时加载内存段寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%BB%BA%E7%AB%8B%E5%92%8C-CPU-%E7%9A%84%E7%A1%AE%E8%AE%A4"><span class="toc-number">4.3.</span> <span class="toc-text">栈的建立和 CPU 的确认</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%9C%B0%E5%9D%80"><span class="toc-number">4.4.</span> <span class="toc-text">计算重定位地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E9%95%BF%E6%A8%A1%E5%BC%8F%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-number">4.5.</span> <span class="toc-text">进入长模式前的准备工作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.6.</span> <span class="toc-text">长模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E6%9C%9F%E9%A1%B5%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.7.</span> <span class="toc-text">初期页表初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E5%88%B0%E9%95%BF%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.8.</span> <span class="toc-text">切换到长模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E8%A7%A3%E5%8E%8B"><span class="toc-number">5.</span> <span class="toc-text">内核解压</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%86%85%E6%A0%B8%E8%A7%A3%E5%8E%8B%E5%89%8D%E7%9A%84%E6%9C%80%E5%90%8E%E5%87%86%E5%A4%87"><span class="toc-number">5.1.</span> <span class="toc-text">在内核解压前的最后准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E8%A7%A3%E5%8E%8B-2"><span class="toc-number">5.2.</span> <span class="toc-text">内核解压</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%9C%B0%E5%9D%80%E9%9A%8F%E6%9C%BA%E5%8C%96"><span class="toc-number">6.</span> <span class="toc-text">内核地址随机化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">6.1.</span> <span class="toc-text">页表的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%BC%80%E4%BF%9D%E7%95%99%E7%9A%84%E5%86%85%E5%AD%98%E8%8C%83%E5%9B%B4"><span class="toc-number">6.2.</span> <span class="toc-text">避开保留的内存范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E9%9A%8F%E6%9C%BA%E5%8C%96"><span class="toc-number">6.3.</span> <span class="toc-text">物理地址随机化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E9%9A%8F%E6%9C%BA%E5%8C%96"><span class="toc-number">6.4.</span> <span class="toc-text">虚拟地址随机化</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By BlackForest1990</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">如果只允许一种声音存在，那么，唯一存在的那个声音就是谎言。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>