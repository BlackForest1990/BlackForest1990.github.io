{"meta":{"title":"黑暗森林","subtitle":"谁是猎物，谁是猎人？","description":"程序&读书","author":"BlackForest1990","url":"https://blackforest1990.github.io","root":"/"},"pages":[{"title":"categories","date":"2023-03-14T09:15:12.000Z","updated":"2023-03-14T09:15:42.088Z","comments":true,"path":"categories/index.html","permalink":"https://blackforest1990.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-03-14T08:49:03.000Z","updated":"2023-03-14T08:59:35.881Z","comments":true,"path":"tags/index.html","permalink":"https://blackforest1990.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Tcp&ip","slug":"Tcp-ip","date":"2024-01-16T04:52:04.000Z","updated":"2024-01-16T08:00:16.583Z","comments":true,"path":"2024/01/16/Tcp-ip/","link":"","permalink":"https://blackforest1990.github.io/2024/01/16/Tcp-ip/","excerpt":"","text":"本文基于一个TCP&amp;IP项目进行学习，主要目的是来探索网络编程的奇妙。如下为本次学习的一些网络库和知识库。 代码参考：https://github.com/saminiir/level-ip 基础知识参考：https://beej-zhcn.netdpi.net/ TCP&amp;IP 协议层 网络接口层（Network Interface Layer）： 对应于OSI模型的物理层和数据链路层。负责将数据帧封装成比特流，并处理与物理网络设备的交互。 网络层（Internet Layer）： 对应于OSI模型的网络层。主要功能是在网络中路由数据包，为数据包选择最佳路径。IP协议是在这一层工作的关键协议。 传输层（Transport Layer）： 对应于OSI模型的传输层。负责端到端的通信，提供可靠的数据传输。TCP（传输控制协议）和UDP（用户数据报协议）是在这一层工作的协议。 应用层（Application Layer）： 对应于OSI模型的会话层、表示层和应用层。包含了各种应用程序，如HTTP（超文本传输协议）、FTP（文件传输协议）、SMTP（简单邮件传输协议）等。 Ethernet &amp; ARP TAP设备 为了拦截来自 Linux 内核的低级网络流量，我们将使用 Linux TAP 设备。简而言之，网络用户空间应用程序通常使用 TUN/TAP 设备分别操作 L3/L2 流量。在Linux中，TAP代表（Tap Virtual Network Device）。TAP设备是一种虚拟网络设备，通常用于模拟网络连接或实现虚拟专用网络（VPN）等网络功能。由于我们想要从第 2 层开始构建网络堆栈，因此我们需要一个 TAP 设备。我们像这样实例化它： 123456789101112131415161718192021222324252627282930313233static int tun_alloc(char *dev)&#123; struct ifreq ifr; int fd, err; if( (fd = open(&quot;/dev/net/tap&quot;, O_RDWR)) &lt; 0 ) &#123; perror(&quot;Cannot open TUN/TAP dev\\n&quot; &quot;Make sure one exists with &quot; &quot;&#x27;$ mknod /dev/net/tap c 10 200&#x27;&quot;); exit(1); &#125; CLEAR(ifr); /* Flags: IFF_TUN - TUN device (no Ethernet headers) * IFF_TAP - TAP device * * IFF_NO_PI - Do not provide packet information */ ifr.ifr_flags = IFF_TAP | IFF_NO_PI; if( *dev ) &#123; strncpy(ifr.ifr_name, dev, IFNAMSIZ); &#125; if( (err = ioctl(fd, TUNSETIFF, (void *) &amp;ifr)) &lt; 0 )&#123; perror(&quot;ERR: Could not ioctl tun&quot;); close(fd); return err; &#125; strcpy(dev, ifr.ifr_name); return fd;&#125; 在这之后，返回的文件描述符fd可以用于读取和写入数据到虚拟设备的以太网缓冲区。IFF_NO_PI标志在这里非常关键，否则我们将得到不必要的数据包信息附加到以太网帧之前。 以太网帧格式 多种不同的以太网技术是连接局域网(LAN) 中计算机的支柱。 以太网标准：https://en.wikipedia.org/wiki/IEEE_802.3 接下来，我们将看一下以太网帧头。可以将其声明为 C 结构体，如下所示： 1234567struct eth_hdr &#123; uint8_t dmac[6]; uint8_t smac[6]; uint16_t ethertype; uint8_t payload[];&#125; __attribute__((packed)); dmac smac: 它们包含通信双方的 MAC 地址（分别是目标和源）。 重载字段ethertype是一个 2 个八位字节的字段，根据其值，指示有效负载的长度或类型。具体来说，如果该字段的值大于或等于1536，则该字段包含有效负载的类型（例如IPv4、ARP）。如果该值小于该值，则它包含有效负载的长度。 在类型字段之后，以太网帧可能有几个不同的标签。这些标签可用于描述帧的虚拟 LAN (VLAN) 或服务质量(QoS) 类型。以太网帧标签被排除在我们的实现之外，因此相应的字段也不会出现在我们的协议声明中。 payload包含指向以太网帧有效负载的指针。在我们的例子中，这将包含 ARP 或 IPv4 数据包。如果有效负载长度小于所需的最小48字节（不含标签），则将填充字节附加到有效负载的末尾以满足要求。 我们还包含if_ether.hLinux 标头来提供以太类型及其十六进制值之间的映射。 最后，以太网帧格式末尾还包括帧校验序列字段，该字段与循环冗余校验（CRC）一起用于检查帧的完整性。我们将在实现中省略对该字段的处理。 __attribute__((packed))：这是一个GCC特有的属性，用于告诉编译器以最小的字节对齐方式来布局结构体，确保没有额外的填充字节。这对于网络协议帧头等需要严格字节对齐的结构体来说是重要的。 以太网帧解析 解析和处理传入以太网帧的总体场景非常简单： 1234567if (tun_read(buf, BUFLEN) &lt; 0) &#123; print_error(&quot;ERR: Read from tun_fd: %s\\n&quot;, strerror(errno));&#125;struct eth_hdr *hdr = init_eth_hdr(buf);handle_frame(&amp;netdev, hdr); 地址解析协议 地址解析协议（ARP）用于将48位以太网地址（MAC地址）动态映射到协议地址（例如IPv4地址）。这里的关键是，通过 ARP，可以使用多种不同的 L3 协议：不仅是 IPv4，还有其他协议。通常的情况是知道 LAN 中某些服务的 IP 地址，但要建立实际通信，还需要知道硬件地址 (MAC)。因此，ARP用于广播和查询网络，要求IP地址的所有者报告其硬件地址。 ARP数据包格式比较简单： 123456789struct arp_hdr&#123; uint16_t hwtype; uint16_t protype; uint8_t hwsize; uint8_t prosize; uint16_t opcode; unsigned char data[];&#125; __attribute__((packed)); ARP 标头 ( arp_hdr) 包含 2 个八位字节hwtype，它确定所使用的链路层类型。在我们的例子中，这是以太网，实际值为0x0001。 2 个八位字节protype字段指示协议类型。在我们的例子中，这是 IPv4，通过值 进行通信0x0800。 hwsize（硬件地址长度）： 一个8位的整数，表示硬件地址的长度，以字节为单位 prosize（协议地址长度）：一个8位的整数，表示协议地址的长度，以字节为单位。 2 个八位字节字段opcode声明 ARP 消息的类型。它可以是 ARP 请求 (1)、ARP 应答 (2)、RARP 请求 (3) 或 RARP 应答 (4)。 该data字段包含 ARP 消息的实际负载，在我们的例子中，它将包含 IPv4 特定信息： 1234567struct arp_ipv4&#123; unsigned char smac[6]; uint32_t sip; unsigned char dmac[6]; uint32_t dip;&#125; __attribute__((packed)); 这些字段非常不言自明。smac dmac分别包含发送方和接收方的 6 字节 MAC 地址。sip和dip分别包含发送者和接收者的 IP 地址。 地址解析算法 检查硬件类型（ar$hrd）： 如果硬件类型存在（几乎肯定存在），继续。 可选地检查硬件长度（ar$hln）： 检查协议类型（ar$pro）： 如果协议类型存在，继续。 可选地检查协议长度（ar$pln）： 初始化Merge_flag为false： 检查转换表中是否存在 &lt;协议类型，发送者协议地址&gt; 这一对： 如果已存在： 使用数据包中的新信息更新该条目的发送者硬件地址字段。 将 Merge_flag 设置为 true。 检查当前设备是否是目标协议地址： 如果是： 如果 Merge_flag 为false，则将 &lt;协议类型，发送者协议地址，发送者硬件地址&gt; 添加到转换表中。 检查操作码是否是ARP请求 (ares_op$REQUEST)： 如果是： 交换硬件和协议字段，将本地硬件和协议地址放入发送者字段。 将 ar$op 字段设置为 ares_op$REPLY。 将数据包发送到在同一硬件上收到请求时的新目标硬件地址。 这个算法描述了在接收到ARP请求时的处理流程，包括更新转换表、响应ARP请求和发送ARP回复。 translation table用于存储 ARP 结果，以便主机只需查找其缓存中是否已有该条目即可。这可以避免向网络发送冗余 ARP 请求的垃圾邮件。 IPv4 and ICMPv4 IPv4 我们的实现中的下一层 (L3)（在以太网帧之后）处理将数据传送到目的地的情况。也就是说，互联网协议(IP) 的发明是为了为 TCP 和 UDP 等传输协议提供基础。它是无连接的，这意味着与 TCP 不同，所有数据报在网络堆栈中都是相互独立处理的。这也意味着 IP 数据报可能会无序到达。 此外，IP 并不能保证成功传输。这是协议设计者有意识的选择，因为 IP 旨在为同样不保证传输的协议提供基础。UDP 就是这样一种协议。如果通信双方之间需要可靠性，则可以在 IP 之上使用 TCP 等协议。在这种情况下，更高级别的协议负责检测丢失的数据并确保所有数据均已传输。 Header IPv4 标头的长度通常为 20 个八位位组。标头可以包含尾随选项，但我们的实现中省略了它们。字段的含义相对简单，可以用 C 结构体来描述： 1234567891011121314struct iphdr &#123; uint8_t ihl : 4; /* TODO: Support Big Endian hosts */ uint8_t version : 4; uint8_t tos; uint16_t len; uint16_t id; uint16_t frag_offset; uint8_t ttl; uint8_t proto; uint16_t csum; uint32_t saddr; uint32_t daddr; uint8_t data[];&#125; __attribute__((packed)); 4 位字段version指示 Internet 标头的格式。在我们的例子中，IPv4 的值为 4。 互联网报头长度字段ihl的长度同样为 4 位，由于该字段的大小为 4 位，因此它最多只能容纳 15。因此，IP 标头的最大长度为 60 个八位字节（15 乘以 32 除以 8）。 服务类型字段源自tos为IP 数据报的服务质量。 总长度字段len 传达整个 IP数据报的长度。由于它是 16 位字段，因此最大长度为 65535 字节。大型 IP 数据报会被分割成更小的数据报，以满足不同通信接口的最大传输单元(MTU)。 id字段用于索引数据报，最终用于重组分片的IP数据报。该字段的值只是一个由发送方递增的计数器。反过来，接收方知道如何对传入的片段进行排序。 flags字段定义了数据报的各种控制标志。具体来说，发送方可以指定数据报是否允许分片，是否是最后一个分片，或者是否还有更多分片传入。 片段偏移字段frag_offset指示片段在数据报中的位置。当然，第一个数据报的索引设置为 0。 ttl是一个常见属性，数据报的生命周期。它通常由原始发送方设置为 64，每个接收方都会将该计数器减 1。当它达到零时，数据报将被丢弃，并且可能会回复一条 ICMP 消息以指示错误。 该proto字段为数据报提供了在其有效负载中携带其他协议的固有能力。该字段通常包含 16 (UDP) 或 6 (TCP) 等值，仅用于向接收方传达实际数据的类型。 报头校验和字段csum，用于验证 IP 报头的完整性。 最后，saddr和daddr字段分别指示数据报的源地址和目标地址。 Internet Checksum 互联网校验和字段用于检查 IP 数据报的完整性。算法的实际代码如下： 12345678910111213141516171819202122232425262728293031323334uint32_t sum_every_16bits(void *addr, int count)&#123; register uint32_t sum = 0; uint16_t * ptr = addr; while( count &gt; 1 ) &#123; /* This is the inner loop */ sum += * ptr++; count -= 2; &#125; /* Add left-over byte, if any */ if( count &gt; 0 ) sum += * (uint8_t *) ptr; return sum;&#125;uint16_t checksum(void *addr, int count, int start_sum)&#123; /* Compute Internet Checksum for &quot;count&quot; bytes * beginning at location &quot;addr&quot;. * Taken from https://tools.ietf.org/html/rfc1071 */ uint32_t sum = start_sum; sum += sum_every_16bits(addr, count); /* Fold 32-bit sum to 16 bits */ while (sum&gt;&gt;16) sum = (sum &amp; 0xffff) + (sum &gt;&gt; 16); return ~sum;&#125; sum_every_16bits 函数： 参数 void *addr 是指向内存地址的指针，表示数据的起始地址。 参数 int count 是要计算校验和的数据字节数。 函数使用指针 ptr 迭代访问数据，每次累加两个字节的值到 sum 中，直到处理完所有的字节。 如果数据字节数是奇数，最后一个字节单独累加。 返回一个 32 位整数，表示所有 16 位字的和。 checksum 函数： 参数 void *addr 是数据的起始地址。 参数 int count 是要计算校验和的数据字节数。 参数 int start_sum 是初始的校验和值。 函数调用 sum_every_16bits 函数计算数据的 16 位字的和，然后将其加到初始校验和值 start_sum 中。 然后，使用一个循环将 32 位的和折叠为 16 位，直到和不再超过 16 位。 最后，返回计算得到的校验和的一位补码。 这些函数的目的是按照 RFC1071 中描述的方式计算 Internet 校验和。计算校验和的过程涉及将所有 16 位字相加，然后将 32 位和折叠为 16 位。最终，返回的值是校验和的一位补码。","categories":[{"name":"编程","slug":"编程","permalink":"https://blackforest1990.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"how to make","slug":"how-to-make","permalink":"https://blackforest1990.github.io/tags/how-to-make/"}]},{"title":"万历十五年读书笔记","slug":"万历十五年读书笔记","date":"2024-01-09T09:42:32.000Z","updated":"2024-01-10T04:15:14.998Z","comments":true,"path":"2024/01/09/万历十五年读书笔记/","link":"","permalink":"https://blackforest1990.github.io/2024/01/09/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","excerpt":"","text":"​ 万历十五年，黄公仁宇之大作，英文名为“1587, A year of No Significance”, 在历史上1587实在为寡淡的一年，但是通过这一年万历皇帝，申时行，张居正，海瑞，戚继光等人的遭遇，阐述出明帝国在结构系统上的硬伤，无论如何的天纵奇才都不可能避免走向衰落。 ​ 明朝的衰败，实为制度的衰败，名为帝国，在本质上无非是数不清的农村合并成的一个集合体，礼仪和道德代替了法律，对于违法的行为作掩饰则被认为忠厚识大体。各个机构之间的联系，从来没有可资遵守的成文条例，所以造成行政效率低下，整个国家不能做到如臂指使的运转。当一个人口众多的国家，各人行动全凭儒家简单粗浅而又无法固定的原则所限制，而法律又缺乏创造性，则其社会发展的程度，必然受到限制。即便是宗旨善良，也不能补助技术之不及。 万历皇帝 ​ 万历皇帝朱翊（yì）钧（jūn）为国家的最高元首，本朝在开国之初曾经设立过丞相的职位，经过一个时期，内阁大学士在某种程度上就行使了丞相的职权。这种以阁臣代行相职的制度，来源于开国之君为了巩固政权而做出的苦心设计，目的是使皇权不被分割，也不致为旁人取代。大学士原来属于文学侍从之臣。由于殿试时文理出众，名列前茅，就可以进入翰林院。翰林几经升转，其中最突出的人物就可以被任命为大学士，供职于文渊阁。由于文渊阁是皇帝的文书机构，和皇帝最为接近，在不设丞相的情况下，这个机构的职权就由于处理政事的需要而越来越大，大学士一职也变成了皇帝的秘书而兼顾问，张居正名为首辅，或称元辅，其他大学士的任命则出于他的推荐。大学士之中有了主次之分，造成了今后朝臣之间的更加复杂的纠纷局面。内阁制度，破坏了皇帝-群臣-相的体系（皇帝负责天命和军事，宰相负责政务和官员任命），造成了文官体系的无比强大。万历皇帝在励精图治以后，发现了文官体系的不可战胜，从此不在做反抗，让帝国慢慢腐烂下去。 张居正 ​ 洪武皇帝两百年以前创建本朝，并确立了整套的政治和经济制度，其主要的着眼点在于保存一个农业社会的俭朴风气。当时全国的文官仅有八千人。所有办理文牍和事务的技术人员称之为“吏”，和文官属于两个不同的阶层，如泾渭之分明。官可以罚降为吏，吏却很少能上升为官。这些吏的薪给极为微薄，仅足以供一家糊。农村的组织方式是以每一乡村为单位，构成一个近于自治的集团，按照中央政府的规定订立自己的乡约。一村内设“申明亭”和“旌善亭”各一座，前者为村中耆老仲裁产业、婚姻、争斗等纠纷的场所，后者则用以表扬村民中为人所钦佩的善行。洪武皇帝所推行的农村政策及一整套的措施，对本朝今后的历史，影响至为深远。其最显著的后果是，在全国的广大农村中遏止了法制的成长发育，而以抽象的道德取代了法律。上自官僚下至村民，其判断是非的标准是“善”和“恶”，而不是“合法”或“非法”。在财政制度上，政府规定了按面积征收田赋，除浙西（当时的浙西包括今日的苏南）而外，其他地区的税率都比较低。征收不分贫富，其限制富户的办法即上述的服役。征收不分贫富，其限制富户的办法为服役。这种服役名目繁多，而且按累进税的原则分派，即家室愈是殷富，其负担也愈是繁重。这种以赢补亏而不由上级机关总揽收支以节约交通、通讯、簿记、仓库管理等各项后勤支出的财政制度贯彻于始终。全国满布着无数的短途运输线，缺乏统一的组织和管理。到后来税收已由实物折为现银。这种原始的方式也由于积重难返，而且中级机构又缺乏组织，而无法完全改变。显而易见，这种财政制度的弊病在于缺乏弹性，不能适应环境而调整。各府县的税率、税额长期凝固，即使耕地的收获量增加，其利益也为业主和高利贷者分润，于国库则无所裨益。 ​ 当张居正出任首辅的时候，本朝已经有了两百年的历史。开国时的理想和所提倡的风气与今天的实际距离已经愈来愈远了。很多问题，按理说应该运用组织上的原则予以解决，但事实上无法办到，只能代之以局部的人事调整。这种积弊的根源在于财政的安排。在开国之初，政府厘定各种制度，其依据的原则是“四书”上的教条，认为官员们应当过简单朴素的生活是万古不磨的真理。从这种观念出发而组成的文官集团，是一个庞大无比的组织，在中央控制下既没有重点，也没有弹性，更谈不上具有随着形势发展而作调整的能力。各种技术力量，诸如交通通讯、分析统计、调查研究、控制金融、发展生产等等则更为缺乏。一个必然的后果，即政府对民间的经济发展或衰退，往往感到隔膜，因之税收和预算不能随之而增加或减缩。财政上死板、混乱与缺乏控制，给予官员的俸禄又微薄到不合实际，官员们要求取得额外收入也就是不可避免的了。以张居正的精明干练，他没有能解决这个问题。他的十年首辅生涯，仅仅刚把问题看清楚。他的一套改革办法使文官们感受到极大的压力而不能成功，而且招致了死后的被清算。 申时行 ​ 申时行为皇帝的老师，张居正死后，申时行担任首辅，接替他的位置，他胸中富有积蓄，但是不近悬崖，不树异帜，在张居正死后，他承认张居正的过错，但并不借此夸大前任的过失，作为自己执政的资本。施政的要诀，仍不外以抽象的方针为主，以道德为一切事业的根基。朝廷最大的任务是促进文官之间的互相信赖与和谐。除非把全部文官罢免，而代之以不同的组织和不同的原则，身为首辅的人只能和文官合作，按照他们的共同意志办事。申时行没有忽略文官的双重性格：即虽称公仆，实系主人；有阳则有阴。他必须恰如其分地处理此中矛盾。时势要求申时行充当和事佬，他就担任这样角色。他不得不把目标降低。他所说的“使不肖者犹知忌惮，而贤者有所依归”，就表现了他调和这阴阳两极的方针。他无意于鼓励不法，但也不能对操守过于认真。他欣赏自己“从中调剂，就事匡维”这一处世和执政的原则，对待皇帝的办法则是“显谏者不若潜移为妙”，因为这种办法既对皇帝的权威无损，而臣下的目的又可以达到。 海瑞 ​ 和很多同僚不同，海瑞不能相信治国的根本大计是在上层悬挂一个抽象的、至美至善的道德标准，而责成下面的人在可能范围内照办，行不通就打折扣。而他的尊重法律，乃是按照规定的最高限度执行。 海瑞充分重视法律的作用并且执法不阿，但是作为一个在圣经贤传培养下成长的文官，他又始终重视伦理道德的指导作用： 凡讼之可疑者，与其屈兄，宁屈其弟；与其屈叔伯，宁屈其侄。与其屈贫民，宁屈富民；与其屈愚直，宁屈刁顽。事在争产业，与其屈小民，宁屈乡宦，以救弊也。事在争言貌，与其屈乡宦，宁屈小民，以存体也。 用这样的精神来执行法律，确实与“四书”的训示相符合。可是他出任文官并在公庭判案，上距“四书”的写作已经两千年，距本朝的开国也已近两百年。这一段有关司法的建议恰恰暴露了这个帝国在制度上长期存在的困难：以熟读诗书的文人治理农民，他们不可能改进这个司法制度，更谈不上保障人权。法律的解释和执行离不开传统的伦理，组织上也没有对付复杂的因素和多元关系的能力。 戚继光 ​ 武将领兵作战，和文官集团的施政原则在根本上是不能相容的。当社会和经济的发展不能平衡，冲突激化，以政治手段调剂无效，通常就会导致战争。有时候严重的天灾造成大面积的饥荒，百姓面对死亡的威胁，也会铤而走险，诉诸武力。但是我们帝国的文官，则一贯以保持各方面的平衡作为施政的前提，如果事情弄到动用武力，对他们来说就是失败的象征。他们具有一种牢不可破的观念，即上自国家，下至个人，不能把力量作为权威。如果一个地区有什么特殊的经济利益，那么就应当加以压抑，而不是提倡。至于天灾足以引起战争，则尤为无知妄说，因为从道德观念来说，天下的事物无不可以共同分配，灾民的暴动乃是小人犯上作乱的劣根性使然。 ​ 在维持军队给养的问题上，同样表现了帝国政府重文轻武的风气。让军人自己组织和管理后方勤务，根本不能考虑；即使是在文官管辖之下，把仓库的地点按照战略需要来作适当的配置，也被看作有背于平衡施政的原则。述种风气还使军人退伍以后不能得到正常的社会地位。本朝治理农民的根本方针是保持他们的淳朴无知，一个士兵退伍还乡，就等于增加一个无业游民，因为他在军队里所学到的技术和养成的起居习惯，已经难于再度适应农村的生活，事情的复杂性就会因之而增加。军官退伍以后所引起的问题更为严重。在别的国家里，一个退伍军官通常都受到应有的尊敬，如果担任民政职务，他的管理经验也能保证他胜任愉快。然而事情适得其反，我们的军官在长期训练中所培养的严格和精确，退伍以后竟毫无用武之地。他会发现在军队以外，人们所重视的是安详的仪表、华丽的文辞、口若悬河的辩才以及圆通无碍的机智。 ​ 也许是有鉴于唐朝藩镇的跋扈，本朝从洪武开始，就具有这重文轻武的趋向。大约经过了一百年，文官集团进入了成熟的阶段，他们的社会地位上升到历史上的最高点；换句话说，也就是武官的社会地位下降到历史上的最低点。这种畸形的出现，原因在于本朝的政治组织为一元化，一元化的思想基础则是两千年来的孔孟之道。如果让军队保持独立的、严格的组织，和文官集团分庭抗礼，这一元化的统治就不可能如所预期地成长、发展，以至于登峰造极。这种制度既经固定，将领们即使出生入死，屡建奇功，其社会影响，也未必抵得上一篇精彩的大块文章。这种制度和风气所造成的严重后果早已被事实所证明。 ​ 面对这样令人焦虑的局面，戚继光的任务决不仅止于单纯地击败倭寇。他首先要组织一支新型的军队，从他的军事著作《纪效新书》中可以看到如何有条不紊地实施他的建军方案：宣布招兵的办法，规定月饷的数字，拟订分配列兵职务的原则，明确官兵的职责，设计队、哨、局的组织，统一武器的规格，颁发旗帜金鼓这一类通讯器材，等等。他所制定的赏罚原则并不完全决定于战斗的胜负。即使大败，有功者仍然要给予奖赏；相反，即使大胜，作战不力和临阵脱逃者仍然要受到处罚。 ​ 在戚继光以前，在军队中受到重视的是个人的武艺，等到他们被有组织的倭寇屡屡击溃以后，当局者才觉悟到一次战斗的成败并非完全决定于个人武艺。戚继光对一个步兵班作了如下的配置：队长一名，火伕一名，战士十名。这这种配置由于左右对称而名为“鸳鸯阵”。右边持方形藤牌的士兵，其主要的任务在于保持既得的位置，稳定本队的阵脚。左边持圆形藤牌的士兵，则要匍匐前进，并在牌后掷出标枪，引诱敌兵离开有利的防御的位置。引诱如果成功，后面的两个士兵则以狼筅把敌人扫倒于地，然后让手持长枪的伙伴一跃而上把敌人刺死戳伤。最后两个手持镋钯的士兵则负责保护本队的后方，警戒侧翼，必要时还可以支援前面的伙伴，构成第二线的攻击力量。可以明显地看出，这一个十二人的步兵班乃是一个有机的集体。预定的战术取得成功，全靠各个士兵分工合作，很少有个人突出的机会。正由于如此，主将戚继光才不惮其烦地再三申明全队人员密切配合的重要性，并以一体赏罚来作纪律上的保证。 ​ 戚继光的方案比较现实。他没有去触动整个的国家体制，而只是脚踏实地，做他职责范围内力所能及的事。他的部队从来没有一个后勤司令，也没有一个固定的军需处和兵工署。在整个国家机构之中，也没有委派过向他的部队作后勤供应的专职人员。他部队中的装备和武器，来源于各府县的分散供应。这种情况自然不能保持武器的质量。戚继光的募兵原则是只收农民，而不收城市居民。他认为来自市井的人都属于狡猾无赖之徒。这种观点，虽然有它的片面性，但揆诸实际，在城市中有固定职业的人是极少自愿从军的。士兵为社会所普遍轻视，其军饷也相当微薄，城市中的应募者绝大多数只是把兵营当作解决食宿的救济所，一有机会就想另谋高就。戚继光的求实精神还表现于使革新不与传统距离过远，更不大事声张。他的部队保留了古老而朴素的农村作风，有时也和卫所内来自军户的部队并肩作战。他们日常的军饷，大体和在农村中充当短工的收入相等，但另设重赏以鼓励士气，一个敌军的头颅，赏额高达白银三十两。在作战中，总兵戚继光不惜初期接战的损失。经验告诉他，战斗无非是击破敌方的军事组织。如果以雷霆万钧之力，加于对方组织重点之上，则其配转运活的枢纽既被消灭，其全局必迅速瓦解。 ​ 在抗倭战争中功绩最为卓著的戚继光不是在理想上把事情做得至善至美的将领，而是最能适应环境以发挥他的天才的将领。他所以获得成功的要点，在于他清醒的现实感。他看清并适应了当时的政治，而把军事技术作为必要的辅助，这是在当时的环境里惟一可以被允许的方案。至于在一个以文人治国的农业国家之内，谁想要极端强调军事效率，提倡技术的发展，而导致军人和文官的并驾齐驱，哪怕他能举出无数动听的理由，在事实上也是绝对办不到的。 ​ 本书清晰透彻，明朝有如submarine sandwich，上面是一块长面包，大而无当，此乃文官集团；下面也是一块长面包，也没有有效的组织，此乃成千上万的农民。其中三个基本的组织原则，此即尊卑男女老幼，没有一个涉及经济及法治和人权，也没有一个可以改造利用。中国以道德代替法律，作者批评得很透彻。但西方的法律，也非道德的根源。比如西方所谓“自由”及“民主”，都是抽象的观念，务必透过每一个国家的地理及历史上的因素，才行得通。英国之民主，即不可能与日本之民主相同，而法国的自由也和美国的自由有差别。大历史的观点，亦即是从“技术上的角度看历史”(technical interpretation of history)。中国的革命，好像一个长隧道，须要一百零一年才可以通过。我们的生命纵长也难过九十九岁。以短衡长，只是我们个人对历史的反应，不足为大历史。将历史的基点推后三五百年才能摄入大历史的轮廓。","categories":[{"name":"历史","slug":"历史","permalink":"https://blackforest1990.github.io/categories/%E5%8E%86%E5%8F%B2/"}],"tags":[{"name":"黄仁宇","slug":"黄仁宇","permalink":"https://blackforest1990.github.io/tags/%E9%BB%84%E4%BB%81%E5%AE%87/"}]},{"title":"CPU调度","slug":"CPU调度","date":"2024-01-03T05:03:58.000Z","updated":"2024-01-09T05:29:23.285Z","comments":true,"path":"2024/01/03/CPU调度/","link":"","permalink":"https://blackforest1990.github.io/2024/01/03/CPU%E8%B0%83%E5%BA%A6/","excerpt":"","text":"基本概念 ​ 多道程序设计的目标是始终有一些进程在运行，以最大限度地提高CPU利用率。在一次性保持内存中有多个进程。当一个进程必须等待时，操作系统将CPU从该进程中取走，并将CPU交给另一个进程。这种类型的调度是操作系统功能的基本部分。几乎所有计算机资源在使用之前都会进行调度。当然，CPU是主要的计算机资源之一。因此，它的调度对操作系统设计至关重要。 CPU-I/O Burst Cycle 进程的执行包括CPU执行和I/O等待的循环。进程在这两种状态之间交替。进程执行始于一个CPU脉冲。接着是一个I/O脉冲，然后是另一个CPU脉冲，再接着是另一个I/O脉冲，如此往复。最终，最后一个CPU脉冲以系统请求终止执行而结束。 CPU脉冲的持续时间已经得到广泛测量。尽管它们在进程之间和计算机之间变化很大，但它们倾向于具有类似于下图所示的频率曲线。该曲线通常被描述为指数或超指数，其中有大量短的CPU脉冲和少量长的CPU脉冲。 I/O密集型程序通常有许多短的CPU脉冲。而CPU密集型程序可能有一些长的CPU脉冲。这种分布在选择适当的CPU调度算法时可能很重要。 CPU调度器 ​ 每当CPU变为空闲状态，操作系统必须选择就绪队列中的一个进程来执行。选择过程由短期调度器，或称为CPU调度器，执行。调度器从内存中准备执行的进程中选择一个，并分配CPU给该进程。 ​ 需要注意的是，就绪队列不一定是先进先出（FIFO）队列。当我们考虑各种调度算法时，就绪队列可以被实现为FIFO队列、优先级队列、树状结构，或者仅仅是一个无序的链表。就绪队列中的所有进程都排队等待在CPU上运行的机会。队列中的记录通常是进程的PCB。 抢占式调度 CPU调度决策可能发生在以下四种情况下： 当一个进程从运行状态切换到等待状态时（例如，由于I/O请求或对子进程终止的wait()调用导致） 当一个进程从运行状态切换到就绪状态时（例如，发生中断时） 当一个进程从等待状态切换到就绪状态时（例如，I/O完成时） 当一个进程终止时 ​ 对于情况1和4，从调度的角度来看没有选择。必须选择一个新的进程（如果在就绪队列中存在的话）来执行。然而，对于情况2和3，有选择的余地。 当调度仅在情况1和4下发生时，我们称调度方案为非抢占式。否则，它是抢占式的。在非抢占式调度下，一旦CPU被分配给一个进程，该进程将保持CPU，直到它通过终止或切换到等待状态释放CPU。Windows 95引入了抢占式调度，之后的所有Windows操作系统版本都使用了抢占式调度。Macintosh的Mac OS X操作系统也使用抢占式调度；Macintosh操作系统的早期版本依赖于合作式调度。合作式调度是某些硬件平台上唯一可用的方法，因为它不需要抢占式调度所需的特殊硬件（例如计时器）。 不幸的是，抢占式调度可能导致多个进程共享数据时出现竞态条件。考虑两个共享数据的进程的情况。在一个进程正在更新数据时，它被抢占以便第二个进程可以运行。然后，第二个进程试图读取数据，这时数据处于不一致的状态。这 抢占还影响操作系统内核的设计。在处理系统调用时，内核可能正忙于代表一个进程进行活动。这些活动可能涉及更改重要的内核数据（例如I/O队列）。如果进程在这些更改的过程中被抢占，并且内核（或设备驱动程序）需要读取或修改相同的结构，会发生混乱。包括大多数UNIX版本在内的某些操作系统通过等待系统调用完成或I/O块发生之前进行上下文切换来处理这个问题。这种方案确保内核结构简单，因为内核不会在内核数据结构处于不一致状态时抢占一个进程。不幸的是，这种内核执行模型对支持必须在给定时间范围内完成执行的实时计算的情况不利。 ​ 由于中断可以在任何时候发生（根据定义），并且因为内核不能总是忽略它们，受中断影响的代码段必须在同时使用时受到保护。操作系统需要几乎在任何时候都能接受中断。否则，可能会丢失输入或覆盖输出。为了确保这些代码段不会被多个进程同时访问，它们在进入时禁用中断，而在退出时重新启用中断。需要注意的是，禁用中断的代码段并不经常发生，通常包含很少的指令。 Dispatcher 参与CPU调度功能的另一个组件是调度程序（dispatcher）。调度程序是一个模块，它将CPU的控制权交给短期调度器选择的进程。这个功能涉及以下内容： • 切换上下文 • 切换到用户模式 • 跳转到用户程序中重新启动该程序的正确位置 调度程序应尽可能快，因为它在每次进程切换时被调用。调度程序停止一个进程并启动另一个进程运行所需的时间被称为调度延迟。 调度标准 不同的CPU调度算法具有不同的特性，选择特定算法可能会偏向某一类进程。在选择在特定情况下使用哪种算法时，我们必须考虑各种算法的特性。 有许多用于比较CPU调度算法的标准。用于比较的特性在判断哪个算法最好时可能会有很大的差异。这些标准包括： CPU利用率CPU utilization。我们希望保持CPU尽可能繁忙。在概念上，CPU利用率可以从0到100％。在实际系统中，它应该在40％（对于轻载系统）到90％（对于重载系统）之间。 吞吐量Throughput 。如果CPU正在执行进程，那么工作正在进行。工作的一个度量是每个时间单位完成的进程数量，称为吞吐量。对于长时间进程，这个速率可能是每小时一个进程；对于短交易，它可能是每秒十个进程。 周转时间Turnaround time。从某个进程的角度来看，重要的标准是执行该进程需要多长时间。从提交进程到完成的时间间隔是周转时间。周转时间是在等待进入内存、在就绪队列中等待、在CPU上执行以及进行I/O的时间段的总和。 等待时间Waiting time。CPU调度算法不会影响进程执行或进行I/O的时间。它只影响进程在就绪队列中等待的时间。等待时间是在就绪队列中等待的时间段的总和。 响应时间Response time。在交互式系统中，周转时间可能不是最佳标准。通常，进程可以在相当早的时候产生一些输出，并且在将先前的结果输出给用户的同时可以继续计算新的结果。因此，另一种度量是从提交请求到产生第一个响应的时间。这个度量称为响应时间，是启动响应所需的时间，而不是输出响应所需的时间。周转时间通常受输出设备速度的限制。 调度算法 算法 方案 优劣势","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://blackforest1990.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"进程管理","slug":"进程管理","permalink":"https://blackforest1990.github.io/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"}]},{"title":"进程同步","slug":"进程同步","date":"2023-12-11T02:27:52.000Z","updated":"2023-12-29T06:50:54.577Z","comments":true,"path":"2023/12/11/进程同步/","link":"","permalink":"https://blackforest1990.github.io/2023/12/11/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/","excerpt":"","text":"合作进程是指可以影响或受其他在系统中执行的进程影响的进程。合作进程可以直接共享逻辑地址空间（即代码和数据），也可以通过文件或消息允许仅共享数据。前一种情况通过使用线程来实现。然而，并发访问共享数据可能导致数据不一致。在本文中，我们讨论确保共享逻辑地址空间的合作进程有序执行的各种机制，以维护数据一致性。 背景 我们将解释并发或并行执行如何导致涉及由多个进程共享的数据完整性的问题。现在我们回到有界缓冲区的问题上。我们最初的解决方案在缓冲区中最多允许 BUFFER SIZE - 1 个项同时存在。假设我们想修改算法来解决这个问题。一种可能性是添加一个整数变量 counter，初始化为 0。每次向缓冲区添加一个新项时，counter 增加，并且每次从缓冲区移除一个项时，counter 减少。生产者进程的代码可以修改如下： 12345678while (true) &#123; /* 在 next produced 中生成一个项 */ while (counter == BUFFER SIZE) ; /* 什么也不做 */ buffer[in] = next produced; in = (in + 1) % BUFFER SIZE; counter++;&#125; 消费者进程的代码可以修改如下： 12345678while (true) &#123; while (counter == 0) ; /* 什么也不做 */ next consumed = buffer[out]; out = (out + 1) % BUFFER SIZE; counter--; /* 在 next consumed 中消费一个项 */&#125; 尽管上述的生产者和消费者例程在单独执行时是正确的，但在并发执行时可能无法正常工作。举例说明，假设变量 counter 的值当前为 5，并且生产者和消费者进程同时执行语句 “counter++” 和 “counter–”。在执行这两个语句之后，变量 counter 的值可能是 4、5 或 6！然而，唯一的正确结果是 counter == 5，只有在生产者和消费者分别执行时才能正确生成。 我们可以通过以下方式说明 counter 的值可能不正确。注意语句 “counter++” 在机器语言中可以如下实现： 123register1 = counterregister1 = register1 + 1counter = register1 同样，语句 “counter–” 可以如下实现： 123register2 = counterregister2 = register2 - 1counter = register2 即使 register1 和 register2 可能是相同的物理寄存器（比如累加器），该寄存器的内容将由中断处理程序保存和恢复。“counter++” 和 “counter–” 的并发执行相当于以某种任意顺序交错执行先前介绍的低级语句的顺序执行（但在每个高级语句内部的顺序被保留）。这样的交错执行可能是以下的其中一种： T0: producer execute register1 = counter {register1 = 5} T1: producer execute register1 = register1 + 1 {register1 = 6} T2: consumer execute register2 = counter {register2 = 5} T3: consumer execute register2 = register2 − 1 {register2 = 4} T4: producer execute counter = register1 {counter = 6} T5: consumer execute counter = register2 {counter = 4} 我们将达到这种不正确的状态是因为我们允许两个进程同时操作变量 counter。这种情况，其中多个进程同时访问和操作相同的数据，并且执行的结果取决于访问发生的具体顺序，被称为竞态条件。为了防范上述竞态条件，我们需要确保一次只有一个进程能够操作变量 counter。为了做出这样的保证，我们需要以某种方式同步这些进程。 临界区问题 首先讨论所谓的临界区问题。考虑一个由 n 个进程 {P0，P1，…，Pn−1} 组成的系统。每个进程都有一段代码，称为临界区，其中进程可能正在更改共享变量、更新表、写文件等。系统的重要特性是，当一个进程正在执行其临界区时，不允许其他进程在其临界区中执行。也就是说，没有两个进程可以同时在其临界区中执行。临界区问题是设计一个协议，进程可以使用该协议进行合作。每个进程必须请求进入其临界区的权限。执行此请求的代码部分是入口部分。临界区可能后面跟着一个退出部分。其余代码是剩余部分。 解决临界区问题的解决方案必须满足以下三个要求： 互斥性。如果进程 Pi 正在执行其临界区，则其他进程不能在其临界区中执行。 进展性。如果没有进程在其临界区中执行，并且有些进程希望进入其临界区，则只有那些不在其剩余部分中执行的进程可以参与决定下一个将进入其临界区的进程，而且此选择不能无限期地推迟。 有限等待。在进程发出请求进入其临界区后，以及在该请求被授予之前，允许其他进程进入其临界区的次数存在一个限制或界限。 我们假设每个进程以非零速度执行。然而，我们不能对 n 个进程的相对速度做任何假设。 在某一时刻，操作系统中可能有许多内核模式进程处于活动状态。因此，实现操作系统的内核代码可能存在几种可能的竞争条件。以维护系统中所有打开文件列表的内核数据结构为例。如果两个进程同时打开文件，对此列表的单独更新可能导致竞争条件。其他可能存在竞争条件的内核数据结构包括用于维护内存分配的结构、用于维护进程列表的结构以及用于中断处理的结构。内核开发人员需要确保操作系统没有这样的竞争条件。 在操作系统中处理临界区的两种一般方法是：抢占式内核和非抢占式内核。抢占式内核允许在内核模式下运行的进程在运行时被抢占。非抢占式内核不允许在内核模式下运行的进程被抢占；内核模式进程将一直运行，直到退出内核模式、阻塞或自愿放弃对CPU的控制。 显然，非抢占式内核基本上不会在内核数据结构上产生竞争条件，因为一次只有一个进程在内核中活动。我们不能说抢占式内核也是如此，因此必须仔细设计以确保共享内核数据不受竞争条件的影响。对于多处理器架构来说，抢占式内核尤其难以设计，因为在这些环境中，两个内核模式进程可能同时在不同的处理器上运行。 那么，为什么有人会选择抢占式内核呢？抢占式内核可能更具响应性，因为在内核模式下运行的进程在放弃处理器给等待中的进程之前有较小的风险在任意长的时间内运行。当然，通过设计不会以这种方式行为的内核代码，也可以将此风险最小化。此外，抢占式内核更适用于实时编程，因为它允许实时进程抢占当前在内核中运行的进程。 彼得森解法 由于现代计算机架构执行基本的机器语言指令（如加载和存储）的方式，Peterson解法在这些架构上不能保证正确运行。然而，我们还是介绍这个解决方案，因为它提供了解决关键区问题的良好算法描述，并展示了设计满足互斥、进展和有限等待要求的软件所涉及的一些复杂性。 Peterson解法仅适用于两个进程，它们在它们的关键区和剩余区之间交替执行。这两个进程分别编号为P0和P1。为了方便起见，在表示Pi时，我们使用Pj来表示另一个进程，即j = 1−i。 Peterson解法要求这两个进程共享两个数据项： 12int turn;boolean flag[2]; 变量turn表示轮到谁进入关键区。也就是说，如果turn == i，则允许进程Pi在其关键区执行。数组flag用于指示一个进程是否准备好进入其关键区。例如，如果flag[i]为true，则表示Pi准备好进入其关键区。 为了进入关键区，进程Pi首先将flag[i]设置为true，然后将turn设置为j的值，从而断言如果另一个进程希望进入关键区，它可以这样做。如果两个进程同时尝试进入，turn将大致同时设置为i和j。只有一个赋值将持续；另一个将发生但将立即被覆盖。turn的最终值确定了这两个进程中哪一个被允许首先进入其关键区。 需要满足以下几个前提条件： ● 进程必须能够独立地执行，并且它们之间可以相互干扰。 ● 进程必须可以共享一些公共变量。 ● 进程之间的速度可以不同，但不能有任何假设。 这个算法的一个限制是它只适用于两个进程之间的情况。在有多个进程需要互斥访问共享资源的情况下，需要采用其他算法或技术来解决。 同步硬件 我们刚刚描述了解决临界区问题的一种基于软件的方法。然而，正如前面提到的，像Peterson这样的基于软件的解决方案在现代计算机体系结构上不能保证正常工作。在接下来的讨论中，我们将探讨解决临界区问题的几种更多方法，涉及从硬件到软件的 API 技术，这些技术对内核开发人员和应用程序员都是可用的。所有这些解决方案都基于锁的概念——即通过使用锁来保护关键区域。正如我们将看到的，这些锁的设计可能非常复杂。 我们首先介绍一些简单的硬件指令，这些指令在许多系统上都可用，并展示它们如何有效地解决临界区问题。硬件特性可以使任何编程任务变得更加容易，并提高系统效率。如果我们能够在修改共享变量时阻止中断，那么在单处理器环境中就可以简单地解决临界区问题。这样，我们可以确保当前的指令序列将被允许按顺序执行而不会被抢占。不会运行其他指令，因此不会对共享变量进行意外的修改。这通常是非抢占内核采用的方法。不幸的是，在多处理器环境中，禁用中断可能会很耗时，因为消息会传递到所有处理器。这种消息传递延迟了进入每个关键区的时间，降低了系统效率。还要考虑系统时钟如果通过中断保持更新的影响。 因此，许多现代计算机系统提供了特殊的硬件指令，允许我们测试和修改一个字的内容，或原子地交换两个字的内容——即作为一个不可中断的单元。我们可以使用这些特殊指令以相对简单的方式解决临界区问题。我们通过描述测试与设置（test and set()）和比较与交换（compare and swap()）指令来抽象这些指令背后的主要概念，而不是讨论某个具体机器的某个具体指令。 互斥锁 基于硬件的解决方案对于应用程序员来说通常很复杂且难以访问。相反，操作系统设计者构建软件工具来解决临界区问题。其中最简单的工具之一是互斥锁（mutex lock）。实际上，“mutex”一词是“mutual exclusion”的缩写。我们使用互斥锁来保护临界区，从而防止竞态条件。也就是说，进程必须在进入临界区之前获取锁；当退出临界区时释放锁。acquire()函数用于获取锁，release()函数用于释放锁。 互斥锁有一个布尔变量available，其值指示锁是否可用。如果锁可用，对acquire()的调用成功，并且然后将锁视为不可用。试图获取不可用锁的进程将被阻塞，直到锁被释放。 acquire()的定义如下： 12345acquire() &#123; while (!available) ; /* 忙等待 */ available = false;&#125; release()的定义如下： 123release() &#123; available = true;&#125; 对acquire()或release()的调用必须以原子方式执行。主要缺点是它需要忙等待。当一个进程处于其临界区时，任何尝试进入其临界区的其他进程必须在调用acquire()时不断循环。事实上，这种类型的互斥锁也称为自旋锁，因为进程在等待锁变得可用时会“旋转”。这种持续循环在真正的多编程系统中显然是个问题，其中一个单独的 CPU 在许多进程之间共享。忙等待浪费了 CPU 周期，其他一些进程可能能够有效地使用。 然而，自旋锁也有一个优点，即在进程必须等待锁时不需要进行上下文切换，而上下文切换可能需要很长时间。因此，当预计锁将被持有的时间很短时，自旋锁是有用的。它们通常用于多处理器系统，其中一个线程可以在一个处理器上“旋转”，而另一个线程在另一个处理器上执行其临界区。 信号量 互斥锁，正如我们之前提到的，通常被认为是最简单的同步工具之一。我们将研究一个更健壮的工具，它可以表现得类似于互斥锁，但也可以提供更复杂的方式来使进程同步它们的活动。信号量（Semaphore）S 是一个整数变量，除了初始化之外，只能通过两个标准的原子操作进行访问：wait() 和 signal()。wait() 操作最初被称为 P；signal() 最初被称为 V。wait() 的定义如下： 1234wait(S) &#123; while (S &lt;= 0) S--;; // 忙等待&#125; signal() 的定义如下： 123signal(S) &#123; S++;&#125; 在 wait() 和 signal() 操作中对信号量的整数值的所有修改都必须是不可分割的。也就是说，当一个进程修改信号量值时，没有其他进程可以同时修改相同的信号量值。此外，在 wait(S) 的情况下，对 S 的整数值的测试（S ≤ 0）以及可能的修改（S–）必须在没有中断的情况下执行。 信号量的使用 操作系统通常区分计数信号量和二进制信号量。计数信号量的值可以在无限的域内变化。二进制信号量的值只能在0和1之间变化。因此，二进制信号量的行为类似于互斥锁。实际上，在不提供互斥锁的系统上，可以使用二进制信号量来提供互斥。 计数信号量可以用于控制对由有限数量实例组成的特定资源的访问。信号量被初始化为可用资源的数量。每个想要使用资源的进程都执行对信号量的 wait() 操作（从而减少计数）。当进程释放资源时，它执行 signal() 操作（增加计数）。当信号量的计数变为0时，所有资源都被使用。在此之后，想要使用资源的进程将被阻塞，直到计数变得大于0。 我们还可以使用信号量来解决各种同步问题。例如，考虑两个并发运行的进程：P1 具有语句 S1，P2 具有语句 S2。假设我们要求只有在 S1 完成后才能执行 S2。我们可以通过让 P1 和 P2 共享一个初始值为0的信号量 synch 来轻松实现这个方案。在进程 P1 中，我们插入以下语句： 12S1;signal(synch); 在进程 P2 中，我们插入以下语句： 12wait(synch);S2; 因为 synch 被初始化为0，所以只有在 P1 调用 signal(synch) 之后（也就是在语句 S1 执行后），P2 才会执行 S2。 信号量的实现 为了克服忙等待的需要，我们可以修改 wait() 和 signal() 操作的定义如下：当一个进程执行 wait() 操作并发现信号量值不是正数时，它必须等待。然而，与其忙等待，该进程可以自我阻塞。阻塞操作将一个进程放入与信号量关联的等待队列中，并将进程的状态切换到等待状态。然后控制被传递给 CPU 调度程序，该程序选择另一个进程执行。 一个被阻塞在等待信号量 S 上的进程应该在另一个进程执行 signal() 操作时重新启动。进程通过 wakeup() 操作重新启动，该操作将进程从等待状态更改为就绪状态。然后，将进程放入就绪队列中。（根据 CPU 调度算法，可能或可能不会从运行中的进程切换到新的就绪进程。） 为了在这个定义下实现信号量，我们将信号量定义为： 1234typedef struct &#123; int value; struct process *list;&#125; semaphore; 每个信号量都有一个整数值和一个进程列表。当一个进程必须等待信号量时，它被添加到进程列表中。signal() 操作从等待进程列表中删除一个进程并唤醒该进程。 现在，wait() 信号量操作可以定义为： 1234567wait(semaphore *S) &#123; S-&gt;value--; if (S-&gt;value &lt; 0) &#123; add this process to S-&gt;list; block(); &#125;&#125; signal() 信号量操作可以定义为： 1234567signal(semaphore *S) &#123; S-&gt;value++; if (S-&gt;value &lt;= 0) &#123; remove a process P from S-&gt;list; wakeup(P); &#125;&#125; 阻塞操作挂起调用它的进程。唤醒操作恢复一个被阻塞的进程 P。这两个操作由操作系统作为基本系统调用提供。请注意，在这个实现中，信号量的值可能是负数，而在具有忙等待的信号量的经典定义下，信号量的值永远不会是负数。如果信号量的值是负数，那么它的大小是等待该信号量的进程数。这是由于在 wait() 操作的实现中切换了减法和测试的顺序。 等待进程列表可以通过每个进程控制块（PCB）中的链接字段轻松实现。每个信号量包含一个整数值和指向 PCB 列表的指针。为了确保有界等待，可以使用 FIFO 队列的方式添加和删除进程，其中信号量包含队列的头指针和尾指针。然而，通常情况下，列表可以使用任何排队策略。信号量列表的正确使用不依赖于信号量列表的特定排队策略。 信号量操作必须以原子方式执行是至关重要的。我们必须确保没有两个进程可以同时在同一个信号量上执行 wait() 和 signal() 操作。这是一个关键部分问题；在单处理器环境中，我们可以通过在执行 wait() 和 signal() 操作时简单地禁用中断来解决它。这个方案在单处理器环境中有效，因为一旦中断被禁用，不同进程的指令就不能交错执行。只有当前运行的进程执行，直到重新启用中断，调度程序才能重新获得控制。 在多处理器环境中，必须在每个处理器上禁用中断。否则，来自不同处理器的进程（在不同处理器上运行）的指令可能以任意的方式交错。在每个处理器上禁用中断可能是一项困难的任务，并且可能严重降低性能。因此，SMP 系统必须提供替代的锁定技术——例如 compare and swap() 或自旋锁（spinlocks）——以确保 wait() 和 signal() 的原子执行。 重要的是要承认，通过这种对 wait() 和 signal() 操作的定义，我们并没有完全消除忙等待。相反，我们将忙等待从进程应用程序的入口部分移到了关键部分。此外，我们将忙等待限制在 wait() 和 signal() 操作的关键部分，而这些部分是短暂的（如果编写正确，它们应该不超过大约十条指令）。 死锁和饥饿 使用等待队列实现的信号量可能导致两个或更多进程无限期等待仅由等待进程之一引起的事件。所涉及的事件是执行 signal() 操作。当达到这种状态时，这些进程被称为死锁。为了说明这一点，考虑一个由两个进程 P0 和 P1 组成的系统，每个进程都访问两个信号量 S 和 Q，它们的初始值均为 1： 12345678P0 P1wait(S); wait(Q);wait(Q); wait(S);. .. .. .signal(S); signal(Q);signal(Q); signal(S); 假设 P0 执行 wait(S)，然后 P1 执行 wait(Q)。当 P0 执行 wait(Q) 时，它必须等待 P1 执行 signal(Q)。同样，当 P1 执行 wait(S) 时，它必须等待 P0 执行 signal(S)。由于这些 signal() 操作无法执行，P0 和 P1 陷入了死锁。 当一个进程集合中的每个进程都在等待只能由该集合中的另一个进程引起的事件时，我们说该进程集合处于死锁状态。这里我们主要关注的事件是资源的获取和释放。与死锁相关的另一个问题是无限阻塞或饥饿，即进程在信号量中无限期等待的情况。如果我们以后进先出（LIFO，last-in, first-out）的顺序从与信号量关联的列表中移除进程，那么可能会发生无限阻塞。 优先级反转 当一个更高优先级的进程需要读取或修改当前由一个低优先级进程（或一系列低优先级进程）访问的内核数据时，就会出现调度的挑战。由于内核数据通常受到锁的保护，更高优先级的进程将不得不等待低优先级进程完成对资源的使用。如果低优先级进程被抢占，让步给优先级更高的进程，情况就变得更加复杂。 例如，假设我们有三个进程L、M和H，它们的优先级按照 L &lt; M &lt; H 的顺序。假设进程H需要资源R，而该资源当前正在被进程L访问。通常情况下，进程H会等待L完成对资源R的使用。但是，现在假设进程M变为可运行状态，从而抢占了进程L。间接地，一个具有较低优先级的进程（进程M）影响了进程H等待L放弃资源R的时间。 这个问题被称为优先级反转。它只会在具有两个以上优先级的系统中发生，因此一种解决方案是只有两个优先级。然而，对于大多数通用操作系统来说，这是不够的。通常，这些系统通过实现优先级继承协议来解决这个问题。根据该协议，所有正在访问由更高优先级进程需要的资源的进程都会继承更高的优先级，直到它们完成对这些资源的使用。当它们完成后，它们的优先级将恢复到原始值。在上面的例子中，优先级继承协议将允许进程L暂时继承进程H的优先级，从而防止进程M抢占其执行。当进程L完成对资源R的使用后，它将放弃从H继承的优先级并恢复为其原始优先级。由于资源R现在可用，接下来运行的将是进程H，而不是M。 经典的同步问题 有界缓冲问题（Bounded-Buffer Problem） 在生产者-消费者模型中，有一个有界的缓冲区，生产者将数据放入缓冲区，而消费者从中取出数据。问题在于要保证在缓冲区满或空的情况下，生产者和消费者能够正确地进行同步，避免溢出或下溢。 在有界缓冲问题中，我们有N个缓冲区，每个缓冲区可以容纳一个项。 为了解决这个问题，我们需要以下信号量： mutex：用于保护对缓冲区的访问，防止多个进程同时访问。初始值为1，表示最初是可用的。 full：用于记录当前有多少个缓冲区已经被占用（即已经放入了项）。初始值为0。 empty：用于记录当前还有多少个缓冲区是空的（即可以放入项）。初始值为N，表示所有缓冲区都是空的。 这样，通过合理地使用这三个信号量，我们可以实现多个生产者和消费者正确、安全地访问缓冲区。 生产者进程结构： 123456789101112do &#123; . . . /* produce an item in next produced */ . . . wait(empty); wait(mutex); . . . /* add next produced to the buffer */ . . . signal(mutex); signal(full);&#125; while (true); 消费者进程结构： 123456789101112do &#123; wait(full); wait(mutex); . . . /* remove an item from buffer to next consumed */ . . . signal(mutex); signal(empty); . . . /* consume the item in next consumed */ . . .&#125; while (true); 读者-写者问题（Readers and Writers Problem） 假设一个数据库需要被多个并发进程共享。其中一些进程可能只想读取数据库，而其他一些可能想要更新数据库。我们通过将前者称为读者，将后者称为写者来区分这两种类型的进程。显然，如果两个读者同时访问共享数据，不会产生不良影响。然而，如果一个写者和另一个进程（无论是读者还是写者）同时访问数据库，可能会导致混乱。 为了确保这些困扰不会出现，我们要求写者在写入数据库时具有对共享数据库的独占访问权。这个同步问题被称为读者-写者问题。自从最初提出以来，它一直被用来测试几乎每个新的同步原语。读者-写者问题有几个变种，都涉及到优先级。最简单的一个，被称为第一个读者-写者问题，要求在写者已经获得使用共享对象的许可之前，不应使读者等待。换句话说，没有读者应该因为有写者在等待而等待其他读者完成。第二个读者-写者问题要求一旦写者准备好，就应该尽快执行其写操作。换句话说，如果一个写者正在等待访问对象，那么新的读者就不能开始读取。在第一种情况下，写者可能会饿死；在第二种情况下，读者可能会饿死。 在解决第一个读者-写者问题的方案中，读者进程共享以下数据结构： 123semaphore rw_mutex = 1;semaphore mutex = 1;int read_count = 0; 信号量 rw_mutex 和 mutex 被初始化为 1；read_count 被初始化为 0。rw_mutex 信号量对读者和写者进程都是共享的。mutex 信号量用于在更新变量 read_count 时确保互斥。变量 read_count 用于跟踪当前正在读取对象的进程数量。rw_mutex 信号量用作写者的互斥信号量。它还由第一个或最后一个进入或退出关键部分的读者使用。它不被在其他读者处于其关键部分时进入或退出的读者使用。 请注意，如果一个写者在关键部分中，有 n 个读者在等待，那么一个读者排队在 rw_mutex 上，而 n - 1 个读者排队在 mutex 上。还请注意，当一个写者执行 signal(rw_mutex) 时，我们可能会恢复等待的读者或一个等待的写者的执行。选择由调度程序做出。 12345678910111213141516171819202122232425writer:do &#123; wait(rw_mutex); . . . /* writing is performed */ . . . signal(rw_mutex);&#125; while (true);Reader:do &#123; wait(mutex); read count++; if (read_count == 1) wait(rw_mutex); signal(mutex); . . . /* reading is performed */ . . . wait(mutex); read_count--; if (read_count == 0) signal(rw_mutex); signal(mutex);&#125; while (true); 读者-写者问题及其解决方案已经推广为在某些系统上提供读者-写者锁。获取读者-写者锁需要指定锁的模式：读取或写入访问。当一个进程只想读取共享数据时，它以读取模式请求读者-写者锁。希望修改共享数据的进程必须以写入模式请求锁。多个进程可以同时以读取模式获取读者-写者锁，但只有一个进程可以以写入模式获取锁，因为写者需要独占访问权限。 读者-写者锁在以下情况下最为有用： 在应用程序中很容易确定哪些进程仅读取共享数据，哪些进程仅写入共享数据。 在具有比写者或互斥锁更多读者的应用程序中。这是因为读者-写者锁通常需要更多的开销来建立，比信号量或互斥锁多。允许多个读者同时进行提高了允许并发的能力，以弥补设置读者-写者锁的开销。 哲学家就餐问题（Dining-Philosophers Problem） 在这个问题中，有五位哲学家坐在圆桌前，每位哲学家之间有一根筷子，共有五根筷子。哲学家可以进行思考或就餐，但只有同时拿到左右两根筷子时才能吃饭。 数据结构: 一个装有米饭的碗（数据集） 五根筷子的信号量数组 chopstick[5]，初始化为1，表示每根筷子最初可用。 哲学家的行为规则如下： 当一个哲学家想要进餐时，他必须先拿起他左边的筷子，然后拿起他右边的筷子，才能开始进餐。 进餐完毕后，他会先放下右边的筷子，再放下左边的筷子，然后继续思考。 为了解决哲学家就餐问题，可以使用信号量来控制筷子的访问。当一个哲学家想要拿起筷子时，他会先等待两根筷子都可用，然后将它们标记为不可用，以防止其他哲学家同时取用同一根筷子。 这个问题的解决方案需要巧妙地使用信号量来保证哲学家们可以安全地就餐，同时避免死锁等问题。 12345678910111213semaphore chopstick[5];do &#123; wait(chopstick[i]); wait(chopstick[(i+1) % 5]); . . . /* eat for awhile */ . . . signal(chopstick[i]); signal(chopstick[(i+1) % 5]); . . . /* think for awhile */ . . .&#125; while (true); 同步案例 Linux 在 Linux 的 Version 2.6 之前，Linux 内核是非抢占式的，这意味着在内核模式下运行的进程即使有更高优先级的进程可运行也不能被抢占。然而，现在的 Linux 内核是完全抢占式的，因此当一个任务在内核中运行时可以被抢占。 Linux 提供了内核中的多种不同的同步机制。由于大多数计算机体系结构都提供了原子版本的简单数学操作的指令，因此在 Linux 内核中最简单的同步技术是原子整数，它使用不透明的数据类型 atomic_t 表示。正如其名称所示，使用原子整数的所有数学操作都是无中断的。以下代码演示了声明一个原子整数计数器并执行各种原子操作： 1234567atomic_t counter;int value;atomic_set(&amp;counter, 5); /* counter = 5 */atomic_add(10, &amp;counter); /* counter = counter + 10 */atomic_sub(4, &amp;counter); /* counter = counter - 4 */atomic_inc(&amp;counter); /* counter = counter + 1 */value = atomic_read(&amp;counter); /* value = 12 */ 原子整数在需要更新整数变量（如计数器）的情况下特别高效，因为原子操作不需要锁定机制的开销。然而，它们的使用仅限于这些场景。在存在多个变量可能导致竞态条件的情况下，必须使用更复杂的锁定工具。 在 Linux 中，提供了用于保护内核中关键部分的互斥锁。在这里，任务在进入关键部分之前必须调用 mutex_lock() 函数，而在退出关键部分后必须调用 mutex_unlock() 函数。如果互斥锁不可用，调用 mutex_lock() 的任务将进入睡眠状态，并在锁的所有者调用 mutex_unlock() 时被唤醒。 Linux 还为内核提供自旋锁和信号量（以及这两种锁的读写版本）用于内核中的锁定。在 SMP（对称多处理）机器上，基本的锁定机制是自旋锁，并且内核被设计成仅在短时间内保持自旋锁。在单处理器机器上，例如仅有一个处理核心的嵌入式系统，自旋锁不适用并被启用和禁用内核抢占来替代。换句话说，在单处理器系统上，内核禁用内核抢占而不是持有自旋锁，然后启用内核抢占而不是释放自旋锁。总结如下： Linux 采用了一种有趣的方法来禁用和启用内核抢占。它提供了两个简单的系统调用——preempt_disable() 和 preempt_enable()——用于禁用和启用内核抢占。但是，如果运行在内核中的任务持有锁，则内核是不可抢占的。为了强制执行这一规则，系统中的每个任务都有一个包含计数器 preempt_count 的线程信息结构，用于指示任务持有的锁的数量。当获取锁时，preempt_count 递增，释放锁时递减。如果当前在内核中运行的任务的 preempt_count 值大于 0，则不能安全地抢占内核，因为此任务当前持有锁。如果计数为 0，则内核可以安全地被中断（假设没有未完成的对 preempt_disable() 的调用）。自旋锁以及启用和禁用内核抢占仅在必须短时间内保持锁时在内核中使用。当需要长时间持有锁时，信号量或互斥锁适合使用。 Pthreads同步 尽管Solaris中使用的锁定机制对用户级线程和内核线程都可用，但基本上讨论的同步方法涉及内核内的同步。相比之下，Pthreads API可用于用户级别的程序员，不属于任何特定的内核。该API为线程同步提供了互斥锁、条件变量和读-写锁。互斥锁代表了Pthreads中使用的基本同步技术。互斥锁用于保护代码的临界部分，即线程在进入临界部分之前获取锁，在退出临界部分时释放锁。Pthreads使用pthread_mutex_t数据类型表示互斥锁。可以使用pthread_mutex_init()函数创建互斥锁。第一个参数是指向互斥锁的指针。通过将第二个参数设置为NULL，我们将互斥锁初始化为其默认属性。下面是一个示例： 1234#include &lt;pthread.h&gt;pthread_mutex_t mutex;/* 创建互斥锁 */pthread_mutex_init(&amp;mutex, NULL); 互斥锁通过pthread_mutex_lock()和pthread_mutex_unlock()函数获取和释放。如果在调用pthread_mutex_lock()时互斥锁不可用，调用线程将被阻塞，直到所有者调用pthread_mutex_unlock()。以下代码示例说明了使用互斥锁保护临界部分： 12345/* 获取互斥锁 */pthread_mutex_lock(&amp;mutex);/* 临界部分 *//* 释放互斥锁 */pthread_mutex_unlock(&amp;mutex); 所有互斥锁函数在正确操作时返回0；如果发生错误，则这些函数返回非零错误代码。 许多实现Pthreads的系统也提供信号量，尽管信号量不是Pthreads标准的一部分，而是属于POSIX SEM扩展。POSIX规定了两种类型的信号量 - 命名和未命名。两者之间的基本区别在于，命名信号量在文件系统中有一个实际的名称，并且可以被多个无关的进程共享。未命名信号量只能由属于同一进程的线程使用。在本节中，我们描述未命名信号量。 下面的代码示例演示了用于创建和初始化未命名信号量的sem_init()函数： 1234#include &lt;semaphore.h&gt;sem_t sem;/* 创建信号量并将其初始化为1 */sem_init(&amp;sem, 0, 1); sem_init()函数传递了三个参数： 信号量的指针 表示共享级别的标志 信号量的初始值 在此示例中，通过传递标志0，我们表示该信号量只能由创建信号量的进程的线程共享。非零值将允许其他进程也访问该信号量。此外，我们将信号量初始化为值1。 我们描述了经典的wait()和signal()信号量操作。Pthreads将这些操作命名为sem_wait()和sem_post()。以下代码示例说明了使用上述创建的信号量保护临界部分： 12345/* 获取信号量 */sem_wait(&amp;sem);/* 临界部分 *//* 释放信号量 */sem_post(&amp;sem); 与互斥锁一样，所有信号量函数在成功时返回0，在发生错误条件时返回非零值。 Pthreads API还有其他扩展，包括自旋锁，但重要的是要注意，并非所有扩展都被认为在一个实现中可以从另一个实现中移植。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://blackforest1990.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"进程管理","slug":"进程管理","permalink":"https://blackforest1990.github.io/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"}]},{"title":"线程","slug":"线程","date":"2023-12-05T07:40:18.000Z","updated":"2023-12-29T06:45:06.310Z","comments":true,"path":"2023/12/05/线程/","link":"","permalink":"https://blackforest1990.github.io/2023/12/05/%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"线程 几乎所有现代操作系统都提供了使进程能够包含多个控制线程的功能。我们引入了与多线程计算机系统相关的许多概念，包括对Pthreads和Java线程库的API的讨论。我们探讨了与多线程编程及其对操作系统设计的影响相关的许多问题。最后，我们探讨了Linux操作系统如何在内核级别支持线程。 概述 线程是CPU利用的基本单位；它包括线程ID、程序计数器、寄存器集和堆栈。它与属于同一进程的其他线程共享代码段、数据段和其他操作系统资源，如打开的文件和信号。传统（或重量级）进程具有单一的控制线程。如果一个进程具有多个控制线程，它可以同时执行多个任务。下图说明了传统的单线程进程和多线程进程之间的区别。 动机 一个应用程序通常被实现为一个独立的进程，拥有多个控制线程。例如，一个网络浏览器可能有一个线程显示图像或文本，一个线程从网络检索数据。一个文字处理软件可能有一个用于显示图形的线程，一个用于响应用户按键的线程，还有一个用于在后台执行拼写和语法检查的线程。应用程序还可以被设计为利用多核系统上的处理能力。这样的应用程序可以在多个计算核心上并行执行多个计算密集型任务。 在某些情况下，一个单一的应用程序可能需要执行多个类似的任务。例如，一个网络服务器接受客户端请求，请求可能包括网页、图像、声音等。一个繁忙的网络服务器可能同时有多个（可能是数千个）客户端访问它。如果网络服务器作为一个传统的单线程进程运行，它只能同时为一个客户端提供服务，客户端可能需要等待很长时间才能得到响应。 一种解决方法是让服务器作为一个单一进程接受请求。当服务器收到一个请求时，它创建一个单独的进程来处理该请求。事实上，在线程变得流行之前，这种进程创建的方法很常见。然而，进程创建是耗时且资源密集的。如果新进程将执行与现有进程相同的任务，为什么要承担这么大的开销呢？通常更有效的方法是使用一个包含多个线程的进程。如果网络服务器进程是多线程的，服务器将创建一个单独的线程来监听客户端请求。当请求到达时，服务器不是创建另一个进程，而是创建一个新的线程来处理该请求，并继续监听其他请求。 线程还在远程过程调用（RPC）系统中发挥着重要作用。通常，RPC服务器是多线程的。当服务器接收到一条消息时，它使用一个单独的线程来处理该消息。这使服务器能够同时处理多个并发请求。 最后，大多数操作系统内核现在也是多线程的。在内核中运行多个线程，每个线程执行特定的任务，如设备管理、内存管理或中断处理。例如，Solaris内核中有一组专门用于处理中断的线程；Linux使用一个内核线程来管理系统中的空闲内存量。 优点 响应性： 将交互式应用程序多线程化可能使程序在其部分被阻塞或执行长时间操作时继续运行，从而提高对用户的响应性。这一特性在设计用户界面时特别有用。例如，考虑当用户点击导致执行耗时操作的按钮时会发生什么情况。单线程应用程序在操作完成之前对用户不响应。相比之下，如果耗时操作在单独的线程中执行，应用程序将保持对用户的响应。 资源共享： 进程只能通过共享内存和消息传递等技术来共享资源。这些技术必须由程序员明确安排。然而，线程默认共享它们所属进程的内存和资源。共享代码和数据的好处是允许应用程序在同一地址空间内具有多个不同的活动线程。 经济性： 为进程创建分配内存和资源的成本很高。由于线程共享它们所属进程的资源，创建和切换线程更经济。在经验上评估开销的差异可能很困难，但总体上创建和管理进程比线程耗时得多。例如，在Solaris中，创建一个进程约比创建一个线程慢30倍，而上下文切换则慢5倍。 可伸缩性： 在多处理器架构中，多线程的好处可能更大，因为线程可以并行在不同的处理核心上运行。单线程的进程只能在一个处理器上运行，而不管有多少可用。 多核编程 在计算机设计的早期阶段，为了提高计算性能，单CPU系统逐渐演变成多CPU系统。在系统设计的更近期的趋势是将多个计算核心集成到一个芯片上。每个核心对操作系统来说都表现为一个独立的处理器。无论这些核心是跨CPU芯片还是在CPU芯片内部，我们称这些系统为多核或多处理器系统。 多线程编程为更有效地利用这些多个计算核心和提高并发性提供了一种机制。考虑一个具有四个线程的应用程序。在一个具有单个计算核心的系统上，并发仅意味着线程的执行将随时间交错进行，因为处理核心一次只能执行一个线程。然而，在具有多个核心的系统中，并发意味着线程可以并行运行，因为系统可以为每个核心分配一个单独的线程。 在这个讨论中，请注意并行性和并发性之间的区别。如果系统能够同时执行多个任务，则系统是并行的。相反，一个并发的系统通过允许所有任务取得进展来支持多个任务。因此，有并发而没有并行是可能的。在SMP和多核架构出现之前，大多数计算机系统只有一个处理器。CPU调度器被设计为通过在系统中迅速切换进程，从而使每个进程取得进展，从而提供并行性的假象。这样的进程是同时运行的，但不是并行的。 随着系统从几十个线程增长到数千个线程，CPU设计者通过添加硬件来改善线程性能，从而提高了系统性能。现代的Intel CPU通常支持每个核心两个线程，而Oracle T4 CPU支持每个核心八个线程。这种支持意味着可以将多个线程加载到核心中进行快速切换。多核计算机毫无疑问将继续增加核心数和硬件线程支持。 阿姆达尔定律是一个公式，用于确定将额外的计算核心添加到既有串行（非并行）组件又有并行组件的应用程序中可能获得的性能增益。如果S是在具有N个处理核心的系统上必须串行执行的应用程序的部分，该公式如下所示： $$ speedup ≤ 1/(S+(1-S)/N) $$ 例如，假设我们有一个应用程序，其中75%是并行的，25%是串行的。如果我们在一个具有两个处理核心的系统上运行此应用程序，我们可以获得1.6倍的加速。如果我们添加两个额外的核心（总共四个），加速比为2.28倍。 随着N趋近于无穷大，加速比趋近于1/S。例如，如果应用程序的40%是串行执行的，最大加速比为2.5倍，无论我们添加多少个处理核心。这是阿姆达尔定律的基本原则：应用程序的串行部分可以对通过添加额外计算核心获得的性能增益产生不成比例的影响。 有人认为阿姆达尔定律未考虑当代多核系统设计中使用的硬件性能增强因素。这些观点表明，随着处理核心数量在现代计算机系统上继续增加，阿姆达尔定律可能不再适用。 编程挑战 多核系统的趋势继续给系统设计师和应用程序员带来了更大的压力，要更好地利用多个计算核心。操作系统的设计者必须编写使用多个处理核心的调度算法，以实现并行执行。对于应用程序员来说，挑战在于修改现有程序以及设计新的支持多线程的程序。 总的来说，在为多核系统编程时有五个方面的挑战： 识别任务： 这涉及检查应用程序，找到可以分为独立并发任务的领域。理想情况下，任务是相互独立的，因此可以在各个核心上并行运行。 平衡： 在识别可以并行运行的任务的同时，程序员还必须确保这些任务执行相等价值的相等工作。在某些情况下，某个任务对整个过程的贡献可能不如其他任务大。为了运行该任务，使用一个单独的执行核心可能不值得成本。 数据分割： 正如应用程序被划分为独立任务一样，任务访问和操作的数据必须分割以在不同的核心上运行。 数据依赖性： 必须检查任务访问的数据，以了解两个或更多任务之间的依赖关系。当一个任务依赖于另一个任务的数据时，程序员必须确保任务的执行是同步的，以适应数据依赖性。 测试和调试： 当一个程序在多个核心上并行运行时，可能有许多不同的执行路径。测试和调试这样的并发程序比测试和调试单线程应用程序更加困难。 并行性的类型 总的来说，有两种类型的并行性：数据并行性和任务并行性。数据并行性侧重于将相同数据的子集分布到多个计算核心上，并在每个核心上执行相同的操作。例如，考虑对大小为N的数组的内容求和。在单核系统上，一个线程将简单地对元素[0] . . . [N − 1]进行求和。然而，在双核系统上，运行在核心0上的线程A可以对元素[0] . . . [N/2 − 1]进行求和，同时在核心1上运行的线程B可以对元素[N/2] . . . [N − 1]进行求和。这两个线程将在分别的计算核心上并行运行。 任务并行性涉及在多个计算核心上分发任务（线程），而不是数据。每个线程执行唯一的操作。不同的线程可以操作相同的数据，也可以操作不同的数据。再次考虑上面的例子。与那种情况相反，任务并行性的一个例子可能涉及两个线程，每个线程在元素数组上执行唯一的统计操作。这两个线程再次在分别的计算核心上并行运行，但每个线程执行的是唯一的操作。 因此，基本上，数据并行性涉及在多个核心上分布数据，任务并行性涉及在多个核心上分布任务。然而，在实践中，很少有应用程序严格遵循数据或任务并行性。在大多数情况下，应用程序使用这两种策略的混合形式。 多线程模型 到目前为止，我们讨论的线程是在一个通用的范围内。然而，线程的支持可以在用户级别提供，用于用户线程，也可以由内核提供，用于内核线程。用户线程在内核之上得到支持，并且在没有内核支持的情况下进行管理，而内核线程由操作系统直接支持和管理。几乎所有当代操作系统，包括Windows、Linux、Mac OS X和Solaris，都支持内核线程。最终，用户线程和内核线程之间必须建立某种关系。我们将讨论建立这种关系的三种常见方式：多对一模型、一对一模型和多对多模型。 多对一模型 将多个用户级线程映射到一个内核线程。线程管理由用户空间中的线程库完成，因此它是高效的。然而，如果一个线程进行了阻塞系统调用，整个进程将被阻塞。而且，由于一次只能有一个线程访问内核，多个线程无法在多核系统上并行运行。绿色线程（Solaris系统上提供的线程库，在早期Java版本中采用了这种模型）使用了多对一模型。然而，由于无法充分利用多个处理核心，很少有系统继续使用这种模型。 一对一模型 将每个用户线程映射到一个内核线程。相较于多对一模型，它提供了更多的并发性，因为当一个线程进行阻塞系统调用时，允许另一个线程运行。它还允许多个线程在多处理器上并行运行。这个模型唯一的缺点是创建一个用户线程需要创建相应的内核线程。由于创建内核线程的开销可能会影响应用程序的性能，因此该模型的大多数实现会限制系统支持的线程数量。Linux以及Windows操作系统家族实现了一对一模型。 多对多模型 多对多模型将许多用户级线程复用到较小或同等数量的内核线程上。内核线程的数量可能特定于特定应用程序或特定机器（在多处理器上，与在单处理器上相比，一个应用程序可能会被分配更多的内核线程）。开发者可以创建任意数量的用户线程，相应的内核线程可以在多处理器上并行运行。此外，当一个线程执行阻塞系统调用时，内核可以调度另一个线程来执行。 多对多模型的一种变体仍然将许多用户级线程复用到较小或等于数量的内核线程上，但还允许将用户级线程绑定到内核线程上。这种变体有时被称为两级模型。Solaris操作系统在Solaris 9之前的版本中支持了两级模型。然而，从Solaris 9开始，该系统采用了一对一模型。 线程库 线程库为程序员提供了一个用于创建和管理线程的API。实现线程库有两种主要方法。第一种方法是在用户空间完全提供一个没有内核支持的库。库的所有代码和数据结构都存在于用户空间。这意味着调用库中的函数会导致用户空间中的本地函数调用，而不是系统调用。第二种方法是实现一个由操作系统直接支持的内核级库。在这种情况下，库的代码和数据结构存在于内核空间。调用库的API中的函数通常会导致对内核的系统调用。 今天有三个主要的线程库在使用中：POSIX Pthreads、Windows和Java。Pthreads是POSIX标准的线程扩展，可以提供作为用户级或内核级库。Windows线程库是一个在Windows系统上可用的内核级库。Java线程API允许在Java程序中直接创建和管理线程。然而，由于在大多数情况下JVM在主机操作系统之上运行，Java线程API通常是使用主机系统上可用的线程库实现的。这意味着在Windows系统上，Java线程通常是使用Windows API实现的；UNIX和Linux系统通常使用Pthreads。 对于POSIX和Windows线程，任何在函数外部声明的全局数据（即在任何函数外部声明的数据）都将在属于同一进程的所有线程之间共享。因为Java没有全局数据的概念，对共享数据的访问必须在线程之间明确安排。在函数内部声明的数据通常存储在堆栈上。由于每个线程都有自己的堆栈，每个线程都有自己的本地数据副本。 两种通用线程策略： 异步线程：一旦父线程创建了一个子线程，父线程就会恢复其执行，使得父线程和子线程同时执行。每个线程独立于其他每个线程运行，父线程无需知道其子线程何时终止。由于线程是独立的，通常在线程之间很少共享数据。 同步线程：发生在父线程创建一个或多个子线程，然后必须等待所有子线程终止才能继续执行的情况下，即所谓的fork-join策略。在这里，由父线程创建的线程并行执行工作，但是父线程在这项工作完成之前不能继续。一旦每个线程完成了它的工作，它就会终止并与其父线程合并。只有在所有子线程都合并后，父线程才能继续执行。通常，同步线程涉及大量线程之间的数据共享。 Pthreads Pthreads指的是POSIX标准（IEEE 1003.1c），定义了线程创建和同步的API。这是线程行为的规范，而不是具体的实现。操作系统设计者可以以任何他们希望的方式实现这个规范。许多系统实现了Pthreads规范；大多数是UNIX类型的系统，包括Linux、Mac OS X和Solaris。 下面显示的C程序演示了用于构建多线程程序的基本Pthreads API，该程序在单独的线程中计算非负整数的求和。当此程序开始运行时，一个控制线程从main()开始。在一些初始化之后，main()创建了一个第二个线程，该线程从runner()函数开始控制。两个线程共享全局数据sum。所有Pthreads程序都必须包含pthread.h头文件。语句pthread_t tid声明了我们将要创建的线程的标识符。每个线程都有一组属性，包括堆栈大小和调度信息。pthread_attr_t attr声明表示线程的属性。我们在函数调用pthread_attr_init(&amp;attr) 中设置这些属性。因为我们没有明确设置任何属性，所以使用了提供的默认属性。使用pthread_create()函数调用创建一个单独的线程。除了传递线程标识符和线程的属性外，我们还传递新线程将开始执行的函数的名称，即runner()函数。最后，我们传递从命令行提供的整数参数，即argv[1]。此时，程序有两个线程：在main()中的父线程和在runner()函数中执行求和操作的子线程。该程序遵循先前描述的fork-join策略：创建求和线程后，父线程将通过调用pthread_join()函数等待其终止。求和线程将在调用pthread_exit()函数时终止。一旦求和线程返回，父线程将输出共享数据sum的值。 123456789101112131415161718192021222324252627282930313233#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;int sum; /* this data is shared by the thread(s) */void *runner(void *param); /* threads call this function */int main(int argc, char *argv[])&#123; pthread_t tid; /* the thread identifier */ pthread_attr_t attr; /* set of thread attributes */ if (argc != 2) &#123; fprintf(stderr,&quot;usage: a.out &lt;integer value&gt;\\n&quot;); return -1; &#125; if (atoi(argv[1]) &lt; 0) &#123; fprintf(stderr,&quot;%d must be &gt;= 0\\n&quot;,atoi(argv[1])); return -1; &#125; /* get the default attributes */ pthread_attr_init(&amp;attr); /* create the thread */ pthread_create(&amp;tid,&amp;attr,runner,argv[1]); /* wait for the thread to exit */ pthread_join(tid,NULL); printf(&quot;sum = %d\\n&quot;,sum);&#125;/* The thread will begin control in this function */void *runner(void *param)&#123; int i, upper = atoi(param); sum = 0; for (i = 1; i &lt;= upper; i++) sum += i; pthread_exit(0);&#125; 随着多核系统的普及，编写包含多个线程的程序变得越来越普遍。使用pthread_join()函数等待多个线程的简单方法是将操作放在一个简单的for循环中。 12345#define NUM_THREADS 10/* an array of threads to be joined upon */pthread_t workers[NUM_THREADS];for (int i = 0; i &lt; NUM_THREADS; i++) pthread_join(workers[i], NULL); Java Threads 线程是Java程序中程序执行的基本模型，Java语言及其API提供了丰富的功能集，用于创建和管理线程。所有Java程序至少包含一个控制线程，即使是一个只包含main()方法的简单Java程序也会作为一个单线程在JVM中运行。Java线程可用于任何提供JVM的系统，包括Windows、Linux和Mac OS X。Java线程API也适用于Android应用程序。 在Java程序中，有两种创建线程的技术。一种方法是创建一个新类，该类派生自Thread类，并覆盖其run()方法。另一种——更常用的——技术是定义一个实现了Runnable接口的类。Runnable接口定义如下： 123public interface Runnable &#123; public abstract void run();&#125; 当一个类实现了Runnable接口时，它必须定义一个run()方法。实现run()方法的代码将作为一个单独的线程运行。 下面展示了一个在Java中确定非负整数求和的多线程程序的Java版本。Summation类实现了Runnable接口。线程的创建通过创建Thread类的对象实例并将构造函数传递给一个Runnable对象来完成。 12345678910111213141516171819202122232425262728293031323334353637383940414243class Sum private int sum; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum = sum; &#125;&#125;class Summation implements Runnable&#123; private int upper; private Sum sumValue; public Summation(int upper, Sum sumValue) &#123; this.upper = upper; this.sumValue = sumValue; &#125; public void run() &#123; int sum = 0; for (int i = 0; i &lt;= upper; i++) sum += i; sumValue.setSum(sum); &#125;&#125;public class Driver&#123; public static void main(String[] args) &#123; if (args.length &gt; 0) &#123; if (Integer.parseInt(args[0]) &lt; 0) System.err.println(args[0] + &quot; must be &gt;= 0.&quot;); else &#123; Sum sumObject = new Sum(); int upper = Integer.parseInt(args[0]); Thread thrd = new Thread(new Summation(upper, sumObject)); thrd.start(); try &#123; thrd.join(); System.out.println(&quot;The sum of &quot;+upper+&quot; is &quot;+sumObject.getSum()); &#125; catch (InterruptedException ie) &#123;&#125; &#125; else System.err.println(&quot;Usage: Summation &lt;integer value&gt;&quot;); &#125;&#125; 创建Thread对象并不会直接创建新线程；相反，start()方法创建新线程。对新对象调用start()方法会执行两件事情： 在JVM中分配内存并初始化一个新线程。 调用run()方法，使线程有资格在JVM中运行。 当求和程序运行时，JVM会创建两个线程。第一个是父线程，在main()方法中开始执行。第二个线程在调用Thread对象上的start()方法时创建。这个子线程在Summation类的run()方法中开始执行。在输出求和值后，此线程在退出其run()方法时终止。 在线程之间共享数据在Windows和Pthreads中很容易，因为共享数据只需在全局声明即可。作为一种纯面向对象的语言，Java没有全局数据的概念。如果Java程序中的两个或多个线程需要共享数据，共享是通过将对共享对象的引用传递给适当的线程来进行的。通过适当的getSum()和setSum()方法引用此共享对象。Pthreads库中的父线程使用pthread_join()来等待求和线程完成后继续的方式。Java中的join()方法提供了类似的功能。 JVM和主机操作系统 JVM通常是在主机操作系统之上实现的。这种设置使得JVM能够隐藏底层操作系统的实现细节，并提供一个一致的、抽象的环境，使Java程序能够在支持JVM的任何平台上运行。JVM的规范并未说明如何将Java线程映射到底层操作系统，而是将该决策留给JVM的具体实现。例如，Windows XP操作系统使用一对一模型；因此，在这样的系统上运行的JVM的每个Java线程都映射到一个内核线程。在使用多对多模型的操作系统（例如Tru64 UNIX）上，Java线程根据多对多模型进行映射。Solaris最初使用了多对一模型来实现JVM（前面提到的绿色线程库）。JVM的后续版本则使用了多对多模型。从Solaris 9开始，Java线程使用了一对一模型进行映射。此外，Java线程库和主机操作系统上的线程库之间可能存在关系。例如，针对Windows家族操作系统的JVM实现可能在创建Java线程时使用Windows API；而Linux、Solaris和Mac OS X系统可能使用Pthreads API。 隐式线程 随着多核处理的不断增长，包含数百甚至数千个线程的应用程序即将出现。为了更好地支持多线程应用程序的设计，一种方法是将线程的创建和管理从应用程序开发人员转移到编译器和运行时库中。这种策略被称为隐式线程implicit threading，是当今的一个流行趋势。 Thread Pools 我们描述了一个多线程的Web服务器。在这种情况下，每当服务器收到一个请求，它就会创建一个单独的线程来处理该请求。虽然创建单独的线程肯定比创建单独的进程更好，但是多线程服务器仍然存在潜在的问题。第一个问题涉及创建线程所需的时间，以及一旦线程完成工作就会被丢弃。第二个问题更为棘手。如果我们允许所有并发请求在新线程中得到服务，那么系统中同时活动的线程数量就没有限制。无限制的线程可能会耗尽系统资源，如CPU时间或内存。解决这个问题的一种方法是使用线程池。 线程池背后的一般思想是在进程启动时创建一些线程，并将它们放入一个池中，等待工作。当服务器收到一个请求时，它唤醒池中的一个线程（如果有的话），并将请求传递给它进行处理。一旦线程完成服务，它就返回到池中等待更多的工作。如果池中没有可用的线程，服务器将等待直到有一个线程空闲。 线程池提供以下优势： 使用现有线程来处理请求比等待创建线程更快。 线程池限制了任一时刻存在的线程数量。这在不能支持大量并发线程的系统中尤为重要。 将要执行的任务与创建任务的机制分离，使我们能够使用不同的策略来运行任务。例如，可以安排任务在一段时间后执行或定期执行。 线程池的线程数量可以根据启发式算法设置，考虑因素包括系统中的CPU数量、物理内存量和预期的并发客户端请求数。更复杂的线程池架构可以根据使用模式动态调整池中的线程数量。这样的架构在系统负载较低时提供更小的池，从而消耗更少的内存。 OpenMP OpenMP是一组编译器指令以及用于在C、C++或FORTRAN中编写的程序的API，为共享内存环境中的并行编程提供支持。OpenMP将并行区域标识为可能并行运行的代码块。应用程序开发人员在其代码中在并行区域插入编译器指令，这些指令指示OpenMP运行时库在并行中执行该区域。以下是一个包含printf()语句的并行区域上方的编译器指令的C程序示例： 12345678910#include &lt;omp.h&gt;#include &lt;stdio.h&gt;int main(int argc, char *argv[]) &#123; /* 顺序代码 */ #pragma omp parallel printf(&quot;I am a parallel region.\\n&quot;); /* 顺序代码 */ return 0;&#125; 当OpenMP遇到指令#pragma omp parallel时，它会创建与系统中的处理核心数量相同的线程。因此，对于双核系统，将创建两个线程；对于四核系统，将创建四个线程；依此类推。然后，所有线程同时执行并行区域。每个线程退出并行区域时，它将被终止。 OpenMP提供了一些额外的指令来并行运行代码区域，包括并行化循环。例如，假设我们有两个大小为N的数组a和b。我们希望将它们的内容相加并将结果放入数组c。我们可以通过使用以下包含并行化for循环指令的代码段来并行运行此任务： 1234#pragma omp parallel forfor (i = 0; i &lt; N; i++) &#123; c[i] = a[i] + b[i];&#125; OpenMP将for循环中的工作分配给它根据指令#pragma omp parallel for创建的线程。 除了提供并行化指令外，OpenMP还允许开发人员在多个并行性级别之间进行选择。例如，他们可以手动设置线程数。它还允许开发人员确定数据是否在线程之间共享或对线程私有。OpenMP在Linux、Windows和Mac OS X系统的多个开源和商业编译器上都可用。 Grand Central Dispatch Grand Central Dispatch (GCD) 是苹果的 Mac OS X 和 iOS 操作系统的一项技术，它是 C 语言的扩展、一个 API 和一个运行时库的组合，允许应用程序开发人员标识要并行运行的代码段。与 OpenMP 类似，GCD 管理大部分线程细节。 GCD 标识了称为 blocks 的 C 和 C++ 语言扩展。一个 block 简单地是一个自包含的工作单元，由插入在一对大括号 { } 前面的插入符 ^ 指定。下面是一个 block 的简单示例： 1^&#123; printf(&quot;I am a block&quot;); &#125; GCD 通过将 block 放置在调度队列上来为运行时执行调度 block。当它从队列中移除一个 block 时，它将该 block 分配给其管理的线程池中的一个可用线程。GCD 标识了两种类型的调度队列：串行队列和并发队列。 放置在串行队列上的 block 按照先进先出（FIFO）的顺序被移除。一旦一个 block 从队列中移除，它必须在移除另一个 block 之前完成执行。每个进程都有自己的串行队列（称为主队列）。开发人员可以创建局部于特定进程的额外串行队列。串行队列对于确保多个任务的顺序执行非常有用。 放置在并发队列上的 block 也按照先进先出的顺序被移除，但是可以同时移除多个 block，从而允许多个 block 并行执行。系统有三个全局并发调度队列，并且根据优先级进行区分：低、默认和高。优先级表示 block 相对重要性的近似值。简单来说，具有更高优先级的 block 应该放置在高优先级调度队列上。 以下代码段演示了如何获取默认优先级的并发队列并使用 dispatch_async() 函数将一个 block 提交到队列中： 12dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_async(queue, ^&#123; printf(&quot;I am a block.&quot;); &#125;); 在内部，GCD 的线程池由 POSIX 线程组成。GCD 主动管理该池，允许线程的数量根据应用程序需求和系统容量而增长和收缩。 线程问题 The fork() and exec() System Calls fork() 系统调用用于创建一个独立的、重复的进程。在多线程程序中，fork() 和 exec() 系统调用的语义发生了变化。如果程序中的一个线程调用了 fork()，那么新进程是复制所有线程，还是新进程是单线程的呢？一些 UNIX 系统选择使用两个版本的 fork()，一个版本复制所有线程，另一个版本只复制调用了 fork() 系统调用的线程。 如果一个线程调用了 exec() 系统调用，那么参数中指定的程序将替换整个进程，包括所有线程。 选择使用 fork() 的哪个版本取决于应用程序。如果在 fork() 后立即调用 exec()，则复制所有线程是不必要的，因为参数中指定的程序将替换进程。在这种情况下，只复制调用线程是合适的。然而，如果在 fork() 后独立的进程没有调用 exec()，那么独立的进程应该复制所有线程。 信号处理 信号在UNIX系统中用于通知一个进程特定事件发生。信号可以是同步接收的，也可以是异步接收的，这取决于事件发生的源头和原因。所有信号，无论是同步还是异步，都遵循相同的模式： 通过发生特定事件生成信号。 将信号传递给一个进程。 一旦传递，必须处理信号。 同步信号的示例包括非法内存访问和除零。如果运行中的程序执行这些操作之一，就会生成一个信号。同步信号被传递给执行引起信号的操作的同一进程（这就是它们被认为是同步的原因）。 当由运行进程外部事件生成信号时，该进程异步接收信号。此类信号的示例包括使用特定按键（例如）终止进程以及计时器超时。通常，异步信号被发送到另一个进程。 一个信号可以由两种可能的处理程序之一处理： 默认信号处理程序 用户定义的信号处理程序 每个信号都有一个默认信号处理程序，内核在处理该信号时运行该处理程序。这个默认操作可以被用户定义的信号处理程序覆盖，后者被调用以处理信号。信号的处理方式各不相同。有些信号（例如更改窗口大小）被简单地忽略；其他信号（例如非法内存访问）通过终止程序来处理。 在单线程程序中处理信号是直截了当的：信号总是传递给一个进程。然而，在多线程程序中，一个进程可能有多个线程，因此传递信号更加复杂。那么，信号应该传递到哪里呢？ 将信号传递给引起信号的线程。 将信号传递给进程中的每个线程。 将信号传递给进程中的某些线程。 为接收进程的所有信号分配一个特定的线程。 传递信号的方法取决于生成的信号类型。例如，同步信号需要传递给引起信号的线程，而异步信号的情况则不那么明确。一些异步信号（例如终止进程的信号，如）应该发送到所有线程。 传递信号的标准UNIX函数是： 1int kill(pid_t pid, int signal); 这个函数指定了要向其发送特定信号的进程（pid）。大多数多线程版本的UNIX允许线程指定它们将接受哪些信号和哪些信号将被阻塞。因此，在某些情况下，异步信号可能只被传递到不阻塞它的那些线程。但是，由于信号只需要处理一次，因此通常只将信号传递到找到的第一个不阻塞它的线程。POSIX Pthreads提供了以下函数，允许将信号传递给指定的线程（tid）： 1int pthread_kill(pthread_t tid, int signal); 线程取消 线程取消涉及在其完成之前终止线程。例如，如果多个线程同时在数据库中搜索，其中一个线程返回结果，那么可能会取消其余的线程。另一种情况可能发生在用户按下 Web 浏览器上的按钮停止网页进一步加载时。通常，一个网页使用多个线程加载 ——每个图像都在单独的线程中加载。当用户按下浏览器上的停止按钮时，加载页面的所有线程都将被取消。 即将取消的线程通常称为目标线程。取消目标线程可能发生在两种不同的场景下： 异步取消。一个线程立即终止目标线程。 延迟取消。目标线程周期性地检查是否应该终止，允许其有机会以有序的方式自行终止。 如果资源已分配给要取消的线程或要取消的线程正在更新与其他线程所共享的数据，那么取消就会有困难。这在异步取消的情况下尤其麻烦。通常，操作系统将从已取消的线程中回收系统资源，但不会回收所有资源。因此，异步取消可能无法释放必要的系统范围资源。相反，延迟取消中，一个线程指示目标线程应该被取消，但取消只在目标线程检查标志以确定是否应该取消时发生。Pthread称这些点为取消点 (cancellation point)。 在Pthreads中，使用pthread_cancel()函数启动线程取消。目标线程的标识符作为参数传递给该函数。 123456pthread_t tid;/* 创建线程 */pthread_create(&amp;tid, 0, worker, NULL);. . ./* 取消线程 */pthread_cancel(tid); 然而，调用pthread_cancel()只是表示请求取消目标线程；实际的取消取决于目标线程如何设置以处理请求。Pthreads支持三种取消模式。每种模式都定义为一种状态和一种类型，如下表所示。线程可以使用API设置其取消状态和类型。 正如表格所示，Pthreads允许线程禁用或启用取消。显然，如果禁用取消，线程将无法被取消。但是，取消请求仍然挂起，因此线程稍后可以启用取消并响应请求。默认的取消类型是延迟取消。在这里，取消仅在线程到达取消点cancellation point时发生。建立取消点的一种技术是调用pthread_testcancel()函数。如果发现有挂起的取消请求，则将调用一个称为清理处理程序cleanup handler 的函数。此函数允许线程释放可能已经获取的任何资源，然后线程终止。 以下代码演示了线程如何使用延迟取消响应取消请求： 123456while (1) &#123; /* 进行一段时间的工作 */ /* . . . */ /* 检查是否有取消请求 */ pthread_testcancel();&#125; 由于前述问题，Pthreads文档不推荐使用异步取消。因此，我们在这里不进行介绍。有趣的是，在Linux系统上，使用Pthreads API进行线程取消是通过信号处理的。 Thread-Local Storage 属于一个进程的线程共享该进程的数据。事实上，这种数据共享是多线程编程的一个好处之一。然而，在某些情况下，每个线程可能需要拥有某些数据的自己的副本。我们将这样的数据称为线程本地存储（TLS）。例如，在事务处理系统中，我们可能在单独的线程中处理每个事务。此外，每个事务可能被分配一个唯一的标识符。为了将每个线程与其唯一标识符关联起来，我们可以使用线程本地存储。 很容易将 TLS 与局部变量混淆。然而，局部变量仅在单个函数调用期间可见，而 TLS 数据在函数调用之间是可见的。在某些方面，TLS 与静态数据类似。区别在于 TLS 数据对于每个线程是唯一的。大多数线程库，包括 Windows 和 Pthreads，都提供对线程本地存储的某种形式的支持；Java 也提供支持。 调度程序激活 多线程程序需要考虑的最后一个问题涉及内核与线程库之间的通信，这可能是由多对多和双层模型所要求的。这种协调允许动态调整内核线程的数量，以确保最佳性能。 许多实现多对多或双层模型的系统在用户线程和内核线程之间放置了一个中间数据结构。这个数据结构通常称为轻量级进程（Lightweight Process，LWP）。对于用户线程库来说，LWP 看起来像是可以调度用户线程运行的虚拟处理器。每个 LWP 都附加到一个内核线程上，而操作系统调度的是内核线程在物理处理器上运行。如果一个内核线程阻塞（例如，等待 I/O 操作完成），LWP 也会阻塞。在上层，附加到 LWP 的用户级线程也会阻塞。 一个应用程序可能需要任意数量的 LWPs 来有效运行。考虑在单个处理器上运行的 CPU 密集型应用程序。在这种情况下，一次只能运行一个线程，因此一个 LWP 就足够了。然而，I/O 密集型的应用程序可能需要多个 LWPs 来执行。通常，每个并发的阻塞系统调用都需要一个 LWP。例如，假设同时发生了五个不同的文件读取请求。需要五个 LWPs，因为它们都可能在内核中等待 I/O 完成。如果一个进程只有四个 LWPs，那么第五个请求必须等待其中一个 LWP 从内核返回。 用户线程库和内核之间的通信方案之一被称为调度程序激活（scheduler activation）。其工作原理如下：内核提供应用程序一组虚拟处理器（LWPs），应用程序可以将用户线程调度到可用的虚拟处理器上。此外，内核必须通知应用程序某些事件。这个过程被称为 upcall。Upcalls 由线程库处理，使用 upcall 处理程序，并且 upcall 处理程序必须在虚拟处理器上运行。 触发 upcall 的一个事件是应用程序线程即将阻塞。在这种情况下，内核通过 upcall 通知应用程序线程即将阻塞，并标识特定的线程。然后，内核为应用程序分配一个新的虚拟处理器。应用程序在这个新的虚拟处理器上运行一个 upcall 处理程序，该处理程序保存阻塞线程的状态并放弃正在运行阻塞线程的虚拟处理器。然后，upcall 处理程序调度另一个有资格在新虚拟处理器上运行的线程。当阻塞线程等待的事件发生时，内核再次发起 upcall 给线程库，通知它先前被阻塞的线程现在有资格运行。这个事件的 upcall 处理程序也需要一个虚拟处理器，内核可能分配一个新的虚拟处理器或抢占其中一个用户线程并在其虚拟处理器上运行 upcall 处理程序。在标记未阻塞的线程有资格运行之后，应用程序调度一个有资格在可用虚拟处理器上运行的线程。 Linux 线程 Linux提供了fork()系统调用，具有复制进程的传统功能。Linux还提供使用clone()系统调用创建线程的能力。然而，Linux不区分进程和线程。事实上，Linux在引用程序中的控制流时使用术语task而不是process或thread。 当调用clone()时，它会传递一组标志，这些标志确定父任务和子任务之间要共享多少。假设clone()传递了标志CLONE_FS、CLONE_VM、CLONE_SIGHAND和CLONE_FILES。那么父任务和子任务将共享相同的文件系统信息（例如当前工作目录）、相同的内存空间、相同的信号处理程序和相同的打开文件集。以这种方式使用clone()相当于创建线程，因为父任务与其子任务共享大多数资源。但是，如果在调用clone()时没有设置这些标志中的任何一个，将不会发生共享，结果类似于fork()系统调用提供的功能。 共享级别的差异是可能的，因为任务在Linux内核中的表示方式。对于系统中的每个任务，都存在一个唯一的内核数据结构（具体而言，是struct task_struct）。该数据结构不存储任务的数据，而是包含指向其他数据结构的指针，其中存储了这些数据，例如表示打开文件列表、信号处理信息和虚拟内存的数据结构。当调用fork()时，将创建一个新任务，以及父进程的所有相关数据结构的副本。当调用clone()系统调用时，也会创建一个新任务。但是，与其复制所有数据结构不同，新任务根据传递给clone()的标志集指向父任务的数据结构。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://blackforest1990.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"进程管理","slug":"进程管理","permalink":"https://blackforest1990.github.io/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"}]},{"title":"how to get a job","slug":"how-to-get-a-job","date":"2023-12-02T00:49:53.000Z","updated":"2023-12-04T08:18:58.257Z","comments":true,"path":"2023/12/02/how-to-get-a-job/","link":"","permalink":"https://blackforest1990.github.io/2023/12/02/how-to-get-a-job/","excerpt":"","text":"维基百科指出，就业就是两个合作伙伴中的契约关系。契约关系就是合同关系，只有做到win-win，才能找到一份合适的工作。所以找工作的方法论应该如下：分析个人能力画像，分析目标雇主，如何达成交易。 个人能力画像 工作经历 公司 职位 描述 时间 华为 核心网工程师 软件开发：基于C/Linux/华为ATCA R9单板，负责核心网 IMS 业务开发。 市场技术：欧洲区市场技术接口，云化核心网大T集采，答标支持，需求分析，竞品分析。 2012.08-2016.10 华为 产品经理 行销代表：信令产品（核心网）全球行销代表, ，营销材料上市，出差支持关键项目。 一线行销产品经理：负责核心网产品在乌干达的销售，客户关系拓展，关键格局项目拓展，峰会策划 2016.10-2019.10 无公司 离职 因为媳妇第一个和第二个孩子都掉了，出现了心理问题，然后就一年没咋找工作 2019.10-2020.11 东莞固润科技有限公司 市场总监 父亲介绍，进入固高科技(深圳)有限公司，负责市场体系工作，担任固高子公司固润科技的市场总监（环保方向），21年9月份因为家庭原因离职。 2020.11-2021.09 无公司 离职 现在已经失业两年多了，也没找工作，辞职情况没有敢跟家里说。 2021.09-至今 个人能力模型 项目 描述 评估 英文 熟练阅读，写作，客户交流，workshop，但演进没有用英文做过 良好 通信行业 熟悉核心网，熟悉运营商市场，对于架构和运作方式较为了解 一般 云计算 有电信私有云的实操经验，但对于公有云缺乏理解，实际上来说公有云才是行业的基础 差 水务市场 对于国内的水务市场还停留在了解阶段，没有打过仗 差 编程能力 C语言熟练，但只是对于应用有开发经验，对于底层理解不够 一般 沟通能力 对于风格较为强硬的客户也能做到良好沟通，没有跟客户发展到良好的私人关系，仅限商务交流 一般 商务能力 给客户报过价，客户按照框架合同下的PO，合同谈判能力不足 差 销售能力 没有独立开发过客户，基本上是公司的资源，然后我们负责维护关键客户 一般 团队合作 组建过销售团队，只招到一个投标专员，团队没有成功组建起来 差 个人职业评估 产品经理或解决方案架构师： 你在华为的核心网产品经理职位可能为你提供了产品管理和解决方案设计的经验。这些技能可以转移到其他公司，从事类似的产品管理、解决方案设计或架构师等职位。 技术销售与业务发展： 由于你在华为有信令产品行销代表的经验，同时具备技术背景，可以考虑在技术销售领域寻找机会，尤其是涉及核心网等领域的产品销售和业务发展。 国际业务发展： 你有在国外工作的经验，可以考虑寻找涉及国际业务发展或跨国公司的职位。这可能包括国际销售、业务拓展或国际市场经理等角色。 分析目标雇主 通信，云计算，智能化设备市场优先 职位上先考虑产品经理，再考虑销售人员，偏技术的岗位国内可以投，偏市场的岗位海外市场多投一些 中小企业也可以考虑，但要查询相关企业的文化和雇员信息。 如何达成交易 简历优化，写在简历上的东西真实可靠，但不写对于自己不利的东西 根据任职资格要求，匹配达到60%以上进行投递。 根据岗位职责，写关于该岗位的理解，以及以往工作经验对于该岗位的帮助。 陈述gap year：1. 老婆的生病，照顾家庭 2. 一定的心理问题，承受不了压力 3. 通过学习和好好生活走出来了 精神状态一定要阳光，happy and tough 快速响应，不要瞻前顾后。","categories":[{"name":"如何赚钱","slug":"如何赚钱","permalink":"https://blackforest1990.github.io/categories/%E5%A6%82%E4%BD%95%E8%B5%9A%E9%92%B1/"}],"tags":[{"name":"工作","slug":"工作","permalink":"https://blackforest1990.github.io/tags/%E5%B7%A5%E4%BD%9C/"}]},{"title":"how to make money","slug":"how-to-make-money","date":"2023-11-29T03:39:24.000Z","updated":"2023-12-04T03:11:13.265Z","comments":true,"path":"2023/11/29/how-to-make-money/","link":"","permalink":"https://blackforest1990.github.io/2023/11/29/how-to-make-money/","excerpt":"","text":"如何赚钱呢，这是一个大问题，如何根据自己的能力模型，在有限的时间能够合法的赚到尽可能多的钱，本文先对于个人做分析，认清现实，再去思考每一条赚钱的路子是否可行，给出自己的分析，然后再去实践，然后根据实践结构反馈修正。 个人情况 工作情况 武汉理工大学毕业，理科生，毕业后任职于华为技术有限公司，一开始做13级的初级软件工程师，13级做了4年，绩效不好，而且产品线也不太行，后来转向市场营销，做过信令产品的行销代表，后去去做核心网产品经理，才升到15级了，中间有一些国家出差经验（阿根廷/墨西哥/奥地利/日本），后来在非洲一个小国常驻了一年，这个时期年收入有70万左右，后面因为媳妇在非洲有孕，就辞职回国，因为媳妇第一个和第二个孩子都掉了，出现了心理问题，然后就一年没咋找工作，后来父亲给我找了个深圳小公司的工作，做水务市场总监，也做了一年就辞了，现在已经失业两年多了，也没找工作，辞职情况没有敢跟家里说。 经济状况 本人父母在合肥有两套房，一套自住一套出租，深圳一套房，还有340万商业贷款，60万公积金贷款，每月商业贷款在1万8, 本人还有47万存款，老婆有60万存款，老婆父母在岳阳开缝纫店的，每个月有6000元收入，老婆在深圳做护士，每个月2万的收入。我和妻子目前有个女孩。 本人性格 谨慎型，在工作压力大的时候不愿意主动沟通，职业经历上来看，国外市场比较适应，国内市场做的不好，性格上比较急躁，学习东西较慢，对于编程有兴趣但是不够深入。 未来建议: 考虑调整工作环境以适应自身性格，可能更适合国际市场领域。 寻求心理健康支持，处理家庭经历的心理问题。 在职业规划中寻找平衡点，结合兴趣和能力，可能重新考虑技术领域的发展。 找工作 先从市场工作入手去找，海外的也可以考虑 程序员方面深入以后能够接一些私单了再考虑职业规划 gap year的解释，真诚是最美的，要跟别人先沟通起来 心理健康是最重要的，实在不行只能跟家里人坦白，离婚我也能接受，毕竟我撒谎了 要立刻去沟通了，行动起来 程序员接私活 创建个人项目集： 在GitHub或其他代码托管平台上展示你的项目和代码，这是潜在客户了解你技术水平的好方式。 参与社区：加入相关领域的社区，参与讨论，结识其他开发者和潜在雇主。 制定清晰的服务提供方案：确定你能够提供的服务，包括技术栈、项目类型、开发周期等。 利用在线平台：使用一些专门的平台，如Freelancer、Upwork等，可以找到各种各样的项目。 建立专业形象： 有一个专业的LinkedIn和个人网站，展示你的技能和项目。 炒金融产品 炒金融产品是指通过金融市场进行交易，赚取价格波动差价的行为。这可能涉及股票、外汇、期货、期权等不同类型的金融工具。在炒金融产品时，有一些重要的事项需要考虑： 知识储备： 在开始炒金融产品之前，建议充分了解所选择市场和金融工具的基本原理、交易机制和风险因素。深入理解市场和产品的特性将有助于更好地做出决策。 风险管理： 金融市场涉及高风险，价格波动可能对投资造成损失。制定明确的风险管理策略，包括设定止损点、分散投资、了解杠杆效应等，以保护资金免受大幅度波动的影响。 市场研究： 进行充分的市场研究，包括技术分析和基本面分析，以便更好地预测市场走势。了解市场消息和事件对价格的潜在影响也是重要的。 交易计划： 制定清晰的交易计划，包括进场点、出场点、目标收益等。不要轻率地进行交易，而应该基于策略和计划做出决策。 心理素质： 炒金融产品可能涉及到市场的情绪波动，保持冷静、理性是非常重要的。情绪化的决策往往容易导致损失。 投资目标和期限： 确定你的投资目标和期限，是长期投资还是短期波动性交易。不同的目标可能需要不同的投资策略。 短视频 创业短视频需要综合考虑内容创作、社交传播和商业运营等多个方面。以下是一些步骤和建议： 市场调研： 了解当前短视频行业的趋势和市场竞争状况。确定你的目标受众，探索他们的需求和喜好。 定位和创意： 确定你的短视频平台的定位和创意特色。这可以是特定领域的内容、独特的创作风格、或者是满足某种特定需求的内容。 平台选择： 选择适合你创意方向的短视频平台。目前，像抖音、快手、TikTok等平台是短视频创业比较热门的选择。 内容策划： 制定内容策略，包括频率、主题、风格等。确保你的内容能够引起观众的兴趣，建立粉丝基础。 创作团队： 如果可能，建立一个稳定的创作团队。团队成员可以负责不同的方面，包括拍摄、剪辑、策划等。 优化用户体验： 关注观众的用户体验。确保视频画面清晰、音质良好，同时考虑字幕、特效等元素的合理运用。 社交互动： 建立社交媒体账号，积极互动观众。回应评论、参与话题讨论，增加用户粘性。 合作和推广： 考虑与其他创作者、品牌或平台进行合作。这有助于扩大你的影响力和用户基础。 商业变现： 探索不同的商业变现方式，如品牌合作、广告投放、付费订阅等。建立多元化的变现渠道，降低经营风险。 法律合规： 注意遵守相关法规，尤其是涉及到版权、隐私等方面的法律规定。确保你的创业活动在法律框架内进行。 数据分析： 使用数据分析工具，了解观众行为、内容表现等数据。通过分析数据调整策略，提高内容质量和用户黏性。 持续学习： 短视频领域变化迅速，持续学习新的趋势、技术和市场动态，保持创新。 创业短视频需要不断尝试和调整，同时耐心积累观众基础。成功的关键在于创新、精细化运营和积极的用户互动。 利用人工智能做一些变现 利用人工智能（AI）进行变现可以涉及多个领域，包括产品开发、服务提供、内容创作等。以下是一些常见的AI变现策略： AI产品和服务： 开发AI应用： 利用AI技术开发有市场需求的应用，如语音助手、智能家居系统、自动化工具等。 提供AI服务： 提供定制的AI解决方案，包括机器学习模型开发、自然语言处理服务、图像识别等。 内容生成和创作： 自动化内容生成： 利用AI算法生成高质量的文本、图像或音频内容，可以用于博客、社交媒体或其他平台。 AI创作工具： 开发或提供AI辅助的创作工具，帮助创作者更高效地生成创意内容。 电子商务和推荐系统： 个性化推荐： 利用AI算法实现个性化产品或内容推荐，提高用户体验，同时获取推荐费用。 智能购物助手： 开发AI驱动的购物助手，帮助用户找到最佳价格、产品评价等信息。 金融和投资： 智能投顾： 利用机器学习分析市场趋势，提供个性化的投资建议。 量化交易： 使用AI算法进行量化交易，通过自动化交易策略获得收益。 在线教育和培训： 个性化学习： 利用AI技术为学生提供个性化的学习路径和内容，提高学习效果。 AI教育工具： 开发AI辅助的教育工具，如智能辅导系统、自适应学习平台等。 数据分析和预测： 行业报告和分析： 利用AI对行业趋势、市场数据进行分析，提供行业报告和预测服务。 定制数据分析： 提供基于AI的数据分析服务，帮助企业更好地理解和利用其数据。 游戏和娱乐： 智能游戏开发： 制作利用AI技术创新的游戏，提供独特的娱乐体验。 虚拟现实（VR）和增强现实（AR）： 利用AI增强虚拟或增强现实体验，吸引用户并提供付费服务。 在实施这些策略时，务必注重数据隐私和合规性，并建立良好的用户体验。不同领域的AI变现模式可能需要不同的技术和商业策略，因此在具体执行前，详细研究和规划是至关重要的。","categories":[{"name":"如何赚钱","slug":"如何赚钱","permalink":"https://blackforest1990.github.io/categories/%E5%A6%82%E4%BD%95%E8%B5%9A%E9%92%B1/"}],"tags":[{"name":"导论","slug":"导论","permalink":"https://blackforest1990.github.io/tags/%E5%AF%BC%E8%AE%BA/"}]},{"title":"进程","slug":"进程","date":"2023-11-28T06:01:38.000Z","updated":"2024-01-09T05:17:03.533Z","comments":true,"path":"2023/11/28/进程/","link":"","permalink":"https://blackforest1990.github.io/2023/11/28/%E8%BF%9B%E7%A8%8B/","excerpt":"","text":"进程 在所有操作系统中，一个重要的概念是进程（process）。进程本质上是正在执行的一个程序。进程不止是程序代码，程序代码有时被称为文本段（text section）。进程还包括当前活动，通过程序计数器（program counter）的值和处理器寄存器的内容来表示。另外，进程还包括堆栈段stack（函数参数，返回地址和局部变量）和数据段data section（全局变量）。进程还包括堆（heap），是在进程运行期间动态分配内存。 这里强调:程序本身不是进程:程序是被动实体，如存储在磁盘上包含一系列指令的文件内容(常被称为可执行文件) ，而进程是活动实体，它有一个程序计数器用来表示下一个要执行的命令和相关资源集合。当一个可执行文件被装入内存时，一个程序才能成为进程。装载可执行文件通常有两种方法，即双击一个代表此可执行文件的图标或在命令行中输入该文件的文件名(如prog.exe 或 a.out)。 进程状态 ● new: 进程被创建 ● running: 指令正被执行 ● waiting: 该进程正在等待/阻止某些事件的发生 ● ready: 该进程正在等待被分配给一个处理器 ● terminated: 该进程已完成执行 进程控制块 每个进程在操作系统内用进程控制块 (process control block. PCB)来表示。 进程状态:状态可包括new/running/waiting/ready/terminated。 程序计数器:计数器表示进程要执行的下个指令的地址。 CPU 寄存器:根据计算机体系结构的不同，寄存器的数量和类型也不同。它们包括累加器、索引寄存器、堆栈指针、通用寄存器和其他条件码信息寄存器。与程序计数器一起，这些状态信息在出现中断时也需要保存，以便进程以后能正确地继续执行。 CPU 调度信息:这类信息包括进程优先级、调度队列的指针和其他调度参数 内存管理信息:根据操作系统所使用的内存系统，这类信息包括基址和界限寄存器的值、页表或段表。 记账信息:这类信息包括 CPU 时间、实际使用时间、时间界限、记账数据、作业或进程数量等。 I/O 状态信息:这类信息包括分配给进程的 I/O 设备列表、打开的文件列表等。 Linux中的进程表示 Linux 操作系统中的进程控制块是通过 &lt;linux/sched.h&gt; 中的 task_struct 来表示的。这个结构包含了表示一个进程所需要的所有信息，包括进程的状态、调度和内存管理信息、打开文件列表和指向父进程和所有子进程的指针(创建进程的进程是父进程，被进程创建的进程为子进程) 123456long state; /* state of the process */struct sched_entity se; /* scheduling information */struct task_struct *parent; /* this process’s parent */struct list_head children; /* this process’s children */struct files_struct *files; /* list of open files */struct mm_struct *mm; /* address space of this process */ 例如，进程的状态是通过这个结构中的long state 字段来表示的。在Linux 内核里，所有活动的进程是通过一个名为task_struct 的双向链表来表示的，内核为当前正在运行的进程保存了一个指针(current)。 解释一下内核如何操作一个指定进程的 task_struct 字段。假定操作系统想把当前运行进程的状态值修改成 new state。如果 current是指向当前进程的指针，那么要改变状态可以如下进行: 1current-&gt;state = new state; 进程调度 多道程序设计的目的是无论何时都有进程在运行，从而使 CPU 利用率达到最大化。分时系统在进程之间快速切换 CPU 以便用户在程序运行时能与其进行交互。为了达到此目的，进程调度选择一个可用的进程(可能从多个可用进程集合中选择)到 CPU 上执行。单处理器系统从不会有超过一个进程在运行。如果有多个进程，那么余下的则需要等待 CPU空闲并重新调度。 调度队列 进程进入系统时，会被加入到作业队列(job queue)中,该队列包括系统中所有进程。驻留在内存中就绪的、等待运行的进程保存在就绪队列(ready queue)中, 该队列通常用链表实现，其头结点指向链表的第一个和最后一个PCB块的指针。每个PCB包括一个指向就绪队列的下一个PCB的指针域。 操作系统也有其他队列。当给进程分配了CPU 后，它开始执行并最终完成，或被中断，或等待特定事件发生(如完成I/O 请求)。假设进程向一个共享设备(如磁盘)发送I/O 请求，由于系统有许多进程，磁盘可能会忙于其他进程的I/O 请求，因此该进程可能需要等待磁盘。等待特定 I/O 设备的进程列表称为设备队列(device queue)。 新进程开始处于就绪队列。它在就绪队列中等待直到被选中执行或被派遣。当进程分配到 CPU 并执行时，可能发生下面事件中的一种: 进程可能发出一个 I/O 请求，并被放到 I/O 队列中。 进程可能创建一个新的子进程，并等待其结束。 进程可能会由于中断而强制释放 CPU ，并被放回到就绪队列中。 对于前两种情况，进程最终从等待状态切换到就绪态，并放回到就绪队列中。进程继续这一循环直到终止，到时它将从所有队列中删除，其PCB 和资源将得以释放。 调度程序 进程选择是由相应的调度程序(scheduler) 来执行的。通常对于批处理系统，进程更多地是被提交，而不是马上执行。这些进程被放到大容量存储设备(通常为磁盘)的缓冲池中，保存在那里以便以后执行。长期调度程序(long-term scheduler) 或作业调度程序 (job scheduler) 从该池中选择进程，并装入内存准备执行(秒/分钟级别调度)。短期调度程序 (short-term scheduler) 或 CPU 调度程序从准备执行的进程中选择进程(毫秒级别调度)，并为之分配 CPU 。达到最好性能，长期调度程序应该选择一个合理的包含I/O 为主的和 CPU 为主的组合进程。 对于有些系统，可能没有长期调度程序。例如，UNIX 或Windows 的分时系统通常没有长期调度程序，只是简单地将所有新进程放在内存中以供短期调度程序使用。这些系统的稳定性依赖于物理限制(如可用的终端数)或用户的自我调整。如果多用户系统性能下降到令人难以接受，那么将有用户退出。 有的操作系统如分时系统，可能引入另外的中期调度程序( medium-term scheduler) 。中期调度程序的核心思想是能将进程从内存(或从 CPU 竞争)中移出，从而降低多道程序设计的程度。之后，进程能被重新调入内存，并从中断处继续执行。这种方案称为交换 (swapping) 。通过中期调度程序，进程可换出，并在后来可被换入。为了改善进程组合，或者因内存要求的改变引起了可用内存的过度使用而需要释放内存，就有必要使用交换。 上下文切换 将 CPU 切换到另一个进程需要保存当前进程的状态并恢复另一个进程的状态，这一任务称为上下文切换 (context switch) 。当发生上下文切换时，内核会将旧进程的状态保存在其 PCB 中，然后装入经调度要执行的并己保存的新进程的上下文。上下文切换时间是额外开销，因为切换时系统并不能做什么工作。上下文切换速度因机器而不同，它依赖于内存速度、必须复制的寄存器的数量、是否有特殊指令(如装入或保存所有寄存器的单个指令)，一般需几毫秒。 上下文切换时间与硬件支持密切相关。例如，有的处理器(如 Sun UltraSPARC) 提供了多组寄存器集合，上下文切换只需要简单地改变当前寄存器组的指针。当然，如果活动进程数超过了寄存器集合数量，那么系统需要像以前一样在寄存器与内存之间进行数据复制。而且，操作系统越复杂，上下文切换所要做的工作就越多。 进程操作 绝大多数系统内的进程能并发执行，它们可以动态创建和删除，因此操作系统必须提供某种机制(或工具)以创建和终止进程。 进程创建 在UNIX中，每个进程都由其进程标识符（PID）唯一标识。通过fork()系统调用创建一个新进程。新进程由原始进程的地址空间的副本组成。这种机制允许父进程与其子进程轻松通信。两个进程都在fork()之后的指令继续执行，唯一的区别是fork()的返回码对于新（子）进程是零，而子进程的（非零）进程标识符被返回给父进程。 在fork()系统调用之后，通常有两个进程中的一个使用exec()系统调用来用一个新程序替换进程的内存空间。exec()系统调用将一个二进制文件加载到内存中（销毁包含exec()系统调用的程序的内存映像）并开始执行。通过这种方式，两个进程能够通信然后各自进行。父进程然后可以创建更多的子进程；或者，如果它在子进程运行时没有其他事情可做，它可以发出wait()系统调用，将自己移出就绪队列直到子进程终止。由于对exec()的调用用新程序覆盖进程的地址空间，所以exec()的调用除非发生错误否则不会返回控制。 下面显示的C程序演示了先前描述的UNIX系统调用。现在我们有两个运行相同程序的不同进程。唯一的区别是子进程的pid（进程标识符）的值为零，而父进程的值为大于零的整数（实际上，它是子进程的实际pid）。子进程从父进程继承特权和调度属性，以及某些资源，如打开的文件。然后，子进程使用execlp()系统调用（execlp()是exec()系统调用的一种版本）命令/bin/ls覆盖其地址空间。父进程等待子进程完成，使用wait()系统调用。当子进程完成（通过隐式或显式调用exit()）时，父进程从wait()调用处恢复，然后使用exit()系统调用完成。 12345678910111213141516171819202122#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main()&#123; pid t pid; /* fork a child process */ pid = fork(); if (pid &lt; 0) &#123; /* error occurred */ fprintf(stderr, &quot;Fork Failed&quot;); return 1; &#125; else if (pid == 0) &#123; /* child process */ execlp(&quot;/bin/ls&quot;,&quot;ls&quot;,NULL); &#125; else &#123; /* parent process */ /* parent will wait for the child to complete */ wait(NULL); printf(&quot;Child Complete&quot;); &#125; return 0;&#125; 某些系统中(UNIX)，当进程创建了另一个进程后，父进程和子进程就以某种形式继续保持关联。子进程自身可以创建更多的进程，组成一个进程的树形结构。进程和它的所有子女以及后裔共同组成一个进程组。当用户从键盘发出一个信号时，该信号被送给当前与键盘相关的进程组中的所有成员（它们通常是在当前窗口创建的所有活动进程）。每个进程可以分别捕获该信号、忽略该信号或采取默认的动作，即被该信号杀死。 下图展示了Linux操作系统的典型进程树，显示了每个进程及其PID（进程标识符）的名称。在这里我们使用术语“进程”比较宽泛，因为Linux更倾向于使用task。init进程（始终具有PID 1）充当所有用户进程的根父进程。一旦系统启动，init进程还可以创建各种用户进程，如Web服务器、打印服务器、SSH服务器等。我们看到init的两个子进程是kthreadd和sshd。kthreadd进程负责创建代表内核执行任务的其他进程（在这种情况下是khelper和pdflush）。sshd进程负责管理通过SSH（安全外壳）连接到系统的客户端。登录进程负责管理直接登录到系统的客户端。在这个示例中，一个客户端已经登录并正在使用bash shell，其分配的PID为8416。使用bash命令行接口，该用户创建了进程ps和emacs编辑器。 进程的终止 一个进程在执行完最后一条语句并通过使用 exit() 系统调用请求操作系统删除它时终止。在这一刻，进程可以通过 wait() 系统调用向其父进程返回一个状态值（通常是一个整数）。进程的所有资源，包括物理和虚拟内存、打开的文件以及I/O缓冲区，都会被操作系统释放。 终止也可能发生在其他情况下。一个进程可以通过适当的系统调用（例如在Windows中的TerminateProcess()）引发另一个进程的终止。通常，这样的系统调用只能由要终止的进程的父进程调用。否则，用户可以任意终止彼此的任务。请注意，如果父进程要终止子进程，父进程需要知道子进程的标识。因此，当一个进程创建一个新的进程时，新创建的进程的标识会传递给父进程。 父进程可能出于多种原因终止其子进程的执行： 子进程已经超出了其被分配的一些资源的使用限制。（要确定是否发生了这种情况，父进程必须有一种机制来检查其子进程的状态。） 分配给子进程的任务不再需要执行。 父进程正在退出，而如果其父进程终止，操作系统不允许子进程继续执行。 在一些系统中，如果一个进程的父进程终止，那么该进程就不能存在。在这种系统中，如果一个进程终止（无论是正常还是异常终止），那么它的所有子进程也必须被终止。这种现象被称为级联终止，通常由操作系统启动。 为了说明进程的执行和终止，在Linux和UNIX系统中，我们可以使用 exit() 系统调用来终止一个进程，并提供一个退出状态作为参数： 12/* exit with status 1 */exit(1); 实际上，在正常终止情况下，exit() 可以直接调用（如上所示）或间接调用（通过 main() 函数中的返回语句）。 父进程可以通过使用 wait() 系统调用等待子进程的终止。wait() 系统调用接受一个参数，允许父进程获取子进程的退出状态。此系统调用还返回终止的子进程的进程标识符，以便父进程可以知道其哪个子进程已经终止。 123pid t pid;int status;pid = wait(&amp;status); 当一个进程终止时，其资源由操作系统释放。然而，它在进程表中的条目必须一直保留，直到父进程调用 wait()，因为进程表包含了进程的退出状态。一个已经终止但其父进程尚未调用 wait() 的进程被称为僵尸进程。所有进程在终止时都会过渡到这个状态，但通常它们只会短暂存在。一旦父进程调用了 wait()，僵尸进程的进程标识符和其在进程表中的条目就会被释放。 现在考虑一下，如果父进程没有调用 wait() 而是终止了，从而使其子进程成为孤儿进程，会发生什么情况。Linux 和 UNIX 通过将 init 进程指定为孤儿进程的新父进程来解决这种情况。init 进程定期调用 wait()，从而允许收集任何孤儿进程的退出状态，并释放孤儿进程的进程标识符和进程表条目。 进程间通信 提供允许进程合作的环境有几个原因： 信息共享。由于可能有多个用户对同一信息感兴趣（例如共享文件），我们必须提供一种环境，允许对这样的信息进行并发访问。 计算加速。如果我们希望某个任务运行得更快，我们必须将其分解为子任务，每个子任务将与其他子任务并行执行。请注意，只有计算机具有多个处理核心时，才能实现这样的加速。 模块化。我们可能希望以模块化的方式构建系统，将系统功能划分为独立的进程或线程。 方便。即使是单个用户也可能同时处理许多任务。例如，用户可能同时进行编辑、听音乐和编译。 合作进程需要一种进程间通信（IPC）机制，使它们能够交换数据和信息。有两种基本的进程间通信模型：共享内存和消息传递。在共享内存模型中，建立了由合作进程共享的内存区域。进程可以通过读写数据到共享区域来交换信息。在消息传递模型中，通信通过合作进程之间交换的消息进行。 这两种模型在操作系统中都很常见，许多系统都同时实现了它们。消息传递对于交换较小量的数据很有用，因为不需要避免冲突。在分布式系统中，消息传递也比共享内存更容易实现。共享内存可能比消息传递更快，因为消息传递系统通常是通过系统调用实现的，因此需要更耗时的内核干预。在共享内存系统中，只有在建立共享内存区域时才需要系统调用。一旦共享内存建立，所有访问都被视为常规内存访问，不需要内核的帮助。 最近对具有多个处理核心的系统进行的研究表明，在这些系统上，消息传递提供了比共享内存更好的性能。共享内存存在缓存一致性问题，因为共享数据在多个缓存之间迁移。随着系统上处理核心数量的增加，我们可能会看到消息传递作为IPC的首选机制。 多进程架构 — Chrome 浏览器 许多网站包含诸如 JavaScript、Flash 和 HTML5 等主动内容，以提供丰富而动态的网页浏览体验。不幸的是，这些 Web 应用程序也可能包含软件缺陷，这可能导致响应时间变慢，甚至导致 Web 浏览器崩溃。在仅显示来自一个网站的内容的 Web 浏览器中，这并不是一个大问题。但是，大多数现代 Web 浏览器提供标签式浏览，允许单个 Web 浏览器应用程序同时打开多个网站，每个站点在单独的标签中。用户只需点击相应的标签即可在不同的站点之间切换。这种排列如下图所示： 这种方法的一个问题是，如果任何一个标签中的 Web 应用程序崩溃，整个进程，包括显示其他网站的所有其他标签，也会崩溃。谷歌的 Chrome Web 浏览器通过采用多进程架构来解决这个问题。Chrome 将进程分为三种类型：浏览器、渲染器和插件。 浏览器进程 负责管理用户界面以及磁盘和网络 I/O。在启动 Chrome 时会创建一个新的浏览器进程。只会创建一个浏览器进程。 渲染器进程 包含用于呈现网页的逻辑。因此，它们包含处理 HTML、JavaScript、图像等的逻辑。通常情况下，每个在新标签中打开的网站都会创建一个新的渲染器进程，因此可以同时存在多个渲染器进程。 插件进程 为每种正在使用的插件（如 Flash 或 QuickTime）创建一个进程。插件进程包含插件的代码以及额外的代码，使插件能够与相关的渲染器进程和浏览器进程进行通信。 多进程方法的优势在于各个网站之间运行时是隔离的。如果一个网站崩溃，只有它的渲染器进程受到影响，所有其他进程都不受影响。此外，渲染器进程在沙箱中运行，这意味着对磁盘和网络 I/O 的访问受到限制，从而最小化了任何安全漏洞的影响。 共享内存系统 使用共享内存进行进程间通信需要通信的进程建立一个共享内存区域。通常，共享内存区域存在于创建该共享内存段的进程的地址空间中。希望使用这个共享内存段进行通信的其他进程必须将其连接到它们的地址空间。通常情况下，操作系统会阻止一个进程访问另一个进程的内存。共享内存要求两个或多个进程同意解除这个限制。然后，它们可以通过在共享区域中读写数据来交换信息。数据的形式和位置由这些进程决定，并不受操作系统的控制。这些进程还负责确保它们不会同时写入相同的位置。 为了阐述合作进程的概念，让我们考虑一下生产者-消费者问题，这是一种常见的合作进程范例。生产者进程生成由消费者进程消耗的信息。例如，编译器可能生成汇编代码，由汇编器消耗。然后，汇编器可能生成目标模块，由加载器消耗。生产者-消费者问题还为客户端-服务器范式提供了一个有用的隐喻。通常我们将服务器视为生产者，客户端视为消费者。例如，Web 服务器生成（即提供）HTML 文件和图像，而客户端 Web 浏览器请求这些资源并消耗（即读取）它们。 生产者-消费者问题的一个解决方案使用了共享内存。为了允许生产者和消费者进程同时运行，我们必须有一个可以由生产者填充并由消费者清空的项目缓冲区。这个缓冲区将位于由生产者和消费者进程共享的内存区域。生产者可以在消费者正在消耗另一项时生成一项。生产者和消费者必须同步，以确保消费者不会尝试消耗尚未生成的项目。 可以使用两种类型的缓冲区。无界缓冲区对缓冲区的大小没有实际限制。消费者可能必须等待新项目，但生产者始终可以生成新项目。有界缓冲区假定一个固定的缓冲区大小。在这种情况下，如果缓冲区为空，消费者必须等待；如果缓冲区已满，生产者必须等待。 让我们更仔细地看一下有界缓冲区是如何通过共享内存进行进程间通信的。以下变量存在于生产者和消费者进程共享的内存区域中： 1234567#define BUFFER SIZE 10typedef struct &#123;. . .&#125;item;item buffer[BUFFER SIZE];int in = 0;int out = 0; 共享缓冲区被实现为一个带有两个逻辑指针（in和out）的循环数组：in指向缓冲区中的下一个空位置；out指向缓冲区中的第一个满位置。当in == out时，缓冲区为空；当((in + 1) % BUFFER SIZE) == out时，缓冲区为满。生产者进程有一个本地变量nextProduced，用于存储要生成的新项。消费者进程有一个本地变量nextConsumed，用于存储要消耗的项。 1234567891011121314151617item next_produced;while (true) &#123; /* produce an item in next produced */ while (((in + 1) % BUFFER SIZE) == out) ; /* do nothing */ buffer[in] = next_produced; in = (in + 1) % BUFFER SIZE;&#125;item next consumed;while (true) &#123; while (in == out) ; /* do nothing */ next_consumed = buffer[out]; out = (out + 1) % BUFFER SIZE; /* consume the item in next consumed */&#125; 这种方案允许在同一时间最多有BUFFER SIZE − 1个项目在缓冲区中。这个例子未解决的问题是生产者进程和消费者进程同时尝试访问共享缓冲区的情况。 An Example: POSIX Shared Memory 在POSIX系统中有多种IPC机制，包括共享内存和消息传递。在这里，我们探讨一下用于共享内存的POSIX API。POSIX共享内存使用内存映射文件进行组织，将共享内存区域与文件关联起来。一个进程首先必须使用shm_open()系统调用创建一个共享内存对象，如下所示： 1shm_fd = shm_open(name, O_CREAT | O_RDWR, 0666); 第一个参数指定了共享内存对象的名称。希望访问这个共享内存的进程必须使用这个名称引用对象。后续的参数指定了如果对象不存在就创建它（O_CREAT），并且对象是可读写的（O_RDWR）。最后一个参数设置了共享内存对象的目录权限。对shm_open()的成功调用会返回一个整数文件描述符，用于表示共享内存对象。一旦对象建立，ftruncate()函数被用于配置对象的大小，单位是字节。调用ftruncate(shm_fd, 4096)将对象的大小设置为4096字节。最后，mmap()函数建立了一个包含共享内存对象的内存映射文件，并返回一个指向用于访问共享内存对象的内存映射文件的指针。 生产者创建了一个名为&quot;OS&quot;的共享内存对象，并向共享内存写入了&quot;Hello World!&quot;这个著名的字符串。该程序内存映射了一个指定大小的共享内存对象，并允许对该对象进行写入（显然，对于生产者来说只有写入是必要的）。标志MAP_SHARED指定对共享内存对象的更改将对所有共享该对象的进程可见。注意，我们通过调用sprintf()函数并将格式化的字符串写入指针ptr来写入共享内存对象。在每次写入之后，我们必须将指针按照写入的字节数递增。 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stlib.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/stat.h&gt;int main()&#123; /* the size (in bytes) of shared memory object */ const int SIZE 4096; /* name of the shared memory object */ const char *name = &quot;OS&quot;; /* strings written to shared memory */ const char *message 0 = &quot;Hello&quot;; const char *message 1 = &quot;World!&quot;; /* shared memory file descriptor */ int shm_fd; /* pointer to shared memory obect */ void *ptr; /* create the shared memory object */ shm_fd = shm_open(name, O_CREAT | O_RDRW, 0666); /* configure the size of the shared memory object */ ftruncate(shm_fd, SIZE); /* memory map the shared memory object */ ptr = mmap(0, SIZE, PROT_WRITE, MAP_SHARED, shm_fd, 0); /* write to the shared memory object */ sprintf(ptr,&quot;%s&quot;,message 0); ptr += strlen(message 0); sprintf(ptr,&quot;%s&quot;,message 1); ptr += strlen(message 1); return 0;&#125; 消费者进程读取并输出共享内存的内容。消费者还调用shm_unlink()函数，在消费者访问完共享内存后删除共享内存段。 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;stlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/stat.h&gt;int main()&#123; /* the size (in bytes) of shared memory object */ const int SIZE 4096; /* name of the shared memory object */ const char *name = &quot;OS&quot;; /* shared memory file descriptor */ int shm_fd; /* pointer to shared memory obect */ void *ptr; /* open the shared memory object */ shm_fd = shm_open(name, O_RDONLY, 0666); /* memory map the shared memory object */ ptr = mmap(0, SIZE, PROT_READ, MAP_SHARED, shm_fd, 0); /* read from the shared memory object */ printf(&quot;%s&quot;,(char *)ptr); /* remove the shared memory object */ shm_unlink(name); return 0;&#125; 消息传递系统 消息传递提供了一种机制，允许进程在不共享相同地址空间的情况下进行通信和同步它们的操作。在分布式环境中特别有用，其中通信的进程可能驻留在由网络连接的不同计算机上。例如，一个互联网聊天程序可以设计成参与聊天的用户通过交换消息进行通信。 消息传递设施至少提供两个操作： send(message)（发送消息） receive(message)（接收消息） 由进程发送的消息可以是固定大小或可变大小的。如果只能发送固定大小的消息，则系统级实现比较直接。然而，这种限制使编程任务变得更加困难。相反，可变大小的消息需要更复杂的系统级实现，但编程任务变得更简单。这是操作系统设计中经常遇到的一种权衡。 如果进程P和Q想要通信，它们必须相互发送消息并接收消息：它们之间必须存在一种通信链路。这个链接可以以多种方式实现。我们关心的不是链接的物理实现（例如共享内存、硬件总线或网络），而是它的逻辑实现。以下是逻辑实现链接和send()/receive()操作的几种方法： 直接或间接通信 同步或异步通信 自动或显式缓冲 命名 进程之间要进行通信，它们必须有一种方式来引用彼此。可以使用直接通信或间接通信。 在直接通信中，每个想要通信的进程必须明确命名通信的接收方或发送方。原语被定义如下： send(P, message) — 向进程 P 发送消息。 receive(Q, message) — 从进程 Q 接收消息。 在这个方案中，通信链具有以下属性： 每对想要通信的进程之间会自动建立一个连接。进程只需知道对方的身份就可以进行通信。 一个链接与两个进程关联。 每对进程之间存在且仅存在一个链接。 这个方案在寻址上表现出对称性，即发送方和接收方都必须命名对方才能进行通信。这个方案的变体采用非对称的寻址方式。在这种情况下，只有发送方命名接收方，而不要求接收方命名发送方。原语被定义如下： send(P, message) — 向进程 P 发送消息。 receive(id, message) — 从任何进程接收消息。变量 id 被设置为发生通信的进程的名称。 这两种方案（对称和非对称）的缺点是由于生成的进程定义的模块性有限。更改进程标识符可能需要检查所有其他进程定义。必须找到对旧标识符的所有引用，以便可以将它们修改为新标识符。总的来说，任何这种硬编码技术，在其中标识符必须明确说明的地方，都不如涉及间接寻址的技术更为可取。 在间接通信中，消息被发送到和从邮箱或端口中接收。**邮箱可以抽象地看作是一个对象，进程可以将消息放入其中，也可以从中移除消息。每个邮箱都有一个唯一的标识。**例如，POSIX 消息队列使用整数值来标识邮箱。一个进程可以通过许多不同的邮箱与另一个进程通信，但只有在它们有一个共享的邮箱时，两个进程才能通信。原语被定义如下： send(A, message) — 向邮箱 A 发送消息。 receive(A, message) — 从邮箱 A 接收消息。 在这个方案中，通信链具有以下属性： 仅当一对进程都有一个共享的邮箱时，才会在它们之间建立连接。 一个链接可以与多于两个进程关联。 对于每一对通信的进程，可能存在多个不同的链接，每个链接对应一个邮箱。 **邮箱可以由进程或操作系统拥有。**如果邮箱由进程拥有（即邮箱是进程的地址空间的一部分），那么我们区分所有者（只能通过这个邮箱接收消息）和用户（只能向邮箱发送消息）。由于每个邮箱都有一个唯一的所有者，所以不会混淆应该接收发送到该邮箱的消息的进程。当拥有邮箱的进程终止时，邮箱消失。随后任何尝试向这个邮箱发送消息的进程都必须得到通知，告诉它该邮箱已经不存在。 相反，由操作系统拥有的邮箱是独立的，不附属于任何特定的进程。操作系统必须提供一种机制，允许进程执行以下操作： 创建一个新的邮箱。 通过邮箱发送和接收消息。 删除一个邮箱。 创建新邮箱的进程默认是那个邮箱的所有者。最初，只有所有者可以通过该邮箱接收消息。但是，通过适当的系统调用，所有权和接收权限可以传递给其他进程。当然，这种规定可能导致每个邮箱有多个接收者。 同步 进程之间的通信通过对send()和receive()原语的调用来实现。实现每个原语的方式有不同的设计选项。消息传递可以是阻塞的或非阻塞的，也称为同步和异步。 阻塞发送。发送进程被阻塞，直到消息被接收进程或邮箱接收。 非阻塞发送。发送进程发送消息并继续操作。 阻塞接收。接收者被阻塞，直到有消息可用。 非阻塞接收。接收者检索到一个有效的消息或一个空消息。 send()和receive()的不同组合是可能的。当send()和receive()都是阻塞的时候，我们有了发送者和接收者之间的汇合。当我们使用阻塞的send()和receive()语句时，生产者-消费者问题的解决方案变得非常简单。生产者只需调用阻塞的send()调用，等待消息被传递给接收者或邮箱。同样，当消费者调用receive()时，它会阻塞，直到有消息可用。 1234567891011message next_produced;while (true) &#123; /* produce an item in next_produced */ send(next_produced);&#125;message next_consumed;while (true) &#123; receive(next_consumed); /* consume the item in next_consumed */&#125; 缓冲 无论通信是直接还是间接的，由通信进程交换的消息都存在于一个临时队列中。基本上，这样的队列可以通过三种方式实现： 零容量（Zero capacity）：队列的最大长度为零；因此，链接不能有任何等待的消息。在这种情况下，发送方必须阻塞，直到接收方接收到消息。 有界容量（Bounded capacity）：队列的长度有限，为n；最多可以容纳n条消息。如果在发送新消息时队列没有满，消息将被放入队列中（可以是消息的副本或消息的指针），发送方可以继续执行而无需等待。然而，链接的容量是有限的。如果链接已满，发送方必须阻塞，直到队列中有空间。 无界容量（Unbounded capacity）：队列的长度是潜在无限的；因此，任意数量的消息都可以在其中等待。发送方永远不会阻塞。 零容量的情况有时被称为没有缓冲的消息系统。其他情况被称为具有自动缓冲的系统。 客户端-服务器系统中的通信 在本节中，我们将探讨客户端-服务器系统中通信的另外三种策略：套接字（sockets）、远程过程调用（RPCs）和管道（pipes）。 Sockets 套接字被定义为通信的端点。在网络上通信的一对进程使用一对套接字，每个进程一个。套接字由IP地址和端口号拼接而成。一般来说，套接字采用客户端-服务器体系结构。服务器通过监听指定端口等待传入的客户端请求。一旦接收到请求，服务器接受来自客户端套接字的连接以完成连接。实现特定服务的服务器（例如telnet、FTP和HTTP）监听知名端口（telnet服务器监听端口23；FTP服务器监听端口21；Web或HTTP服务器监听端口80）。所有小于1024的端口都被视为知名端口；我们可以使用它们来实现标准服务。 当客户端进程发起连接请求时，它会被分配一个由其主机计算机指定的端口。此端口具有大于1024的某个任意数字。例如，如果主机X上的具有IP地址146.86.5.20的客户端希望与在地址161.25.19.8上监听端口80的Web服务器建立连接，主机X可能会被分配端口1625。连接将由一对套接字组成：主机X上的(146.86.5.20:1625)和Web服务器上的(161.25.19.8:80)。在主机之间传输的数据包将根据目标端口号传递到适当的进程。 所有连接必须是唯一的。因此，如果主机X上的另一个进程也希望与相同的Web服务器建立另一个连接，它将被分配一个大于1024且不等于1625的端口号。这确保所有连接都由唯一的套接字对组成。 Java提供了三种不同类型的套接字。基于连接的（TCP）套接字使用Socket类实现。无连接的（UDP）套接字使用DatagramSocket类。最后，MulticastSocket类是DatagramSocket类的子类。多播套接字允许将数据发送给多个接收者。 我们的示例描述了一个使用基于连接的TCP套接字的日期服务器。该操作允许客户端从服务器请求当前日期和时间。服务器监听端口6013，尽管端口可以是大于1024的任意任意数字。当接收到连接时，服务器将日期和时间返回给客户端。服务器创建一个指定将监听端口6013的ServerSocket。然后，服务器开始使用accept()方法监听该端口。服务器在accept()方法上阻塞，等待客户端请求连接。当接收到连接请求时，accept()返回一个套接字，服务器可以用来与客户端通信。 123456789101112131415161718192021222324import java.net.*;import java.io.*;public class DateServer&#123; public static void main(String[] args) &#123; try &#123; ServerSocket sock = new ServerSocket(6013); /* now listen for connections */ while (true) &#123; Socket client = sock.accept(); PrintWriter pout = new PrintWriter(client.getOutputStream(), true); /* write the Date to the socket */ pout.println(new java.util.Date().toString()); /* close the socket and resume */ /* listening for connections */ client.close(); &#125; &#125; catch (IOException ioe) &#123; System.err.println(ioe); &#125; &#125;&#125; 服务器与套接字通信的详细步骤如下。服务器首先创建一个PrintWriter对象，用于与客户端通信。PrintWriter对象允许服务器使用print()和println()方法向套接字写入输出。服务器进程通过调用println()方法向客户端发送日期。一旦将日期写入套接字，服务器关闭与客户端的套接字，并继续等待更多请求。 客户端通过创建一个套接字并连接到服务器正在监听的端口来与服务器通信。客户端创建一个Socket，并请求与IP地址为127.0.0.1、端口为6013的服务器建立连接。一旦建立连接，客户端可以使用正常的流I/O语句从套接字读取数据。在从服务器接收到日期后，客户端关闭套接字并退出。IP地址127.0.0.1是一个特殊的IP地址，被称为回环地址。当计算机引用IP地址127.0.0.1时，它指的是自己。这种机制允许同一主机上的客户端和服务器使用TCP/IP协议进行通信。IP地址127.0.0.1可以替换为运行日期服务器的另一台主机的IP地址。除了IP地址外，还可以使用实际主机名。 1234567891011121314151617181920212223import java.net.*;import java.io.*;public class DateClient&#123; public static void main(String[] args) &#123; try &#123; /* make connection to server socket */ Socket sock = new Socket(&quot;127.0.0.1&quot;,6013); InputStream in = sock.getInputStream(); BufferedReader bin = new BufferedReader(new InputStreamReader(in)); /* read the date from the socket */ String line; while ( (line = bin.readLine()) != null) System.out.println(line); /* close the socket connection*/ sock.close(); &#125; catch (IOException ioe) &#123; System.err.println(ioe); &#125; &#125;&#125; 使用套接字进行通信，尽管普遍而高效，被认为是在分布式进程之间进行低级通信的一种形式。其中一个原因是套接字仅允许在通信线程之间交换无结构的字节流。客户端或服务器应用程序有责任对数据施加结构。 远程过程调用 远程服务的最常见形式之一是RPC范例，RPC被设计为一种抽象的过程调用机制，用于在具有网络连接的系统之间使用。在许多方面，它类似于IPC机制，并且通常构建在这样的系统之上。然而，在这里，因为我们处理的是进程在不同系统上执行的环境，我们必须使用基于消息的通信方案来提供远程服务。 与IPC消息不同，RPC通信中交换的消息是结构良好的，因此不再只是数据包。每个消息都寻址到监听远程系统上某个端口的RPC守护程序，并且每个消息都包含一个标识符，指定要执行的函数以及传递给该函数的参数。然后按照请求执行函数，并将任何输出发送回请求者，以独立的消息形式。 端口只是包含在消息数据包开头的一个数字。虽然系统通常只有一个网络地址，但它可以在该地址内有多个端口，以区分它支持的许多网络服务。如果远程进程需要一个服务，它会将消息寻址到适当的端口。例如，如果一个系统希望允许其他系统能够列出其当前用户，它将具有支持这样一个RPC的守护程序，附加到一个端口上，比如端口3027。任何远程系统都可以通过向服务器的端口3027发送RPC消息来获取所需的信息（即当前用户列表）。数据将在回复消息中接收到。 RPC的语义允许客户端调用远程主机上的过程，就像在本地调用过程一样。RPC系统通过在客户端侧提供一个存根来隐藏允许通信发生的细节。通常，每个单独的远程过程都有一个单独的存根。当客户端调用远程过程时，RPC系统调用适当的存根，将提供给远程过程的参数传递给它。该存根定位服务器上的端口并对参数进行编组。参数编组涉及将参数封装为可以通过网络传输的形式。然后，存根使用消息传递向服务器发送消息。服务器端的类似存根接收此消息并在服务器上调用该过程。如果需要，返回值将使用相同的技术传递回客户端。在Windows系统上，存根代码是从使用Microsoft Interface Definition Language（MIDL）编写的规范中编译出来的，该语言用于定义客户端和服务器程序之间的接口。 必须处理的一个问题涉及客户端和服务器机器上数据表示的差异。考虑32位整数的表示。一些系统（称为big-endian）首先存储最高有效字节，而其他系统（称为little-endian）首先存储最低有效字节。在计算机体系结构内，两种顺序都没有本质的“更好”之分；相反，选择在计算机体系结构内是任意的。为了解决这样的差异，许多RPC系统定义了数据的机器无关表示。其中一种表示被称为外部数据表示（XDR）。在客户端侧，参数编组涉及在将数据发送到服务器之前将机器相关的数据转换为XDR。在服务器端，XDR数据进行解组，并转换为服务器的机器相关表示。 另一个重要问题涉及调用的语义。而本地过程调用仅在极端情况下失败，RPC可能会因为常见网络错误而失败，或者被重复执行多次。解决这个问题的一种方法是让操作系统确保消息仅被执行一次，而不是至多一次。大多数本地过程调用具有“仅一次”功能，但实现起来更为困难。 首先，考虑“至多一次”。这种语义可以通过将时间戳附加到每个消息上来实现。服务器必须保留其已处理的所有消息的时间戳历史记录，或者历史记录足够大，以确保检测到重复的消息。具有已在历史记录中的时间戳的传入消息将被忽略。然后，客户端可以发送一条或多条消息，并确保它只执行一次。 对于“仅一次”，我们需要消除服务器永远不会接收到请求的风险。为了实现这一点，服务器必须实现上述“至多一次”协议，但还必须向客户端确认已接收和执行了RPC调用。这些ACK消息在整个网络中都很常见。客户端必须定期重新发送每个RPC调用，直到收到该调用的ACK为止。 另一个重要问题涉及服务器和客户端之间的通信。**在标准过程调用中，通常在链接、加载或执行时间发生某种绑定，以便过程调用的名称被过程调用的内存地址替换。**RPC方案要求对客户端和服务器端口进行类似的绑定，但是客户端如何知道服务器上的端口号呢？由于它们不共享内存，因此两个系统都没有关于对方的完整信息。 有两种常见的方法。首先，绑定信息可以是预先确定的，以固定的端口地址的形式存在。在编译时，RPC调用与其关联的固定端口号。一旦程序被编译，服务器就不能更改所请求服务的端口号。其次，可以通过会合机制动态地进行绑定。通常，在固定的RPC端口上提供一个会合守护程序。然后，客户端发送一个包含所需执行的RPC的名称的消息给会合守护程序，请求该RPC的端口地址。返回端口号后，就可以将RPC调用发送到该端口，直到该进程终止（或服务器崩溃）。这种方法需要初始请求的额外开销，但比第一种方法更灵活。 RPC方案在实现分布式文件系统时非常有用。这样的系统可以作为一组RPC守护程序和客户端来实现。消息寻址到服务器上将执行文件操作的分布式文件系统端口。消息包含要执行的磁盘操作。磁盘操作可能是读取、写入、重命名、删除或状态，对应于常见的文件相关系统调用。返回消息包含由客户端的DFS守护程序代表客户端执行的该调用产生的任何数据。例如，一条消息可能包含一个请求将整个文件传输给客户端，也可能仅限于简单的块请求。在后一种情况下，如果要传输整个文件，可能需要多次请求。 管道 管道允许两个进程进行通信。在早期的UNIX系统中，管道是最早的IPC机制之一。它们通常为进程相互通信提供了较为简单的方式，尽管它们也有一些局限性。在实现管道时，需要考虑四个问题： 管道是否允许双向通信，还是通信是单向的？ 如果允许双向通信，它是半双工的（数据只能单向传输）还是全双工的（数据可以同时在两个方向传输）？ 通信进程之间是否必须存在某种关系（如父子关系）？ 管道是否可以在网络上通信，还是通信进程必须位于同一台机器上？ 普通管道 普通管道允许两个进程以标准的生产者-消费者方式进行通信：生产者向管道的一端写入（写端），而消费者从另一端读取（读端）。**因此，普通管道是单向的，只允许单向通信。**如果需要双向通信，必须使用两个管道，每个管道在不同的方向发送数据。接下来，我们将演示如何在UNIX上构建普通管道。在这两个程序示例中，一个进程向管道写入消息“Greetings”，而另一个进程从管道中读取这条消息。 在UNIX系统上，使用函数pipe(int fd[])构建普通管道。这个函数创建一个通过int fd[]文件描述符访问的管道：fd[0]是管道的读端fd[1]是写端。UNIX将管道视为一种特殊类型的文件，因此可以使用普通的read()和write()系统调用访问管道。 普通管道无法从创建它的进程外部访问。通常，父进程创建一个管道，并使用它与通过fork()创建的子进程进行通信。下图说明了文件描述符fd与父进程和子进程之间的关系。 在下面的UNIX程序中，父进程创建了一个管道，然后调用fork()创建子进程。在fork()调用之后发生的事情取决于数据如何通过管道流动。在这个示例中，父进程写入管道，而子进程从管道中读取。重要的是要注意，父进程和子进程最初都关闭了他们未使用的管道端。这是一个重要的步骤，以确保从管道读取的进程能够检测到文件末尾（read()返回0），当写入端关闭其端口时。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#define BUFFER_SIZE 25#define READ_END 0#define WRITE_END 1int main(void)&#123; char write msg[BUFFER_SIZE] = &quot;Greetings&quot;; char read msg[BUFFER_SIZE]; int fd[2]; pid_t pid; /* create the pipe */ if (pipe(fd) == -1) &#123; fprintf(stderr,&quot;Pipe failed&quot;); return 1; &#125; /* fork a child process */ pid = fork(); if (pid &lt; 0) &#123; /* error occurred */ fprintf(stderr, &quot;Fork Failed&quot;); return 1; &#125; if (pid &gt; 0) &#123; /* parent process */ /* close the unused end of the pipe */ close(fd[READ_END]); /* write to the pipe */ write(fd[WRITE_END], write msg, strlen(write msg)+1); /* close the write end of the pipe */ close(fd[WRITE_END]); &#125; else &#123; /* child process */ /* close the unused end of the pipe */ close(fd[WRITE_END]); /* read from the pipe */ read(fd[READ_END], read msg, BUFFER SIZE); printf(&quot;read %s&quot;,read msg); /* close the write end of the pipe */ close(fd[READ_END]); &#125; return 0;&#125; 请注意，普通管道在UNIX系统上都要求通信进程之间存在父-子关系。这意味着这些管道只能用于在同一台机器上的进程之间进行通信。 命名管道 普通管道提供了一个简单的机制，允许一对进程进行通信。然而，普通管道只存在于进程在彼此通信时。在UNIX系统上，一旦进程完成通信并终止，普通管道就会停止存在。命名管道提供了一种更强大的通信工具。通信可以是双向的，并且不需要父子关系。一旦建立了命名管道，多个进程可以使用它进行通信。事实上，在典型情况下，一个命名管道可能有多个写入者。此外，命名管道在通信进程完成后仍然存在。 在UNIX系统中，命名管道被称为FIFO（先进先出）。一旦创建，它们会在文件系统中显示为典型的文件。可以使用mkfifo()系统调用创建FIFO，并使用普通的open()、read()、write()和close()系统调用对其进行操作。它将继续存在，直到在文件系统中明确删除为止。虽然FIFO允许双向通信，但通常只允许半双工传输。如果数据必须在两个方向上传输，通常会使用两个FIFO。此外，通信进程必须驻留在同一台机器上。如果需要跨机器通信，则必须使用套接字。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://blackforest1990.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"进程管理","slug":"进程管理","permalink":"https://blackforest1990.github.io/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"}]},{"title":"操作系统原理导论","slug":"操作系统原理导论","date":"2023-11-28T03:09:28.000Z","updated":"2023-12-29T06:34:04.164Z","comments":true,"path":"2023/11/28/操作系统原理导论/","link":"","permalink":"https://blackforest1990.github.io/2023/11/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%AF%BC%E8%AE%BA/","excerpt":"","text":"根据维基百科对于操作系统的总结：操作系统（英语：Operating System，缩写：OS）是一组主管并控制计算机操作、运用和运行硬件、软件资源和提供公共服务来组织用户交互的相互关联的系统软件程序，同时也是计算机系统的内核与基石。 操作系统的历史 第一代（1945~1955）：真空管和穿孔卡带 同一个小组的人设计、建造、编程、操作并维护一台机器。所有的程序设计是用纯粹的机器语言编写的，甚至更糟糕，需要通过将上千根电缆接到插件板上连接成电路，以便控制机器的基本功能。没有程序设计语言（甚至汇编语言也没有），操作系统则从来没有听说过。使用机器的一般方式是，程序员在墙上的机时表上预约一段时间，然后到机房中将他的插件板接到计算机里，在接下来的几小时里，期盼正在运行中的两万多个真空管不会烧坏。那时，所有的计算问题实际都只是简单的数字运算，如制作正弦、余弦以及对数表等。到了20世纪50年代早期有了改进，出现了穿孔卡片，这时就可以将程序写在卡片上，然后读入计算机而不用插件板，但其他过程则依然如旧。 第二代（1955～1965）：晶体管和批处理系统 20世纪50年代晶体管的发明极大地改变了整个状况。计算机已经很可靠，厂商可以成批地生产并销售计算机给用户，用户可以指望计算机长时间运行，完成一些有用的工作。此时，设计人员、生产人员、操作人员、程序人员和维护人员之间第一次有了明确的分工。 这些机器，现在被称作大型机（mainframe），锁在有专用空调的房间中，由专业操作人员运行。只有少数大公司、重要的政府部门或大学才接受数百万美元的标价。要运行一个作业（job，即一个或一组程序），程序员首先将程序写在纸上（用FORTRAN语言或汇编语言），然后穿孔成卡片，再将卡片盒带到输入室，交给操作员，接着就喝咖啡直到输出完成。 由于当时的计算机非常昂贵，人们很自然地要想办法减少机时的浪费。通常采用的解决方法就是批处理系统（batch system）。在输入室收集全部的作业，然后用一台相对便宜的计算机，如IBM 1401计算机，将它们读到磁带上。IBM 1401计算机适用于读卡片、复制磁带和输出打印，但不适用于数值运算。另外用较昂贵的计算机，如IBM 7094来完成真正的计算。 第三代（1965～1980）：集成电路芯片和多道程序设计 IBM 360是一个软件兼容的计算机系列，其低档机与1401相当，高档机则比7094功能强很多。由于所有的计算机都有相同的体系结构和指令集，因此，在理论上，为一种型号机器编写的程序可以在其他所有型号的机器上运行。而且360被设计成既可用于科学计算，又可用于商业计算，这样，一个系列的计算机便可以满足所有用户的要求。360是第一个采用（小规模）芯片（集成电路）的主流机型，与采用分立晶体管制造的第二代计算机相比，其性能/价格比有很大提高。“单一家族”思想的最大优点同时也是其最大的缺点。IBM（或其他公司）无法写出同时满足这些相互冲突需要的软件，其结果是一个庞大的又极其复杂的操作系统。 它也使第二代操作系统所缺乏的几项关键技术得到了广泛应用。 其中最重要的应该是多道程序设计（multiprogramming）。当一个作业等待I/O操作完成时，另一个作业可以使用CPU。如果内存中可以同时存放足够多的作业，则CPU利用率可以接近100%。在内存中同时驻留多个作业需要特殊的硬件来对其进行保护，以避免作业的信息被窃取或受到攻击。 同时的外部设备联机操作（Simultaneous Peripheral Operation On Line，SPOOLing），任何时刻当一个作业运行结束时，操作系统就能将一个新作业从磁盘读出，装进空出来的内存区域运行。 分时系统（timesharing）的出现 【Unix诞生】 一位曾参加过MULTICS研制的贝尔实验室计算机科学家Ken Thompson，后来找到一台无人使用的PDP-7机器，并开始开发一个简化的、单用户版MULTICS。他的工作后来导致了UNIX操作系统的诞生。接着，UNIX在学术界，政府部门以及许多公司中流行。为了使编写的程序能够在任何版本的UNIX上运行，IEEE提出了一个UNIX的标准，称作POSIX，目前大多数UNIX版本都支持它。对UNIX版本免费产品（不同于教育目的）的愿望，导致芬兰学生Linus Torvalds编写了Linux。 第四代（1980年至今）：个人计算机 随着LSI（大规模集成电路）的发展，在每平方厘米的硅片芯片上可以集成数千个晶体管，个人计算机时代到来了。 1974年，当Intel 8080，第一代通用8位CPU出现时，Intel希望有一个用于8080的操作系统，部分是为了测试目的。Intel请求其顾问Gary Kildall编写。Kildall和一位朋友首先为新推出的Shugart Associates 8英寸软盘构造了一个控制器，并把这个软磁盘同8080相连，从而制造了第一个配有磁盘的微型计算机。 1977年，Digital Research重写了CP/M，使其可以在使用8080、Zilog Z80以及其他CPU芯片的多种微型计算机上运行，从而使得CP/M完全控制了微型计算机世界达5年之久。 在20世纪80年代的早期，IBM设计了IBM PC并寻找可在上面运行的软件。来自IBM的人员同Bill Gates联系有关他的BASIC解释器的许可证事宜，他们也询问是否他知道可在PC机上运行的操作系统。Gates建议IBM同Digital Research联系，即当时世界上主宰操作系统的公司。在做出毫无疑问是近代历史上最糟的商业决策后，Kildall拒绝与IBM会见。 在IBM返回时，Gates了解到一家本地计算机制造商，Seattle Computer Products，有合适的操作系统DOS（Disk Operating System）。他联系对方并提出购买（宣称75 000美元），对方接受了。然后Gates提供给IBM成套的DOS/BASIC，IBM也接受了。IBM希望做某些修改，于是Gates雇佣了那个写DOS的作者，Tim Paterson，作为Gates的微软公司早期的一个雇员，并开展工作。修改版称为MS-DOS（MicroSoft Disk Operating System），并且很快主导了IBM PC市场。同Kildall试图将CP/M每次卖给用户一个产品相比（至少 开始是这样），这里一个关键因素是Gates（回顾起来，极其聪明）的决策，将MS-DOS与计算机公司的硬件捆绑在一起出售。 1983年，IBM PC后续机型IBM PC/AT推出，配有Intel 80286 CPU。此时，MS-DOS已经确立了地位。 Steve Jobs访问PARC,Jobs一看到GUI，立即意识到它的潜在价值，而Xerox管理层恰好没有认识到。Jobs随后着手设计了带有GUI的苹果计算机。Jobs的第二次尝试，即苹果Macintosh，取得了巨大的成功，它是为那些不仅没有计算机知识，而且也根本不打算学习计算机的用户们准备的。在图像设计、专业数码摄影，以及专业数字视频生产的创意世界里，Macintosh得到广泛的应用。 在微软决定构建MS-DOS的后继产品时，受到了Macintosh成功的巨大影响。微软开发了名为Windows的基于GUI的系统，早期它运行在MS-DOS上层（它更像shell而不像真正的操作系统）。在从1985年至1995年的10年之间，Windows只是在MS-DOS上层的一个图形环境。然而，到了1995年，一个独立的Windows版本，具有许多操作系统功能的Windows 95发布了。Windows 95仅仅把底层的MS-DOS作为启动和运行老的MS-DOS程序之用。1998年，一个稍做修改的系统，Windows 98发布。不过Windows 95和Windows 98仍然使用了大量16位Intel汇编语言。 在个人计算机世界中，另一个主要竞争者是UNIX（和它的各种变体）。UNIX在网络和企业服务器等领域强大，在台式计算机上，特别是在诸如印度和中国这些发展中国家里，UNIX的使用也在增加。 操作系统功能 操作系统位于底层硬件与用户之间，是两者沟通的桥梁。用户可以通过操作系统的用户界面，输入命令。操作系统则对命令进行解释，驱动硬件设备，实现用户要求。操作系统的主要标准功能：进程管理，内存管理，文件系统管理，输入输出管理。 对于操作系统功能总结如下： 同样理论需要向实践服务，知行需要合一，本博客同样针对一种一种多应用与服务端的操作系统进行研究，Linux。 参考资料 维基百科 操作系统概念(第9版) 英文版 操作系统设计与实现 第3版 现代操作系统（原书第3版） (计算机科学丛书) 后续阅读链接","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://blackforest1990.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"导论","slug":"导论","permalink":"https://blackforest1990.github.io/tags/%E5%AF%BC%E8%AE%BA/"}]},{"title":"how to read a book","slug":"how-to-read-a-book","date":"2023-11-21T08:10:05.000Z","updated":"2023-12-04T03:11:19.897Z","comments":true,"path":"2023/11/21/how-to-read-a-book/","link":"","permalink":"https://blackforest1990.github.io/2023/11/21/how-to-read-a-book/","excerpt":"","text":"如何阅读一本书 读书多而无所得，遇到经典书籍很难坚持下去，读不到自己脑子里去，找到一本【如何阅读一本书】，从几个层次来讨论书籍如何来阅读。 读书分为四个层次，基础阅读，检视阅读，分析阅读，主题阅读，层层递进，一层比一层深入。 基础阅读 基础阅读为基本能力，逐句阅读，为信息检索。 检视阅读 检视阅读为了解作者写作的框架，粗粗略略的快速读过，也是读者对于书的挑选，如果是煌煌巨著，再深入之。 (1)先看书名页，然后如果有序就先看序 (2)研究目录页 (3)如果书中附有索引，也要检阅一下 (4)如果那是本包着书衣的新书，不妨读一下出版社的介绍 (5)从你对一本书的目录很概略，甚至有点模糊的印象中，开始挑几个看来跟主题息息相关的篇章来看。 (6)最后一步，把书打开来，东翻翻西翻翻，念个一两段，有时候连续读几页，但不要太多 分析阅读 分析阅读有时候也可以称为“精读”。显然，只有对有价值的书，才值得花力气做“分析阅读”。“烂书或平庸的书”是没有这种待遇的。 这本书花了大量的篇幅来介绍“分析阅读”。这部分是此书【重点中的重点】。 第一阶段 找出一本书在谈些什么： (1)依照书本的种类与主题作分类。 (2)用最简短的句子说出整本书在谈些什么。 (3)按照顺序与关系，列出全书的重要部分。将全书的纲要拟出来之后，再将各个部分的纲要也一一列出。 (4)找出作者在问的问题，或作者想要解决的问题。 第二阶段 诠释一本书的内容： (5)诠释作者使用的关键字，与作者达成共识。 (6)从最重要的句子中抓出作者的重要主旨。 (7)找出作者的论述，重新架构这些论述的前因后果，以明白作者的主张。 (8)确定作者已经解决了哪些问题，还有哪些是未解决的。在未解决的问题中，确定哪些是作者认为自己无法解决的问题。 第三阶段 像是沟通知识一样地评论一本书： A．智慧礼节的一般规则 (9)除非你已经完成大纲架构，也能诠释整本书了，否则不要轻易批评。（在你说出：“我读懂了!”之前，不要说你同意、不同意或暂缓评论。） (10)不要争强好胜，非辩到底不可。 (11)在说出评论之前，你要能证明自己区别得出真正的知识与个人观点的不同。 B．批评观点的特别标准 (12)证明作者的知识不足。 (13)证明作者的知识错误。 (14)证明作者不合逻辑。 (15)证明作者的分析与理由是不完整的。 注意：关于最后这四点，前三点是表示不同意见的准则，如果你无法提出相关的佐证，就必须同意作者的说法，或至少一部分说法。你只能因为最后一点理由，对这本书暂缓评论。 主题阅读 所谓的“主题阅读”，通俗而言就是：为了研究某个主题，阅读跟该主题相关的多本书籍。这种阅读主要包括5个步骤： 步骤一：找到相关的章节。在主题阅读中，你及你关心的主题才是基本的重点，而不是你阅读的书。总之，要记得你最主要的工作不是理解整本书的内容，而是找出这本书对你的主题有什么帮助，而这可能与作者本身的写作目的相去甚远。 步骤二：带引作者与你达成共识。真正的困难在于要强迫作者使用你的语言，而不是使用他的语言。 步骤三：厘清问题。把我们的问题说得比较明白的问题，然后让那些作者来回答这些问题。 步骤四：界定议题。设定了一个不偏不倚的共识，适用于所有被检视过的作者，再设定出一整套的问题，其中大部分都能在作者的说明中找到答案。然后就不同的答案界定并安排出议题。 步骤五：分析讨论。找到有价值的问题之后，就需要通过自己的综合分析，思考一下：为什么这几本书的作者，对同一个问题会有不同的答案。如果你能想明白，那么你对该主题所处的领域，就有了更深刻的理解。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://blackforest1990.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"实用","slug":"实用","permalink":"https://blackforest1990.github.io/tags/%E5%AE%9E%E7%94%A8/"},{"name":"工具书","slug":"工具书","permalink":"https://blackforest1990.github.io/tags/%E5%B7%A5%E5%85%B7%E4%B9%A6/"}]},{"title":"邓小平时代","slug":"邓小平时代","date":"2023-03-21T08:25:20.000Z","updated":"2024-01-09T05:14:10.942Z","comments":true,"path":"2023/03/21/邓小平时代/","link":"","permalink":"https://blackforest1990.github.io/2023/03/21/%E9%82%93%E5%B0%8F%E5%B9%B3%E6%97%B6%E4%BB%A3/","excerpt":"","text":"傅高义这本书，基本上站在客观角度观察邓小平，说明了邓在各个阶段的人生经历和施政要领。 邓是一名忠诚的共产党员和民族主义者，贯穿整个人生他都做到了这一点，他在法国留学，但是由于时局突变，没有机会学习，进行了革命运动，但终其一生他都对于知识和科学技术保留了尊重，明白科技为第一生产力。在毛主政时期，虽然三上三下，屡受打压，但是他没有让打压阻碍了工作，仍然宠辱不惊的完成了外交任务，同时恪守原则，在路线问题上不退后一步，但同时因为与毛的私交没有被开除党籍，仍然保留了希望；邓在施政上以稳定为第一原则，对于文革没有清算，保存了党和政权的威严，在经济发展上，摸着石头过河，有问题先去实践，看看效果，再决定全国是否推广。坚持改革开放不动摇，由地方去影响北京。在学潮问题中，以强悍的手腕维持了稳定，同时积极跟美国沟通，后面虽然遭受了制裁但事情仍有余地，邓的治国，让中国迅速拜托了阶级斗争，封印了文革的伤痛，发展壮大了起来，他始终保持客观与强悍，信奉精英治国，维持了中国的稳定。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://blackforest1990.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"人物传记","slug":"人物传记","permalink":"https://blackforest1990.github.io/tags/%E4%BA%BA%E7%89%A9%E4%BC%A0%E8%AE%B0/"}]},{"title":"读超新星纪元有感","slug":"读超新星纪元有感","date":"2023-03-14T14:12:11.000Z","updated":"2023-03-14T14:21:11.715Z","comments":true,"path":"2023/03/14/读超新星纪元有感/","link":"","permalink":"https://blackforest1990.github.io/2023/03/14/%E8%AF%BB%E8%B6%85%E6%96%B0%E6%98%9F%E7%BA%AA%E5%85%83%E6%9C%89%E6%84%9F/","excerpt":"","text":"超新星纪元 读书笔记 作者：刘慈欣 残酷的幻想，人类被星际灾变拦腰截断。 人类在有一线希望的时候总能迸发强大的生机。 孩子和大人是两种不同的物种，双方对于对方都有误判。 当失去了领土，一种骨子里流淌的东西也失去了。 需要有智囊，同样也要有决断。 国际政治的均衡实际上很脆弱。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://blackforest1990.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"科幻","slug":"科幻","permalink":"https://blackforest1990.github.io/tags/%E7%A7%91%E5%B9%BB/"}]},{"title":"读史有感","slug":"读史有感","date":"2023-03-14T13:58:14.000Z","updated":"2023-10-24T06:53:35.303Z","comments":true,"path":"2023/03/14/读史有感/","link":"","permalink":"https://blackforest1990.github.io/2023/03/14/%E8%AF%BB%E5%8F%B2%E6%9C%89%E6%84%9F/","excerpt":"","text":"秦：国家军国主义，丈量全国土地，登记造册全国资源，对于人民压榨太过，没有很好地消化六国残余势力 项羽：军神级别，勇略为第一将，而无战略，以自己的喜怒而支配政治（烧咸阳宫，杀秦降将，失关中之心） 刘邦：49岁斩白蛇，取得关中，军霸上，财务无所取，妇女无所辛，完成蜕变（成大事要有第一等的克制），永远用正确的人做事，宽以待人，团结一切力量，对于制度的探索要摸着石头过河，黑猫白猫抓住老鼠就是好猫。 韩信：长于军事战略，能够快速判断局势，趁关中立足未稳而定关中，10个月平魏，定赵，灭齐，降燕，充分收集情报，实实虚虚，以比之长攻彼之短，但是在身居高位的时候没有三分天下，终究是国士无双，而没有意识到政治斗争的残酷性。 吕后：用黄老之道治国，维持小政府，在没有大动乱（战争和大灾），能够很好地与民休息，不与军功集团争相权，保持政治平衡，对于权力克制不够，对于政敌迫害过大，导致后面反弹太大。 文帝：宽厚而福报深厚，在政治和权力面前永远是谨慎的，推恩令逐渐蚕食诸侯的权力，继续用黄老之道治国。 武帝：为千古一帝，权术的顶峰，文化上独尊儒术，儒学也彻底倒向统治者，创造了很多压榨人民的手段，官方统一货币，国有企业出现（盐，铁），人民被无止境的盘剥，允许买官，通过压榨天下，拥有了庞大的经费，建立起了天下无敌的骑兵，发出了犯强汉者虽远必诛的强音，然后在晚年通过权术，让太子自杀，发布罪己诏，让政策软着陆，定下了昭宣的政策方针（由军略和盘剥改为与民休息），选择了最优秀的接班人霍光，让自己的政策能够执行。 宣帝：民间长大，了解民间疾苦，不搞政治清算，对于霍光的政策能够延续，“汉家自有制度，本以霸王道杂之。奈何纯任德教，用周政乎！”是对于汉朝制度最好的注解，然而儒家没有被关进笼子里，太学制度让儒家成为了大祸。 王莽：乱天下者，儒家理想主义者，糟糕的经济政策，糟糕的豪强政策，加上糟糕的天气，一世而终。 光武：安定天下，豪族投票出的代理人，重新确立儒学的地位，以夷制夷的优秀策略。 曹操：浪漫的诗人和强大的军事家，优秀的政治家，年轻时候想成为大汉的一名优秀官吏，后来讨伐董卓后认清现实，武以涿郡老家的武人集团起兵，后来得到颍川荀彧的加盟，从而确立了文以颍川文人集团，在于袁绍的官渡之战中，在最后关头亲自带5000骑兵攻打乌巢，真英雄自风流。 平定北方，统一了全国80%人口的地方，但是同时造成的破坏也很多，屠戮徐州，迁徙百姓，对于曾经得王佐之才，为了能够以魏代汉，也诛杀了荀彧， 最后曹氏不得善终。 太宗李世民：7世纪地表最强，少年英雄，布局深远，军略上能够洞悉战场的局势，以最小的成本取得最大的战果，政治上以自我的克制造成了清明的政治环境，对于北疆的策略非常高明，作为天可汗，能够集合草原部落去对付不听话的野心家，种种布局，以最小的代价确定了北疆的和平，唯一比较诟病的是对于继承人的策略。 武则天：唐朝衰弱由武氏开始，任用酷吏，破坏政治清明，好大喜功，军事上昏招频出，从而使府兵制衰弱下去，为藩镇割据打好基础。 成大事者，无不历经各种险阻，内修德行，有第一流的克制和自强不息，一心一意，才能得窥第一流的风景。","categories":[{"name":"历史","slug":"历史","permalink":"https://blackforest1990.github.io/categories/%E5%8E%86%E5%8F%B2/"}],"tags":[{"name":"杂记","slug":"杂记","permalink":"https://blackforest1990.github.io/tags/%E6%9D%82%E8%AE%B0/"}]}],"categories":[{"name":"编程","slug":"编程","permalink":"https://blackforest1990.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"历史","slug":"历史","permalink":"https://blackforest1990.github.io/categories/%E5%8E%86%E5%8F%B2/"},{"name":"操作系统","slug":"操作系统","permalink":"https://blackforest1990.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"如何赚钱","slug":"如何赚钱","permalink":"https://blackforest1990.github.io/categories/%E5%A6%82%E4%BD%95%E8%B5%9A%E9%92%B1/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://blackforest1990.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"how to make","slug":"how-to-make","permalink":"https://blackforest1990.github.io/tags/how-to-make/"},{"name":"黄仁宇","slug":"黄仁宇","permalink":"https://blackforest1990.github.io/tags/%E9%BB%84%E4%BB%81%E5%AE%87/"},{"name":"进程管理","slug":"进程管理","permalink":"https://blackforest1990.github.io/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"name":"工作","slug":"工作","permalink":"https://blackforest1990.github.io/tags/%E5%B7%A5%E4%BD%9C/"},{"name":"导论","slug":"导论","permalink":"https://blackforest1990.github.io/tags/%E5%AF%BC%E8%AE%BA/"},{"name":"实用","slug":"实用","permalink":"https://blackforest1990.github.io/tags/%E5%AE%9E%E7%94%A8/"},{"name":"工具书","slug":"工具书","permalink":"https://blackforest1990.github.io/tags/%E5%B7%A5%E5%85%B7%E4%B9%A6/"},{"name":"人物传记","slug":"人物传记","permalink":"https://blackforest1990.github.io/tags/%E4%BA%BA%E7%89%A9%E4%BC%A0%E8%AE%B0/"},{"name":"科幻","slug":"科幻","permalink":"https://blackforest1990.github.io/tags/%E7%A7%91%E5%B9%BB/"},{"name":"杂记","slug":"杂记","permalink":"https://blackforest1990.github.io/tags/%E6%9D%82%E8%AE%B0/"}]}