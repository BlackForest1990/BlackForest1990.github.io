<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>进程同步 | 黑暗森林</title><meta name="author" content="BlackForest1990"><meta name="copyright" content="BlackForest1990"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="合作进程是指可以影响或受其他在系统中执行的进程影响的进程。合作进程可以直接共享逻辑地址空间（即代码和数据），也可以通过文件或消息允许仅共享数据。前一种情况通过使用线程来实现。然而，并发访问共享数据可能导致数据不一致。在本文中，我们讨论确保共享逻辑地址空间的合作进程有序执行的各种机制，以维护数据一致性。 背景 我们将解释并发或并行执行如何导致涉及由多个进程共享的数据完整性的问题。现在我们回到有界缓冲">
<meta property="og:type" content="article">
<meta property="og:title" content="进程同步">
<meta property="og:url" content="https://blackforest1990.github.io/2023/12/11/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/index.html">
<meta property="og:site_name" content="黑暗森林">
<meta property="og:description" content="合作进程是指可以影响或受其他在系统中执行的进程影响的进程。合作进程可以直接共享逻辑地址空间（即代码和数据），也可以通过文件或消息允许仅共享数据。前一种情况通过使用线程来实现。然而，并发访问共享数据可能导致数据不一致。在本文中，我们讨论确保共享逻辑地址空间的合作进程有序执行的各种机制，以维护数据一致性。 背景 我们将解释并发或并行执行如何导致涉及由多个进程共享的数据完整性的问题。现在我们回到有界缓冲">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blackforest1990.github.io/image/blackforest.jpg">
<meta property="article:published_time" content="2023-12-11T02:27:52.000Z">
<meta property="article:modified_time" content="2024-08-15T07:34:15.469Z">
<meta property="article:author" content="BlackForest1990">
<meta property="article:tag" content="进程管理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blackforest1990.github.io/image/blackforest.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blackforest1990.github.io/2023/12/11/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '进程同步',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-15 15:34:15'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="黑暗森林" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/image/blackforest.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="黑暗森林"><span class="site-name">黑暗森林</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">进程同步</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-11T02:27:52.000Z" title="发表于 2023-12-11 10:27:52">2023-12-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-15T07:34:15.469Z" title="更新于 2024-08-15 15:34:15">2024-08-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="进程同步"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>合作进程是指可以影响或受其他在系统中执行的进程影响的进程。合作进程可以直接共享逻辑地址空间（即代码和数据），也可以通过文件或消息允许仅共享数据。前一种情况通过使用线程来实现。然而，并发访问共享数据可能导致数据不一致。在本文中，我们讨论确保共享逻辑地址空间的合作进程有序执行的各种机制，以维护数据一致性。</p>
<h2 id="背景">背景</h2>
<p>我们将解释并发或并行执行如何导致涉及由多个进程共享的数据完整性的问题。现在我们回到有界缓冲区的问题上。我们最初的解决方案在缓冲区中最多允许 BUFFER SIZE - 1 个项同时存在。假设我们想修改算法来解决这个问题。一种可能性是添加一个整数变量 counter，初始化为 0。每次向缓冲区添加一个新项时，counter 增加，并且每次从缓冲区移除一个项时，counter 减少。生产者进程的代码可以修改如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">/* 在 next produced 中生成一个项 */</span></span><br><span class="line">    <span class="keyword">while</span> (counter == BUFFER SIZE)</span><br><span class="line">        ; <span class="comment">/* 什么也不做 */</span></span><br><span class="line">    buffer[in] = next produced;</span><br><span class="line">    in = (in + <span class="number">1</span>) % BUFFER SIZE;</span><br><span class="line">    counter++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费者进程的代码可以修改如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (counter == <span class="number">0</span>)</span><br><span class="line">        ; <span class="comment">/* 什么也不做 */</span></span><br><span class="line">    next consumed = buffer[out];</span><br><span class="line">    out = (out + <span class="number">1</span>) % BUFFER SIZE;</span><br><span class="line">    counter--;</span><br><span class="line">    <span class="comment">/* 在 next consumed 中消费一个项 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管上述的生产者和消费者例程在单独执行时是正确的，但在并发执行时可能无法正常工作。举例说明，假设变量 counter 的值当前为 5，并且生产者和消费者进程同时执行语句 “counter++” 和 “counter–”。在执行这两个语句之后，变量 counter 的值可能是 4、5 或 6！然而，唯一的正确结果是 counter == 5，只有在生产者和消费者分别执行时才能正确生成。</p>
<p>我们可以通过以下方式说明 counter 的值可能不正确。注意语句 “counter++” 在机器语言中可以如下实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">register1 = counter</span><br><span class="line">register1 = register1 + 1</span><br><span class="line">counter = register1</span><br></pre></td></tr></table></figure>
<p>同样，语句 “counter–” 可以如下实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">register2 = counter</span><br><span class="line">register2 = register2 - 1</span><br><span class="line">counter = register2</span><br></pre></td></tr></table></figure>
<p>即使 register1 和 register2 可能是相同的物理寄存器（比如累加器），该寄存器的内容将由中断处理程序保存和恢复。“counter++” 和 “counter–” 的并发执行相当于以某种任意顺序交错执行先前介绍的低级语句的顺序执行（但在每个高级语句内部的顺序被保留）。这样的交错执行可能是以下的其中一种：</p>
<p>T0: producer execute register1 = counter {register1 = 5}<br>
T1: producer execute register1 = register1 + 1 {register1 = 6}<br>
T2: consumer execute register2 = counter {register2 = 5}<br>
T3: consumer execute register2 = register2 − 1 {register2 = 4}<br>
T4: producer execute counter = register1 {counter = 6}<br>
T5: consumer execute counter = register2 {counter = 4}</p>
<p>我们将达到这种不正确的状态是因为我们允许两个进程同时操作变量 counter。这种情况，其中多个进程同时访问和操作相同的数据，并且执行的结果取决于访问发生的具体顺序，被称为<strong>竞态条件</strong>。为了防范上述竞态条件，我们需要确保一次只有一个进程能够操作变量 counter。为了做出这样的保证，我们需要以某种方式同步这些进程。</p>
<h2 id="临界区问题">临界区问题</h2>
<p>首先讨论所谓的临界区问题。考虑一个由 n 个进程 {P0，P1，…，Pn−1} 组成的系统。每个进程都有一段代码，称为临界区，其中进程可能正在更改共享变量、更新表、写文件等。系统的重要特性是，当一个进程正在执行其临界区时，不允许其他进程在其临界区中执行。也就是说，没有两个进程可以同时在其临界区中执行。<strong>临界区问题是设计一个协议，进程可以使用该协议进行合作</strong>。每个进程必须请求进入其临界区的权限。执行此请求的代码部分是入口部分。临界区可能后面跟着一个退出部分。其余代码是剩余部分。</p>
<img src="https://raw.githubusercontent.com/BlackForest1990/Mypic/img/img/临界区问题.png" style="zoom:40%;">
<p>解决临界区问题的解决方案必须满足以下三个要求：</p>
<ol>
<li><strong>互斥性</strong>。如果进程 Pi 正在执行其临界区，则其他进程不能在其临界区中执行。</li>
<li><strong>进展性</strong>。如果没有进程在其临界区中执行，并且有些进程希望进入其临界区，则只有那些<strong>不在其剩余部分中执行的进程</strong>可以参与决定下一个将进入其临界区的进程，而且此选择不能无限期地推迟。</li>
<li><strong>有限等待</strong>。在进程发出请求进入其临界区后，以及在该请求被授予之前，允许其他进程进入其临界区的次数存在一个限制或界限。</li>
</ol>
<p>我们假设每个进程以非零速度执行。然而，我们不能对 n 个进程的相对速度做任何假设。 在某一时刻，操作系统中可能有许多内核模式进程处于活动状态。因此，实现操作系统的内核代码可能存在几种可能的竞争条件。以维护系统中所有打开文件列表的内核数据结构为例。如果两个进程同时打开文件，对此列表的单独更新可能导致竞争条件。其他可能存在竞争条件的内核数据结构包括用于维护内存分配的结构、用于维护进程列表的结构以及用于中断处理的结构。<strong>内核开发人员需要确保操作系统没有这样的竞争条件</strong>。</p>
<p>在操作系统中处理临界区的两种一般方法是：<strong>抢占式内核和非抢占式内核</strong>。抢占式内核允许在内核模式下运行的进程在运行时被抢占。非抢占式内核不允许在内核模式下运行的进程被抢占；内核模式进程将一直运行，直到退出内核模式、阻塞或自愿放弃对CPU的控制。</p>
<p>显然，非抢占式内核基本上不会在内核数据结构上产生竞争条件，因为一次只有一个进程在内核中活动。我们不能说抢占式内核也是如此，因此必须仔细设计以确保共享内核数据不受竞争条件的影响。<strong>对于多处理器架构来说，抢占式内核尤其难以设计</strong>，因为在这些环境中，两个内核模式进程可能同时在不同的处理器上运行。</p>
<p>那么，为什么有人会选择抢占式内核呢？抢占式内核可能更具响应性，因为在内核模式下运行的进程在放弃处理器给等待中的进程之前有较小的风险在任意长的时间内运行。当然，通过设计不会以这种方式行为的内核代码，也可以将此风险最小化。此外，抢占式内核更适用于实时编程，因为它允许实时进程抢占当前在内核中运行的进程。</p>
<h2 id="彼得森解法">彼得森解法</h2>
<p>由于现代计算机架构执行基本的机器语言指令（如加载和存储）的方式，Peterson解法在这些架构上不能保证正确运行。然而，我们还是介绍这个解决方案，因为它提供了解决关键区问题的良好算法描述，并展示了设计满足互斥、进展和有限等待要求的软件所涉及的一些复杂性。</p>
<p><strong>Peterson解法仅适用于两个进程，它们在它们的关键区和剩余区之间交替执行</strong>。这两个进程分别编号为P0和P1。为了方便起见，在表示Pi时，我们使用Pj来表示另一个进程，即j = 1−i。</p>
<p>Peterson解法要求这两个进程共享两个数据项：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> turn;</span><br><span class="line">boolean flag[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<p>变量<code>turn</code>表示轮到谁进入关键区。也就是说，如果<code>turn == i</code>，则允许进程Pi在其关键区执行。数组<code>flag</code>用于指示一个进程是否准备好进入其关键区。例如，如果<code>flag[i]</code>为true，则表示Pi准备好进入其关键区。</p>
<img src="https://raw.githubusercontent.com/BlackForest1990/Mypic/img/img/peterson算法.PNG" style="zoom:40%;">
<p>为了进入关键区，进程Pi首先将<code>flag[i]</code>设置为true，然后将<code>turn</code>设置为j的值，从而断言如果另一个进程希望进入关键区，它可以这样做。如果两个进程同时尝试进入，<code>turn</code>将大致同时设置为i和j。只有一个赋值将持续；另一个将发生但将立即被覆盖。<code>turn</code>的最终值确定了这两个进程中哪一个被允许首先进入其关键区。</p>
<p>需要满足以下几个前提条件：</p>
<p>● 进程必须能够独立地执行，并且它们之间可以相互干扰。</p>
<p>● 进程必须可以共享一些公共变量。</p>
<p>● 进程之间的速度可以不同，但不能有任何假设。</p>
<p>这个算法的一个限制是它只适用于两个进程之间的情况。在有多个进程需要互斥访问共享资源的情况下，需要采用其他算法或技术来解决。</p>
<h2 id="同步硬件">同步硬件</h2>
<p>我们刚刚描述了解决临界区问题的一种基于软件的方法。然而，正如前面提到的，像Peterson这样的基于软件的解决方案在现代计算机体系结构上不能保证正常工作。在接下来的讨论中，我们将探讨解决临界区问题的几种更多方法，涉及从硬件到软件的 API 技术，这些技术对内核开发人员和应用程序员都是可用的。所有这些解决方案都基于锁的概念——即通过使用锁来保护关键区域。正如我们将看到的，这些锁的设计可能非常复杂。</p>
<p>我们首先介绍一些简单的硬件指令，这些指令在许多系统上都可用，并展示它们如何有效地解决临界区问题。硬件特性可以使任何编程任务变得更加容易，并提高系统效率。如果我们能够在修改共享变量时阻止中断，那么在单处理器环境中就可以简单地解决临界区问题。这样，我们可以确保当前的指令序列将被允许按顺序执行而不会被抢占。不会运行其他指令，因此不会对共享变量进行意外的修改。这通常是非抢占内核采用的方法。不幸的是，在多处理器环境中，禁用中断可能会很耗时，因为消息会传递到所有处理器。这种消息传递延迟了进入每个关键区的时间，降低了系统效率。还要考虑系统时钟如果通过中断保持更新的影响。</p>
<p>因此，许多现代计算机系统提供了特殊的硬件指令，允许我们测试和修改一个字的内容，或原子地交换两个字的内容——即作为一个不可中断的单元。我们可以使用这些特殊指令以相对简单的方式解决临界区问题。我们通过描述测试与设置（test and set()）和比较与交换（compare and swap()）指令来抽象这些指令背后的主要概念，而不是讨论某个具体机器的某个具体指令。</p>
<h2 id="自旋锁">自旋锁</h2>
<p>基于硬件的解决方案对于应用程序员来说通常很复杂且难以访问。相反，操作系统设计者构建软件工具来解决临界区问题。其中最简单的工具之一是互斥锁（mutex lock）。实际上，“mutex”一词是“mutual exclusion”的缩写。我们使用互斥锁来保护临界区，从而防止竞态条件。也就是说，进程必须在进入临界区之前获取锁；当退出临界区时释放锁。<code>acquire()</code>函数用于获取锁，<code>release()</code>函数用于释放锁。</p>
<img src="https://raw.githubusercontent.com/BlackForest1990/Mypic/img/img/互斥锁.PNG" style="zoom:40%;">
<p>互斥锁有一个布尔变量<code>available</code>，其值指示锁是否可用。如果锁可用，对<code>acquire()</code>的调用成功，并且然后将锁视为不可用。试图获取不可用锁的进程将被阻塞，直到锁被释放。</p>
<p><code>acquire()</code>的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">acquire() &#123;</span><br><span class="line">    <span class="keyword">while</span> (!available)</span><br><span class="line">        ; <span class="comment">/* 忙等待 */</span></span><br><span class="line">    available = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>release()</code>的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">release() &#123;</span><br><span class="line">    available = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对<code>acquire()</code>或<code>release()</code>的调用必须以原子方式执行。主要缺点是它需要忙等待。当一个进程处于其临界区时，任何尝试进入其临界区的其他进程必须在调用<code>acquire()</code>时不断循环。事实上，<strong>这种类型的互斥锁也称为自旋锁</strong>，因为进程在等待锁变得可用时会“旋转”。这种持续循环在真正的多编程系统中显然是个问题，其中一个单独的 CPU 在许多进程之间共享。忙等待浪费了 CPU 周期，其他一些进程可能能够有效地使用。</p>
<p>然而，自旋锁也有一个优点，即在进程必须等待锁时不需要进行上下文切换，而上下文切换可能需要很长时间。因此，当预计锁将被持有的时间很短时，自旋锁是有用的。<strong>它们通常用于多处理器系统</strong>，其中一个线程可以在一个处理器上“旋转”，而另一个线程在另一个处理器上执行其临界区。</p>
<h2 id="信号量">信号量</h2>
<p>可以把信号量看成一个对象</p>
<ul>
<li>一个整数变量</li>
<li>一个等待进程的链表</li>
<li>两个原子方法wait() 和 signal()</li>
</ul>
<p>信号量（Semaphore）S 是一个整数变量，除了初始化之外，只能通过两个标准的原子操作进行访问：wait() 和 signal()。wait() 操作最初被称为 P；signal() 最初被称为 V。wait() 的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wait(S) &#123;</span><br><span class="line">    <span class="keyword">while</span> (S &lt;= <span class="number">0</span>)</span><br><span class="line">        S--;; <span class="comment">// 忙等待</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>signal() 的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">signal(S) &#123;</span><br><span class="line">    S++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 wait() 和 signal() 操作中对信号量的整数值的所有修改都必须是不可分割的。也就是说，当一个进程修改信号量值时，没有其他进程可以同时修改相同的信号量值。此外，在 wait(S) 的情况下，对 S 的整数值的测试（S ≤ 0）以及可能的修改（S–）必须在没有中断的情况下执行。</p>
<h3 id="信号量的使用">信号量的使用</h3>
<p><strong>操作系统通常区分计数信号量和二进制信号量</strong>。计数信号量的值可以在无限的域内变化。二进制信号量的值只能在0和1之间变化。因此，二进制信号量的行为类似于互斥锁。实际上，在不提供互斥锁的系统上，可以使用二进制信号量来提供互斥。</p>
<p>计数信号量可以用于控制对由有限数量实例组成的特定资源的访问。信号量被初始化为可用资源的数量。每个想要使用资源的进程都执行对信号量的 wait() 操作（从而减少计数）。当进程释放资源时，它执行 signal() 操作（增加计数）。当信号量的计数变为0时，所有资源都被使用。在此之后，想要使用资源的进程将被阻塞，直到计数变得大于0。</p>
<p>我们还可以使用信号量来解决各种同步问题。例如，考虑两个并发运行的进程：P1 具有语句 S1，P2 具有语句 S2。假设我们要求只有在 S1 完成后才能执行 S2。我们可以通过让 P1 和 P2 共享一个初始值为0的信号量 synch 来轻松实现这个方案。在进程 P1 中，我们插入以下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S1;</span><br><span class="line">signal(synch);</span><br></pre></td></tr></table></figure>
<p>在进程 P2 中，我们插入以下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wait(synch);</span><br><span class="line">S2;</span><br></pre></td></tr></table></figure>
<p>因为 synch 被初始化为0，所以只有在 P1 调用 signal(synch) 之后（也就是在语句 S1 执行后），P2 才会执行 S2。</p>
<h3 id="信号量的实现">信号量的实现</h3>
<p>为了克服<strong>忙等待</strong>的需要，我们可以修改 wait() 和 signal() 操作的定义如下：当一个进程执行 wait() 操作并发现信号量值不是正数时，它必须等待。然而，与其忙等待，该进程可以自我阻塞。<strong>阻塞操作将一个进程放入与信号量关联的等待队列中</strong>，并将进程的状态切换到等待状态。然后控制被传递给 CPU 调度程序，该程序选择另一个进程执行。</p>
<p>一个被阻塞在等待信号量 S 上的进程应该在另一个进程执行 signal() 操作时重新启动。进程通过 wakeup() 操作重新启动，该操作将进程从等待状态更改为就绪状态。然后，将进程放入就绪队列中。（根据 CPU 调度算法，可能或可能不会从运行中的进程切换到新的就绪进程。）</p>
<p>为了在这个定义下实现信号量，我们将信号量定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">list</span>;</span></span><br><span class="line">&#125; semaphore;</span><br></pre></td></tr></table></figure>
<p>每个信号量都有一个整数值和一个进程列表。当一个进程必须等待信号量时，它被添加到进程列表中。signal() 操作从等待进程列表中删除一个进程并唤醒该进程。</p>
<p>现在，wait() 信号量操作可以定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wait(semaphore *S) &#123;</span><br><span class="line">    S-&gt;value--;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        add this process to S-&gt;<span class="built_in">list</span>;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>signal() 信号量操作可以定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">signal(semaphore *S) &#123;</span><br><span class="line">    S-&gt;value++;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        remove a process P from S-&gt;<span class="built_in">list</span>;</span><br><span class="line">        wakeup(P);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>阻塞操作挂起调用它的进程。唤醒操作恢复一个被阻塞的进程 P。这两个操作由操作系统作为基本系统调用提供。请注意，在这个实现中，信号量的值可能是负数，而在具有忙等待的信号量的经典定义下，信号量的值永远不会是负数。如果信号量的值是负数，那么它的大小是等待该信号量的进程数。这是由于在 wait() 操作的实现中切换了减法和测试的顺序。</p>
<p><strong>等待进程列表可以通过每个进程控制块（PCB）中的链接字段轻松实现</strong>。每个信号量包含一个整数值和指向 PCB 列表的指针。为了确保有界等待，可以使用 FIFO 队列的方式添加和删除进程，其中信号量包含队列的头指针和尾指针。然而，通常情况下，列表可以使用任何排队策略。信号量列表的正确使用不依赖于信号量列表的特定排队策略。</p>
<p>信号量操作必须以原子方式执行是至关重要的。我们必须确保没有两个进程可以同时在同一个信号量上执行 wait() 和 signal() 操作。这是一个关键部分问题；<strong>在单处理器环境中，我们可以通过在执行 wait() 和 signal() 操作时简单地禁用中断来解决它</strong>。这个方案在单处理器环境中有效，因为一旦中断被禁用，不同进程的指令就不能交错执行。只有当前运行的进程执行，直到重新启用中断，调度程序才能重新获得控制。</p>
<p>在多处理器环境中，必须在每个处理器上禁用中断。否则，来自不同处理器的进程（在不同处理器上运行）的指令可能以任意的方式交错。<strong>在每个处理器上禁用中断可能是一项困难的任务，并且可能严重降低性能</strong>。因此，SMP 系统必须提供替代的锁定技术——例如 compare and swap() 或自旋锁（spinlocks）——以确保 wait() 和 signal() 的原子执行。</p>
<p>重要的是要承认，通过这种对 wait() 和 signal() 操作的定义，<strong>我们并没有完全消除忙等待</strong>。相反，我们将忙等待从进程应用程序的入口部分移到了关键部分。此外，我们将忙等待限制在 wait() 和 signal() 操作的关键部分，而这些部分是短暂的（如果编写正确，它们应该不超过大约十条指令）。</p>
<h3 id="死锁和饥饿">死锁和饥饿</h3>
<p>使用等待队列实现的信号量可能导致两个或更多进程无限期等待仅由等待进程之一引起的事件。所涉及的事件是执行 signal() 操作。当达到这种状态时，这些进程被称为<strong>死锁</strong>。为了说明这一点，考虑一个由两个进程 P0 和 P1 组成的系统，每个进程都访问两个信号量 S 和 Q，它们的初始值均为 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">P0                      P1</span><br><span class="line">wait(S);                wait(Q);</span><br><span class="line">wait(Q);                wait(S);</span><br><span class="line">.                       .</span><br><span class="line">.                       .</span><br><span class="line">.                       .</span><br><span class="line">signal(S);              signal(Q);</span><br><span class="line">signal(Q);              signal(S);</span><br></pre></td></tr></table></figure>
<p>假设 P0 执行 wait(S)，然后 P1 执行 wait(Q)。当 P0 执行 wait(Q) 时，它必须等待 P1 执行 signal(Q)。同样，当 P1 执行 wait(S) 时，它必须等待 P0 执行 signal(S)。由于这些 signal() 操作无法执行，P0 和 P1 陷入了死锁。</p>
<p><strong>当一个进程集合中的每个进程都在等待只能由该集合中的另一个进程引起的事件时，我们说该进程集合处于死锁状态</strong>。这里我们主要关注的事件是资源的获取和释放。与死锁相关的另一个问题是无限阻塞或饥饿，<strong>即进程在信号量中无限期等待的情况</strong>。如果我们以后进先出（LIFO，last-in, first-out）的顺序从与信号量关联的列表中移除进程，那么可能会发生无限阻塞。</p>
<h3 id="优先级反转">优先级反转</h3>
<p>当一个更高优先级的进程需要读取或修改当前由一个低优先级进程（或一系列低优先级进程）访问的内核数据时，就会出现调度的挑战。由于内核数据通常受到锁的保护，更高优先级的进程将不得不等待低优先级进程完成对资源的使用。如果低优先级进程被抢占，让步给优先级更高的进程，情况就变得更加复杂。</p>
<p>例如，假设我们有三个进程L、M和H，它们的优先级按照 L &lt; M &lt; H 的顺序。假设进程H需要资源R，而该资源当前正在被进程L访问。通常情况下，进程H会等待L完成对资源R的使用。但是，现在假设进程M变为可运行状态，从而抢占了进程L。间接地，一个具有较低优先级的进程（进程M）影响了进程H等待L放弃资源R的时间。</p>
<p>这个问题被称为优先级反转。它只会在具有两个以上优先级的系统中发生，因此一种解决方案是只有两个优先级。然而，对于大多数通用操作系统来说，这是不够的。通常，这些系统通过实现优先级继承协议来解决这个问题。<strong>根据该协议，所有正在访问由更高优先级进程需要的资源的进程都会继承更高的优先级，直到它们完成对这些资源的使用</strong>。当它们完成后，它们的优先级将恢复到原始值。在上面的例子中，优先级继承协议将允许进程L暂时继承进程H的优先级，从而防止进程M抢占其执行。当进程L完成对资源R的使用后，它将放弃从H继承的优先级并恢复为其原始优先级。由于资源R现在可用，接下来运行的将是进程H，而不是M。</p>
<h2 id="经典的同步问题">经典的同步问题</h2>
<h3 id="有界缓冲问题（Bounded-Buffer-Problem）">有界缓冲问题（Bounded-Buffer Problem）</h3>
<p>在生产者-消费者模型中，有一个有界的缓冲区，生产者将数据放入缓冲区，而消费者从中取出数据。问题在于要保证在缓冲区满或空的情况下，生产者和消费者能够正确地进行同步，避免溢出或下溢。</p>
<p>在有界缓冲问题中，我们有N个缓冲区，每个缓冲区可以容纳一个项。</p>
<p>为了解决这个问题，我们需要以下信号量：</p>
<ol>
<li>mutex：用于保护对缓冲区的访问，防止多个进程同时访问。初始值为1，表示最初是可用的。</li>
<li>full：用于记录当前有多少个缓冲区已经被占用（即已经放入了项）。初始值为0。</li>
<li>empty：用于记录当前还有多少个缓冲区是空的（即可以放入项）。初始值为N，表示所有缓冲区都是空的。</li>
</ol>
<p>这样，通过合理地使用这三个信号量，我们可以实现多个生产者和消费者正确、安全地访问缓冲区。</p>
<p>生产者进程结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    . . .</span><br><span class="line">    <span class="comment">/* produce an item in next produced */</span></span><br><span class="line">    . . .</span><br><span class="line">    wait(empty);</span><br><span class="line">    wait(mutex);</span><br><span class="line">    . . .</span><br><span class="line">    <span class="comment">/* add next produced to the buffer */</span></span><br><span class="line">    . . .</span><br><span class="line">    signal(mutex);</span><br><span class="line">    signal(full);</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>消费者进程结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    wait(full);</span><br><span class="line">    wait(mutex);</span><br><span class="line">    . . .</span><br><span class="line">    <span class="comment">/* remove an item from buffer to next consumed */</span></span><br><span class="line">    . . .</span><br><span class="line">    signal(mutex);</span><br><span class="line">    signal(empty);</span><br><span class="line">    . . .</span><br><span class="line">    <span class="comment">/* consume the item in next consumed */</span></span><br><span class="line">    . . .</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<h3 id="读者-写者问题（Readers-and-Writers-Problem）">读者-写者问题（Readers and Writers Problem）</h3>
<p>假设一个数据库需要被多个并发进程共享。其中一些进程可能只想读取数据库，而其他一些可能想要更新数据库。我们通过将前者称为读者，将后者称为写者来区分这两种类型的进程。显然，如果两个读者同时访问共享数据，不会产生不良影响。然而，如果一个写者和另一个进程（无论是读者还是写者）同时访问数据库，可能会导致混乱。</p>
<p><strong>为了确保这些困扰不会出现，我们要求写者在写入数据库时具有对共享数据库的独占访问权</strong>。这个同步问题被称为读者-写者问题。自从最初提出以来，它一直被用来测试几乎每个新的同步原语。读者-写者问题有几个变种，都涉及到优先级。最简单的一个，<strong>被称为第一个读者-写者问题，要求在写者已经获得使用共享对象的许可之前，不应使读者等待</strong>。换句话说，没有读者应该因为有写者在等待而等待其他读者完成。<strong>第二个读者-写者问题要求一旦写者准备好，就应该尽快执行其写操作</strong>。换句话说，如果一个写者正在等待访问对象，那么新的读者就不能开始读取。在第一种情况下，写者可能会饿死；在第二种情况下，读者可能会饿死。</p>
<p>在解决第一个读者-写者问题的方案中，读者进程共享以下数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw_mutex = <span class="number">1</span>;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> read_count = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>信号量 <code>rw_mutex</code> 和 <code>mutex</code> 被初始化为 1；<code>read_count</code> 被初始化为 0。<code>rw_mutex</code> 信号量对读者和写者进程都是共享的。<code>mutex</code> 信号量用于在更新变量 <code>read_count</code> 时确保互斥。变量 <code>read_count</code> 用于跟踪当前正在读取对象的进程数量。<code>rw_mutex</code> 信号量用作写者的互斥信号量。它还由第一个或最后一个进入或退出关键部分的读者使用。它不被在其他读者处于其关键部分时进入或退出的读者使用。</p>
<p>请注意，如果一个写者在关键部分中，有 n 个读者在等待，那么一个读者排队在 <code>rw_mutex</code> 上，而 n - 1 个读者排队在 <code>mutex</code> 上。还请注意，当一个写者执行 <code>signal(rw_mutex)</code> 时，我们可能会恢复等待的读者或一个等待的写者的执行。选择由调度程序做出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">writer:</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    wait(rw_mutex);</span><br><span class="line">    . . .</span><br><span class="line">    <span class="comment">/* writing is performed */</span></span><br><span class="line">    . . .</span><br><span class="line">    signal(rw_mutex);</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">Reader:</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    wait(mutex);</span><br><span class="line">    read count++;</span><br><span class="line">    <span class="keyword">if</span> (read_count == <span class="number">1</span>)</span><br><span class="line">        wait(rw_mutex);</span><br><span class="line">        signal(mutex);</span><br><span class="line">        . . .</span><br><span class="line">        <span class="comment">/* reading is performed */</span></span><br><span class="line">        . . .</span><br><span class="line">        wait(mutex);</span><br><span class="line">        read_count--;</span><br><span class="line">    <span class="keyword">if</span> (read_count == <span class="number">0</span>)</span><br><span class="line">        signal(rw_mutex);</span><br><span class="line">        signal(mutex);</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>读者-写者问题及其解决方案已经推广为在某些系统上提供读者-写者锁。获取读者-写者锁需要指定锁的模式：读取或写入访问。当一个进程只想读取共享数据时，它以读取模式请求读者-写者锁。希望修改共享数据的进程必须以写入模式请求锁。多个进程可以同时以读取模式获取读者-写者锁，但只有一个进程可以以写入模式获取锁，因为写者需要独占访问权限。</p>
<p>读者-写者锁在以下情况下最为有用：</p>
<ul>
<li>在应用程序中很容易确定哪些进程仅读取共享数据，哪些进程仅写入共享数据。</li>
<li>在具有比写者或互斥锁更多读者的应用程序中。这是因为读者-写者锁通常需要更多的开销来建立，比信号量或互斥锁多。允许多个读者同时进行提高了允许并发的能力，以弥补设置读者-写者锁的开销。</li>
</ul>
<h3 id="哲学家就餐问题（Dining-Philosophers-Problem）">哲学家就餐问题（Dining-Philosophers Problem）</h3>
<p>在这个问题中，有五位哲学家坐在圆桌前，每位哲学家之间有一根筷子，共有五根筷子。哲学家可以进行思考或就餐，但只有同时拿到左右两根筷子时才能吃饭。</p>
<p>数据结构:</p>
<ul>
<li>一个装有米饭的碗（数据集）</li>
<li>五根筷子的信号量数组 chopstick[5]，初始化为1，表示每根筷子最初可用。</li>
</ul>
<p>哲学家的行为规则如下：</p>
<ol>
<li>当一个哲学家想要进餐时，他必须先拿起他左边的筷子，然后拿起他右边的筷子，才能开始进餐。</li>
<li>进餐完毕后，他会先放下右边的筷子，再放下左边的筷子，然后继续思考。</li>
</ol>
<p>为了解决哲学家就餐问题，可以使用信号量来控制筷子的访问。当一个哲学家想要拿起筷子时，他会先等待两根筷子都可用，然后将它们标记为不可用，以防止其他哲学家同时取用同一根筷子。</p>
<p>这个问题的解决方案需要巧妙地使用信号量来保证哲学家们可以安全地就餐，同时避免死锁等问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    wait(chopstick[i]);</span><br><span class="line">    wait(chopstick[(i+<span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">    . . .</span><br><span class="line">    <span class="comment">/* eat for awhile */</span></span><br><span class="line">    . . .</span><br><span class="line">    signal(chopstick[i]);</span><br><span class="line">    signal(chopstick[(i+<span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">    . . .</span><br><span class="line">    <span class="comment">/* think for awhile */</span></span><br><span class="line">    . . .</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<h2 id="同步案例">同步案例</h2>
<h3 id="Linux">Linux</h3>
<p>在 Linux 的 Version 2.6 之前，Linux 内核是非抢占式的，这意味着在内核模式下运行的进程即使有更高优先级的进程可运行也不能被抢占。然而，现在的 Linux 内核是完全抢占式的，因此当一个任务在内核中运行时可以被抢占。</p>
<p>Linux 提供了内核中的多种不同的同步机制。由于大多数计算机体系结构都提供了原子版本的简单数学操作的指令，因此在 Linux 内核中最简单的同步技术是原子整数，它使用不透明的数据类型 <code>atomic_t</code> 表示。正如其名称所示，使用原子整数的所有数学操作都是无中断的。以下代码演示了声明一个原子整数计数器并执行各种原子操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">atomic_t</span> counter;</span><br><span class="line"><span class="type">int</span> value;</span><br><span class="line"><span class="type">atomic_set</span>(&amp;counter, <span class="number">5</span>);       <span class="comment">/* counter = 5 */</span></span><br><span class="line"><span class="type">atomic_add</span>(<span class="number">10</span>, &amp;counter);      <span class="comment">/* counter = counter + 10 */</span></span><br><span class="line"><span class="type">atomic_sub</span>(<span class="number">4</span>, &amp;counter);       <span class="comment">/* counter = counter - 4 */</span></span><br><span class="line"><span class="type">atomic_inc</span>(&amp;counter);          <span class="comment">/* counter = counter + 1 */</span></span><br><span class="line">value = <span class="type">atomic_read</span>(&amp;counter); <span class="comment">/* value = 12 */</span></span><br></pre></td></tr></table></figure>
<p>原子整数在需要更新<strong>整数变量</strong>（如计数器）的情况下特别高效，因为原子操作不需要锁定机制的开销。然而，它们的使用仅限于这些场景。在存在多个变量可能导致竞态条件的情况下，必须使用更复杂的锁定工具。</p>
<p>在 Linux 中，提供了用于保护内核中关键部分的互斥锁。在这里，任务在进入关键部分之前必须调用 <code>mutex_lock()</code> 函数，而在退出关键部分后必须调用 <code>mutex_unlock()</code> 函数。如果互斥锁不可用，调用 <code>mutex_lock()</code> 的任务将进入睡眠状态，并在锁的所有者调用 <code>mutex_unlock()</code> 时被唤醒。</p>
<p>Linux 还为内核提供自旋锁和信号量（以及这两种锁的读写版本）用于内核中的锁定。在 SMP（对称多处理）机器上，基本的锁定机制是自旋锁，并且内核被设计成仅在短时间内保持自旋锁。在单处理器机器上，例如仅有一个处理核心的嵌入式系统，自旋锁不适用并被启用和禁用内核抢占来替代。换句话说，在单处理器系统上，内核禁用内核抢占而不是持有自旋锁，然后启用内核抢占而不是释放自旋锁。总结如下：</p>
<img src="https://raw.githubusercontent.com/BlackForest1990/Mypic/img/img/Linux.PNG" style="zoom:40%;">
<p>Linux 采用了一种有趣的方法来禁用和启用内核抢占。它提供了两个简单的系统调用——<code>preempt_disable()</code> 和 <code>preempt_enable()</code>——用于禁用和启用内核抢占。但是，如果运行在内核中的任务持有锁，则内核是不可抢占的。为了强制执行这一规则，系统中的每个任务都有一个包含计数器 <code>preempt_count</code> 的线程信息结构，用于指示任务持有的锁的数量。当获取锁时，<code>preempt_count</code> 递增，释放锁时递减。如果当前在内核中运行的任务的 <code>preempt_count</code> 值大于 0，则不能安全地抢占内核，因为此任务当前持有锁。如果计数为 0，则内核可以安全地被中断（假设没有未完成的对 <code>preempt_disable()</code> 的调用）。<strong>自旋锁以及启用和禁用内核抢占仅在必须短时间内保持锁时在内核中使用。当需要长时间持有锁时，信号量或互斥锁适合使用</strong>。</p>
<p>Linux内核的同步技术：</p>
<img src="https://raw.githubusercontent.com/BlackForest1990/Mypic/img/img/image-20240815153320394.png" alt="image-20240815153320394" style="zoom:50%;">
<h3 id="Pthreads同步">Pthreads同步</h3>
<p>尽管Solaris中使用的锁定机制对用户级线程和内核线程都可用，但基本上讨论的同步方法涉及内核内的同步。相比之下，Pthreads API可用于用户级别的程序员，不属于任何特定的内核。该API为线程同步提供了互斥锁、条件变量和读-写锁。互斥锁代表了Pthreads中使用的基本同步技术。互斥锁用于保护代码的临界部分，即线程在进入临界部分之前获取锁，在退出临界部分时释放锁。Pthreads使用pthread_mutex_t数据类型表示互斥锁。可以使用pthread_mutex_init()函数创建互斥锁。第一个参数是指向互斥锁的指针。通过将第二个参数设置为NULL，我们将互斥锁初始化为其默认属性。下面是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">/* 创建互斥锁 */</span></span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>互斥锁通过pthread_mutex_lock()和pthread_mutex_unlock()函数获取和释放。如果在调用pthread_mutex_lock()时互斥锁不可用，调用线程将被阻塞，直到所有者调用pthread_mutex_unlock()。以下代码示例说明了使用互斥锁保护临界部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取互斥锁 */</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="comment">/* 临界部分 */</span></span><br><span class="line"><span class="comment">/* 释放互斥锁 */</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure>
<p>所有互斥锁函数在正确操作时返回0；如果发生错误，则这些函数返回非零错误代码。</p>
<p>许多实现Pthreads的系统也提供信号量，尽管信号量不是Pthreads标准的一部分，而是属于POSIX SEM扩展。POSIX规定了两种类型的信号量 - 命名和未命名。两者之间的基本区别在于，命名信号量在文件系统中有一个实际的名称，并且可以被多个无关的进程共享。未命名信号量只能由属于同一进程的线程使用。在本节中，我们描述未命名信号量。</p>
<p>下面的代码示例演示了用于创建和初始化未命名信号量的sem_init()函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">sem_t</span> sem;</span><br><span class="line"><span class="comment">/* 创建信号量并将其初始化为1 */</span></span><br><span class="line">sem_init(&amp;sem, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>sem_init()函数传递了三个参数：</p>
<ol>
<li>信号量的指针</li>
<li>表示共享级别的标志</li>
<li>信号量的初始值 在此示例中，通过传递标志0，我们表示该信号量只能由创建信号量的进程的线程共享。非零值将允许其他进程也访问该信号量。此外，我们将信号量初始化为值1。</li>
</ol>
<p>我们描述了经典的wait()和signal()信号量操作。Pthreads将这些操作命名为sem_wait()和sem_post()。以下代码示例说明了使用上述创建的信号量保护临界部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取信号量 */</span></span><br><span class="line">sem_wait(&amp;sem);</span><br><span class="line"><span class="comment">/* 临界部分 */</span></span><br><span class="line"><span class="comment">/* 释放信号量 */</span></span><br><span class="line">sem_post(&amp;sem);</span><br></pre></td></tr></table></figure>
<p>与互斥锁一样，所有信号量函数在成功时返回0，在发生错误条件时返回非零值。</p>
<p>Pthreads API还有其他扩展，包括自旋锁，但重要的是要注意，并非所有扩展都被认为在一个实现中可以从另一个实现中移植。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blackforest1990.github.io">BlackForest1990</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blackforest1990.github.io/2023/12/11/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/">https://blackforest1990.github.io/2023/12/11/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blackforest1990.github.io" target="_blank">黑暗森林</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">进程管理</a></div><div class="post_share"><div class="social-share" data-image="/image/blackforest.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>谢谢支持</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechatpay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechatpay.jpg"/></a><div class="post-qr-code-desc"></div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/01/03/CPU%E8%B0%83%E5%BA%A6/" title="CPU调度"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">CPU调度</div></div></a></div><div class="next-post pull-right"><a href="/2023/12/05/%E7%BA%BF%E7%A8%8B/" title="线程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">线程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/01/03/CPU%E8%B0%83%E5%BA%A6/" title="CPU调度"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-01-19</div><div class="title">CPU调度</div></div></a></div><div><a href="/2024/02/19/deadlock/" title="deadlock"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-02-19</div><div class="title">deadlock</div></div></a></div><div><a href="/2023/12/05/%E7%BA%BF%E7%A8%8B/" title="线程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-08-12</div><div class="title">线程</div></div></a></div><div><a href="/2023/11/28/%E8%BF%9B%E7%A8%8B/" title="进程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-08-12</div><div class="title">进程</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA%E9%97%AE%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">临界区问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%BC%E5%BE%97%E6%A3%AE%E8%A7%A3%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">彼得森解法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E7%A1%AC%E4%BB%B6"><span class="toc-number">4.</span> <span class="toc-text">同步硬件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">5.</span> <span class="toc-text">自旋锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">6.</span> <span class="toc-text">信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">6.1.</span> <span class="toc-text">信号量的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.2.</span> <span class="toc-text">信号量的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%92%8C%E9%A5%A5%E9%A5%BF"><span class="toc-number">6.3.</span> <span class="toc-text">死锁和饥饿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E5%8F%8D%E8%BD%AC"><span class="toc-number">6.4.</span> <span class="toc-text">优先级反转</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E7%9A%84%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-number">7.</span> <span class="toc-text">经典的同步问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E7%95%8C%E7%BC%93%E5%86%B2%E9%97%AE%E9%A2%98%EF%BC%88Bounded-Buffer-Problem%EF%BC%89"><span class="toc-number">7.1.</span> <span class="toc-text">有界缓冲问题（Bounded-Buffer Problem）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98%EF%BC%88Readers-and-Writers-Problem%EF%BC%89"><span class="toc-number">7.2.</span> <span class="toc-text">读者-写者问题（Readers and Writers Problem）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98%EF%BC%88Dining-Philosophers-Problem%EF%BC%89"><span class="toc-number">7.3.</span> <span class="toc-text">哲学家就餐问题（Dining-Philosophers Problem）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%A1%88%E4%BE%8B"><span class="toc-number">8.</span> <span class="toc-text">同步案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux"><span class="toc-number">8.1.</span> <span class="toc-text">Linux</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pthreads%E5%90%8C%E6%AD%A5"><span class="toc-number">8.2.</span> <span class="toc-text">Pthreads同步</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By BlackForest1990</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">如果只允许一种声音存在，那么，唯一存在的那个声音就是谎言。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>