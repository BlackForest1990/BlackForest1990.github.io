<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>线程 | 黑暗森林</title><meta name="author" content="BlackForest1990"><meta name="copyright" content="BlackForest1990"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="线程 几乎所有现代操作系统都提供了使进程能够包含多个控制线程的功能。我们引入了与多线程计算机系统相关的许多概念，包括对Pthreads和Java线程库的API的讨论。我们探讨了与多线程编程及其对操作系统设计的影响相关的许多问题。最后，我们探讨了Linux操作系统如何在内核级别支持线程。 概述 线程是CPU利用的基本单位；它包括线程ID、程序计数器、寄存器集和堆栈。它与属于同一进程的其他线程共享代码">
<meta property="og:type" content="article">
<meta property="og:title" content="线程">
<meta property="og:url" content="https://blackforest1990.github.io/2023/12/05/%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="黑暗森林">
<meta property="og:description" content="线程 几乎所有现代操作系统都提供了使进程能够包含多个控制线程的功能。我们引入了与多线程计算机系统相关的许多概念，包括对Pthreads和Java线程库的API的讨论。我们探讨了与多线程编程及其对操作系统设计的影响相关的许多问题。最后，我们探讨了Linux操作系统如何在内核级别支持线程。 概述 线程是CPU利用的基本单位；它包括线程ID、程序计数器、寄存器集和堆栈。它与属于同一进程的其他线程共享代码">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blackforest1990.github.io/image/blackforest.jpg">
<meta property="article:published_time" content="2023-12-05T07:40:18.000Z">
<meta property="article:modified_time" content="2024-08-12T07:39:11.757Z">
<meta property="article:author" content="BlackForest1990">
<meta property="article:tag" content="进程管理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blackforest1990.github.io/image/blackforest.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blackforest1990.github.io/2023/12/05/%E7%BA%BF%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '线程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-12 15:39:11'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="黑暗森林" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/image/blackforest.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="黑暗森林"><span class="site-name">黑暗森林</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">线程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-05T07:40:18.000Z" title="发表于 2023-12-05 15:40:18">2023-12-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-12T07:39:11.757Z" title="更新于 2024-08-12 15:39:11">2024-08-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="线程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>线程</h1>
<p>几乎所有现代操作系统都提供了使进程能够包含多个控制线程的功能。我们引入了与多线程计算机系统相关的许多概念，包括对Pthreads和Java线程库的API的讨论。我们探讨了与多线程编程及其对操作系统设计的影响相关的许多问题。最后，我们探讨了Linux操作系统如何在内核级别支持线程。</p>
<h2 id="概述">概述</h2>
<p>线程是CPU利用的基本单位；它包括线程ID、程序计数器、寄存器集和堆栈。它与属于同一进程的其他线程共享代码段、数据段和其他操作系统资源，如打开的文件和信号。传统（或重量级）进程具有单一的控制线程。如果一个进程具有多个控制线程，它可以同时执行多个任务。下图说明了传统的单线程进程和多线程进程之间的区别。</p>
<img src="https://raw.githubusercontent.com/BlackForest1990/Mypic/img/img/单线程和多线程进程.PNG" style="zoom:40%;">
<h3 id="动机">动机</h3>
<p><strong>一个应用程序通常被实现为一个独立的进程，拥有多个控制线程</strong>。例如，一个网络浏览器可能有一个线程显示图像或文本，一个线程从网络检索数据。一个文字处理软件可能有一个用于显示图形的线程，一个用于响应用户按键的线程，还有一个用于在后台执行拼写和语法检查的线程。应用程序还可以被设计为利用多核系统上的处理能力。这样的应用程序可以在多个计算核心上并行执行多个计算密集型任务。</p>
<p><strong>在某些情况下，一个单一的应用程序可能需要执行多个类似的任务</strong>。例如，一个网络服务器接受客户端请求，请求可能包括网页、图像、声音等。一个繁忙的网络服务器可能同时有多个（可能是数千个）客户端访问它。如果网络服务器作为一个传统的单线程进程运行，它只能同时为一个客户端提供服务，客户端可能需要等待很长时间才能得到响应。</p>
<p>一种解决方法是让服务器作为一个单一进程接受请求。当服务器收到一个请求时，它创建一个单独的进程来处理该请求。事实上，在线程变得流行之前，这种进程创建的方法很常见。然而，<strong>进程创建是耗时且资源密集的</strong>。如果新进程将执行与现有进程相同的任务，为什么要承担这么大的开销呢？通常更有效的方法是使用一个包含多个线程的进程。如果网络服务器进程是多线程的，服务器将创建一个单独的线程来监听客户端请求。当请求到达时，服务器不是创建另一个进程，而是创建一个新的线程来处理该请求，并继续监听其他请求。</p>
<img src="https://raw.githubusercontent.com/BlackForest1990/Mypic/img/img/多线程服务器架构.PNG" style="zoom:40%;">
<p>线程还在远程过程调用（RPC）系统中发挥着重要作用。通常，RPC服务器是多线程的。当服务器接收到一条消息时，它使用一个单独的线程来处理该消息。这使服务器能够同时处理多个并发请求。</p>
<p>最后，大多数操作系统内核现在也是多线程的。在内核中运行多个线程，每个线程执行特定的任务，如设备管理、内存管理或中断处理。例如，Solaris内核中有一组专门用于处理中断的线程；Linux使用一个内核线程来管理系统中的空闲内存量。</p>
<h3 id="优点">优点</h3>
<ol>
<li><strong>响应性：</strong> 将交互式应用程序多线程化可能使程序在其部分被阻塞或执行长时间操作时继续运行，从而提高对用户的响应性。这一特性在设计用户界面时特别有用。例如，考虑当用户点击导致执行耗时操作的按钮时会发生什么情况。单线程应用程序在操作完成之前对用户不响应。相比之下，如果耗时操作在单独的线程中执行，应用程序将保持对用户的响应。</li>
<li><strong>资源共享：</strong> 进程只能通过共享内存和消息传递等技术来共享资源。这些技术必须由程序员明确安排。然而，线程默认共享它们所属进程的内存和资源。共享代码和数据的好处是允许应用程序在同一地址空间内具有多个不同的活动线程。</li>
<li><strong>经济性：</strong> 为进程创建分配内存和资源的成本很高。由于线程共享它们所属进程的资源，创建和切换线程更经济。在经验上评估开销的差异可能很困难，但总体上创建和管理进程比线程耗时得多。例如，在Solaris中，创建一个进程约比创建一个线程慢30倍，而上下文切换则慢5倍。</li>
<li><strong>可伸缩性：</strong> 在多处理器架构中，多线程的好处可能更大，因为线程可以并行在不同的处理核心上运行。单线程的进程只能在一个处理器上运行，而不管有多少可用。</li>
</ol>
<h2 id="进程和线程有什么区别">进程和线程有什么区别</h2>
<p><strong>进程是运行程序的抽象</strong>：二进制映像、虚拟化内存、各种内核资源、关联的安全上下文等。<strong>线程是进程中的执行单元</strong>：虚拟处理器、堆栈和程序状态。换句话说，进程是运行的二进制文件，线程是操作系统进程调度程序可调度的最小执行单元。</p>
<p>一个进程<em>包含</em>一个或多个线程。在单线程进程中，进程包含一个线程。你可以说线程<em>就是</em>进程——正在发生一件事。在多线程进程中，进程包含多个线程，即发生不止一件事。</p>
<p>现代操作系统中两个主要的虚拟化抽象是虚拟化内存和虚拟化处理器。两者都给正在运行的进程提供了一种错觉，认为它们单独消耗了机器的资源。虚拟化内存为进程提供了独特的内存视图，可以无缝映射回物理 RAM 或磁盘存储（交换空间）。虚拟化处理器让进程就像单独在处理器上运行一样，而实际上多个进程跨多个处理器执行多任务。</p>
<p>虚拟化内存与进程相关联，而不是与线程相关联。因此，线程共享一个内存地址空间。相反，不同的虚拟化处理器与每个线程相关联。每个线程都是一个独立的可调度实体。</p>
<h2 id="多核编程">多核编程</h2>
<p>在计算机设计的早期阶段，为了提高计算性能，单CPU系统逐渐演变成多CPU系统。在系统设计的更近期的趋势是将多个计算核心集成到一个芯片上。每个核心对操作系统来说都表现为一个独立的处理器。无论这些核心是跨CPU芯片还是在CPU芯片内部，我们称这些系统为多核或多处理器系统。</p>
<p>多线程编程为更有效地利用这些多个计算核心和提高并发性提供了一种机制。考虑一个具有四个线程的应用程序。在一个具有单个计算核心的系统上，并发仅意味着线程的执行将随时间交错进行，因为处理核心一次只能执行一个线程。然而，在具有多个核心的系统中，并发意味着线程可以并行运行，因为系统可以为每个核心分配一个单独的线程。</p>
<p>在这个讨论中，请注意并行性和并发性之间的区别。如果系统能够同时执行多个任务，则系统是并行的。相反，一个并发的系统通过允许所有任务取得进展来支持多个任务。因此，有并发而没有并行是可能的。在SMP和多核架构出现之前，大多数计算机系统只有一个处理器。CPU调度器被设计为通过在系统中迅速切换进程，从而使每个进程取得进展，从而提供并行性的假象。这样的进程是同时运行的，但不是并行的。</p>
<p>随着系统从几十个线程增长到数千个线程，CPU设计者通过添加硬件来改善线程性能，从而提高了系统性能。现代的Intel CPU通常支持每个核心两个线程，而Oracle T4 CPU支持每个核心八个线程。这种支持意味着可以将多个线程加载到核心中进行快速切换。多核计算机毫无疑问将继续增加核心数和硬件线程支持。</p>
<blockquote>
<p>阿姆达尔定律是一个公式，用于确定将额外的计算核心添加到既有串行（非并行）组件又有并行组件的应用程序中可能获得的性能增益。如果S是在具有N个处理核心的系统上必须串行执行的应用程序的部分，该公式如下所示：<br>
$$<br>
speedup ≤ 1/(S+(1-S)/N)<br>
$$<br>
例如，假设我们有一个应用程序，其中75%是并行的，25%是串行的。如果我们在一个具有两个处理核心的系统上运行此应用程序，我们可以获得1.6倍的加速。如果我们添加两个额外的核心（总共四个），加速比为2.28倍。</p>
<p>随着N趋近于无穷大，加速比趋近于1/S。例如，如果应用程序的40%是串行执行的，最大加速比为2.5倍，无论我们添加多少个处理核心。这是阿姆达尔定律的基本原则：<strong>应用程序的串行部分</strong>可以对通过添加额外计算核心获得的性能增益产生不成比例的影响。 有人认为阿姆达尔定律未考虑当代多核系统设计中使用的硬件性能增强因素。这些观点表明，随着处理核心数量在现代计算机系统上继续增加，阿姆达尔定律可能不再适用。</p>
</blockquote>
<h3 id="编程挑战">编程挑战</h3>
<p>多核系统的趋势继续给系统设计师和应用程序员带来了更大的压力，要更好地利用多个计算核心。操作系统的设计者必须编写使用多个处理核心的调度算法，以实现并行执行。对于应用程序员来说，挑战在于修改现有程序以及设计新的支持多线程的程序。 总的来说，在为多核系统编程时有五个方面的挑战：</p>
<ol>
<li><strong>识别任务：</strong> 这涉及检查应用程序，找到可以分为独立并发任务的领域。理想情况下，任务是相互独立的，因此可以在各个核心上并行运行。</li>
<li><strong>平衡：</strong> 在识别可以并行运行的任务的同时，程序员还必须确保这些任务执行相等价值的相等工作。在某些情况下，某个任务对整个过程的贡献可能不如其他任务大。为了运行该任务，使用一个单独的执行核心可能不值得成本。</li>
<li><strong>数据分割：</strong> 正如应用程序被划分为独立任务一样，任务访问和操作的数据必须分割以在不同的核心上运行。</li>
<li><strong>数据依赖性：</strong> 必须检查任务访问的数据，以了解两个或更多任务之间的依赖关系。当一个任务依赖于另一个任务的数据时，程序员必须确保任务的执行是同步的，以适应数据依赖性。</li>
<li><strong>测试和调试：</strong> 当一个程序在多个核心上并行运行时，可能有许多不同的执行路径。测试和调试这样的并发程序比测试和调试单线程应用程序更加困难。</li>
</ol>
<h3 id="并行性的类型">并行性的类型</h3>
<p>总的来说，有两种类型的并行性：数据并行性和任务并行性。数据并行性侧重于将相同数据的子集分布到多个计算核心上，并在每个核心上执行相同的操作。例如，考虑对大小为N的数组的内容求和。在单核系统上，一个线程将简单地对元素[0] . . . [N − 1]进行求和。然而，在双核系统上，运行在核心0上的线程A可以对元素[0] . . . [N/2 − 1]进行求和，同时在核心1上运行的线程B可以对元素[N/2] . . . [N − 1]进行求和。这两个线程将在分别的计算核心上并行运行。</p>
<p>任务并行性涉及在多个计算核心上分发任务（线程），而不是数据。每个线程执行唯一的操作。不同的线程可以操作相同的数据，也可以操作不同的数据。再次考虑上面的例子。与那种情况相反，任务并行性的一个例子可能涉及两个线程，每个线程在元素数组上执行唯一的统计操作。这两个线程再次在分别的计算核心上并行运行，但每个线程执行的是唯一的操作。</p>
<p>因此，基本上，数据并行性涉及在多个核心上分布数据，任务并行性涉及在多个核心上分布任务。然而，在实践中，很少有应用程序严格遵循数据或任务并行性。在大多数情况下，应用程序使用这两种策略的混合形式。</p>
<h2 id="多线程模型">多线程模型</h2>
<p>到目前为止，我们讨论的线程是在一个通用的范围内。然而，线程的支持可以在用户级别提供，用于用户线程，也可以由内核提供，用于内核线程。用户线程在内核之上得到支持，并且在没有内核支持的情况下进行管理，而内核线程由操作系统直接支持和管理。几乎所有当代操作系统，包括Windows、Linux、Mac OS X和Solaris，都支持内核线程。最终，用户线程和内核线程之间必须建立某种关系。我们将讨论建立这种关系的三种常见方式：多对一模型、一对一模型和多对多模型。</p>
<h3 id="多对一模型">多对一模型</h3>
<p>将多个用户级线程映射到一个内核线程。线程管理由用户空间中的线程库完成，因此它是高效的。然而，如果一个线程进行了阻塞系统调用，整个进程将被阻塞。而且，由于一次只能有一个线程访问内核，多个线程无法在多核系统上并行运行。绿色线程（Solaris系统上提供的线程库，在早期Java版本中采用了这种模型）使用了多对一模型。<strong>然而，由于无法充分利用多个处理核心，很少有系统继续使用这种模型</strong>。</p>
<img src="https://raw.githubusercontent.com/BlackForest1990/Mypic/img/img/多对一模型.PNG" style="zoom:40%;">
<h3 id="一对一模型">一对一模型</h3>
<p>将每个用户线程映射到一个内核线程。相较于多对一模型，它提供了更多的并发性，因为当一个线程进行阻塞系统调用时，允许另一个线程运行。它还允许多个线程在多处理器上并行运行。这个模型唯一的缺点是创建一个用户线程需要创建相应的内核线程。由于创建内核线程的开销可能会影响应用程序的性能，因此该模型的大多数实现会限制系统支持的线程数量。Linux以及Windows操作系统家族实现了一对一模型。</p>
<img src="https://raw.githubusercontent.com/BlackForest1990/Mypic/img/img/一对一模型.PNG" style="zoom:40%;">
<h3 id="多对多模型">多对多模型</h3>
<p>多对多模型将许多用户级线程复用到较小或同等数量的内核线程上。内核线程的数量可能特定于特定应用程序或特定机器（在多处理器上，与在单处理器上相比，一个应用程序可能会被分配更多的内核线程）。开发者可以创建任意数量的用户线程，相应的内核线程可以在多处理器上并行运行。此外，当一个线程执行阻塞系统调用时，内核可以调度另一个线程来执行。</p>
<img src="https://raw.githubusercontent.com/BlackForest1990/Mypic/img/img/多对多模型.PNG" style="zoom:40%;">
<p>多对多模型的一种变体仍然将许多用户级线程复用到较小或等于数量的内核线程上，但还允许将用户级线程绑定到内核线程上。这种变体有时被称为两级模型。Solaris操作系统在Solaris 9之前的版本中支持了两级模型。然而，从Solaris 9开始，该系统采用了一对一模型。</p>
<img src="https://raw.githubusercontent.com/BlackForest1990/Mypic/img/img/两级.PNG" style="zoom:40%;">
<h2 id="线程库">线程库</h2>
<p>线程库为程序员提供了一个用于创建和管理线程的API。实现线程库有两种主要方法。第一种方法是在用户空间完全提供一个没有内核支持的库。库的所有代码和数据结构都存在于用户空间。这意味着调用库中的函数会导致用户空间中的本地函数调用，而不是系统调用。第二种方法是实现一个由操作系统直接支持的内核级库。在这种情况下，库的代码和数据结构存在于内核空间。调用库的API中的函数通常会导致对内核的系统调用。</p>
<p>今天有三个主要的线程库在使用中：POSIX Pthreads、Windows和Java。Pthreads是POSIX标准的线程扩展，可以提供作为用户级或内核级库。Windows线程库是一个在Windows系统上可用的内核级库。Java线程API允许在Java程序中直接创建和管理线程。然而，由于在大多数情况下JVM在主机操作系统之上运行，Java线程API通常是使用主机系统上可用的线程库实现的。这意味着在Windows系统上，Java线程通常是使用Windows API实现的；UNIX和Linux系统通常使用Pthreads。</p>
<p>对于POSIX和Windows线程，任何在函数外部声明的全局数据（即在任何函数外部声明的数据）都将在属于同一进程的所有线程之间共享。因为Java没有全局数据的概念，对共享数据的访问必须在线程之间明确安排。在函数内部声明的数据通常存储在堆栈上。由于每个线程都有自己的堆栈，每个线程都有自己的本地数据副本。</p>
<p>两种通用线程策略：</p>
<ul>
<li><strong>异步线程</strong>：一旦父线程创建了一个子线程，父线程就会恢复其执行，使得父线程和子线程同时执行。每个线程独立于其他每个线程运行，父线程无需知道其子线程何时终止。由于线程是独立的，通常在线程之间很少共享数据。</li>
<li><strong>同步线程</strong>：发生在父线程创建一个或多个子线程，然后必须等待所有子线程终止才能继续执行的情况下，即所谓的fork-join策略。在这里，由父线程创建的线程并行执行工作，但是父线程在这项工作完成之前不能继续。一旦每个线程完成了它的工作，它就会终止并与其父线程合并。只有在所有子线程都合并后，父线程才能继续执行。通常，同步线程涉及大量线程之间的数据共享。</li>
</ul>
<h3 id="Pthreads">Pthreads</h3>
<p>Pthreads指的是POSIX标准（IEEE 1003.1c），定义了线程创建和同步的API。这是线程行为的规范，而不是具体的实现。操作系统设计者可以以任何他们希望的方式实现这个规范。许多系统实现了Pthreads规范；大多数是UNIX类型的系统，包括Linux、Mac OS X和Solaris。</p>
<p>下面显示的C程序演示了用于构建多线程程序的基本Pthreads API，该程序在单独的线程中计算非负整数的求和。当此程序开始运行时，一个控制线程从main()开始。在一些初始化之后，main()创建了一个第二个线程，该线程从runner()函数开始控制。两个线程共享全局数据sum。所有Pthreads程序都必须包含pthread.h头文件。语句pthread_t tid声明了我们将要创建的线程的标识符。每个线程都有一组属性，包括堆栈大小和调度信息。pthread_attr_t attr声明表示线程的属性。我们在函数调用pthread_attr_init(&amp;attr) 中设置这些属性。因为我们没有明确设置任何属性，所以使用了提供的默认属性。使用pthread_create()函数调用创建一个单独的线程。除了传递线程标识符和线程的属性外，我们还传递新线程将开始执行的函数的名称，即runner()函数。最后，我们传递从命令行提供的整数参数，即argv[1]。此时，程序有两个线程：在main()中的父线程和在runner()函数中执行求和操作的子线程。该程序遵循先前描述的fork-join策略：创建求和线程后，父线程将通过调用pthread_join()函数等待其终止。求和线程将在调用pthread_exit()函数时终止。一旦求和线程返回，父线程将输出共享数据sum的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> sum; <span class="comment">/* this data is shared by the thread(s) */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">runner</span><span class="params">(<span class="type">void</span> *param)</span>; <span class="comment">/* threads call this function */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid; <span class="comment">/* the thread identifier */</span></span><br><span class="line">    <span class="type">pthread_attr_t</span> attr; <span class="comment">/* set of thread attributes */</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;usage: a.out &lt;integer value&gt;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (atoi(argv[<span class="number">1</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;%d must be &gt;= 0\n&quot;</span>,atoi(argv[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* get the default attributes */</span></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    <span class="comment">/* create the thread */</span></span><br><span class="line">    pthread_create(&amp;tid,&amp;attr,runner,argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">/* wait for the thread to exit */</span></span><br><span class="line">    pthread_join(tid,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum = %d\n&quot;</span>,sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* The thread will begin control in this function */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">runner</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, upper = atoi(param);</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= upper; i++)</span><br><span class="line">    sum += i;</span><br><span class="line">    pthread_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随着多核系统的普及，编写包含多个线程的程序变得越来越普遍。使用pthread_join()函数等待多个线程的简单方法是将操作放在一个简单的for循环中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_THREADS 10</span></span><br><span class="line"><span class="comment">/* an array of threads to be joined upon */</span></span><br><span class="line"><span class="type">pthread_t</span> workers[NUM_THREADS];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; i++)</span><br><span class="line">	pthread_join(workers[i], <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Java-Threads">Java Threads</h3>
<p>线程是Java程序中程序执行的基本模型，Java语言及其API提供了丰富的功能集，用于创建和管理线程。所有Java程序至少包含一个控制线程，即使是一个只包含main()方法的简单Java程序也会作为一个单线程在JVM中运行。Java线程可用于任何提供JVM的系统，包括Windows、Linux和Mac OS X。Java线程API也适用于Android应用程序。</p>
<p>在Java程序中，有两种创建线程的技术。一种方法是创建一个新类，该类派生自Thread类，并覆盖其run()方法。另一种——更常用的——技术是定义一个实现了Runnable接口的类。Runnable接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个类实现了Runnable接口时，它必须定义一个run()方法。实现run()方法的代码将作为一个单独的线程运行。</p>
<p>下面展示了一个在Java中确定非负整数求和的多线程程序的Java版本。Summation类实现了Runnable接口。线程的创建通过创建Thread类的对象实例并将构造函数传递给一个Runnable对象来完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sum</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> sum;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSum</span><span class="params">(<span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sum = sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Summation</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> upper;</span><br><span class="line">    <span class="keyword">private</span> Sum sumValue;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Summation</span><span class="params">(<span class="type">int</span> upper, Sum sumValue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.upper = upper;</span><br><span class="line">        <span class="built_in">this</span>.sumValue = sumValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= upper; i++)</span><br><span class="line">        	sum += i;</span><br><span class="line">        sumValue.setSum(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Integer.parseInt(args[<span class="number">0</span>]) &lt; <span class="number">0</span>)</span><br><span class="line">            	System.err.println(args[<span class="number">0</span>] + <span class="string">&quot; must be &gt;= 0.&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Sum</span> <span class="variable">sumObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sum</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">upper</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thrd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Summation</span>(upper, sumObject));</span><br><span class="line">            thrd.start();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                thrd.join();</span><br><span class="line">                System.out.println(<span class="string">&quot;The sum of &quot;</span>+upper+<span class="string">&quot; is &quot;</span>+sumObject.getSum());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        	System.err.println(<span class="string">&quot;Usage: Summation &lt;integer value&gt;&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建Thread对象并不会直接创建新线程；相反，start()方法创建新线程。对新对象调用start()方法会执行两件事情：</p>
<ol>
<li>在JVM中分配内存并初始化一个新线程。</li>
<li>调用run()方法，使线程有资格在JVM中运行。</li>
</ol>
<p>当求和程序运行时，JVM会创建两个线程。第一个是父线程，在main()方法中开始执行。第二个线程在调用Thread对象上的start()方法时创建。这个子线程在Summation类的run()方法中开始执行。在输出求和值后，此线程在退出其run()方法时终止。</p>
<p>在线程之间共享数据在Windows和Pthreads中很容易，因为共享数据只需在全局声明即可。作为一种纯面向对象的语言，Java没有全局数据的概念。如果Java程序中的两个或多个线程需要共享数据，共享是通过将对共享对象的引用传递给适当的线程来进行的。通过适当的getSum()和setSum()方法引用此共享对象。Pthreads库中的父线程使用pthread_join()来等待求和线程完成后继续的方式。Java中的join()方法提供了类似的功能。</p>
<blockquote>
<p>JVM和主机操作系统</p>
<p>JVM通常是在主机操作系统之上实现的。这种设置使得JVM能够隐藏底层操作系统的实现细节，并提供一个一致的、抽象的环境，使Java程序能够在支持JVM的任何平台上运行。JVM的规范并未说明如何将Java线程映射到底层操作系统，而是将该决策留给JVM的具体实现。例如，Windows XP操作系统使用一对一模型；因此，在这样的系统上运行的JVM的每个Java线程都映射到一个内核线程。在使用多对多模型的操作系统（例如Tru64 UNIX）上，Java线程根据多对多模型进行映射。Solaris最初使用了多对一模型来实现JVM（前面提到的绿色线程库）。JVM的后续版本则使用了多对多模型。从Solaris 9开始，Java线程使用了一对一模型进行映射。此外，Java线程库和主机操作系统上的线程库之间可能存在关系。例如，针对Windows家族操作系统的JVM实现可能在创建Java线程时使用Windows API；而Linux、Solaris和Mac OS X系统可能使用Pthreads API。</p>
</blockquote>
<h2 id="隐式线程">隐式线程</h2>
<p>随着多核处理的不断增长，包含数百甚至数千个线程的应用程序即将出现。为了更好地支持多线程应用程序的设计，一种方法是将线程的创建和管理从应用程序开发人员转移到编译器和运行时库中。这种策略被称为隐式线程implicit threading，是当今的一个流行趋势。</p>
<h3 id="Thread-Pools">Thread Pools</h3>
<p>我们描述了一个多线程的Web服务器。在这种情况下，每当服务器收到一个请求，它就会创建一个单独的线程来处理该请求。虽然创建单独的线程肯定比创建单独的进程更好，但是多线程服务器仍然存在潜在的问题。第一个问题涉及创建线程所需的时间，以及一旦线程完成工作就会被丢弃。第二个问题更为棘手。如果我们允许所有并发请求在新线程中得到服务，那么系统中同时活动的线程数量就没有限制。无限制的线程可能会耗尽系统资源，如CPU时间或内存。解决这个问题的一种方法是使用线程池。</p>
<p>线程池背后的一般思想是在进程启动时创建一些线程，并将它们放入一个池中，等待工作。当服务器收到一个请求时，它唤醒池中的一个线程（如果有的话），并将请求传递给它进行处理。一旦线程完成服务，它就返回到池中等待更多的工作。如果池中没有可用的线程，服务器将等待直到有一个线程空闲。</p>
<p>线程池提供以下优势：</p>
<ol>
<li>使用现有线程来处理请求比等待创建线程更快。</li>
<li>线程池限制了任一时刻存在的线程数量。这在不能支持大量并发线程的系统中尤为重要。</li>
<li>将要执行的任务与创建任务的机制分离，使我们能够使用不同的策略来运行任务。例如，可以安排任务在一段时间后执行或定期执行。</li>
</ol>
<p>线程池的线程数量可以根据启发式算法设置，考虑因素包括系统中的CPU数量、物理内存量和预期的并发客户端请求数。更复杂的线程池架构可以根据使用模式动态调整池中的线程数量。这样的架构在系统负载较低时提供更小的池，从而消耗更少的内存。</p>
<h3 id="OpenMP">OpenMP</h3>
<p>OpenMP是一组编译器指令以及用于在C、C++或FORTRAN中编写的程序的API，为共享内存环境中的并行编程提供支持。OpenMP将并行区域标识为可能并行运行的代码块。应用程序开发人员在其代码中在并行区域插入编译器指令，这些指令指示OpenMP运行时库在并行中执行该区域。以下是一个包含printf()语句的并行区域上方的编译器指令的C程序示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">/* 顺序代码 */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am a parallel region.\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* 顺序代码 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当OpenMP遇到指令<code>#pragma omp parallel</code>时，它会创建与系统中的处理核心数量相同的线程。因此，对于双核系统，将创建两个线程；对于四核系统，将创建四个线程；依此类推。然后，所有线程同时执行并行区域。每个线程退出并行区域时，它将被终止。</p>
<p>OpenMP提供了一些额外的指令来并行运行代码区域，包括并行化循环。例如，假设我们有两个大小为N的数组a和b。我们希望将它们的内容相加并将结果放入数组c。我们可以通过使用以下包含并行化for循环指令的代码段来并行运行此任务：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    c[i] = a[i] + b[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OpenMP将for循环中的工作分配给它根据指令<code>#pragma omp parallel for</code>创建的线程。</p>
<p>除了提供并行化指令外，OpenMP还允许开发人员在多个并行性级别之间进行选择。例如，他们可以手动设置线程数。它还允许开发人员确定数据是否在线程之间共享或对线程私有。OpenMP在Linux、Windows和Mac OS X系统的多个开源和商业编译器上都可用。</p>
<h3 id="Grand-Central-Dispatch">Grand Central Dispatch</h3>
<p>Grand Central Dispatch (GCD) 是苹果的 Mac OS X 和 iOS 操作系统的一项技术，它是 C 语言的扩展、一个 API 和一个运行时库的组合，允许应用程序开发人员标识要并行运行的代码段。与 OpenMP 类似，GCD 管理大部分线程细节。</p>
<p>GCD 标识了称为 blocks 的 C 和 C++ 语言扩展。一个 block 简单地是一个自包含的工作单元，由插入在一对大括号 { } 前面的插入符 ^ 指定。下面是一个 block 的简单示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^&#123; <span class="built_in">printf</span>(<span class="string">&quot;I am a block&quot;</span>); &#125;</span><br></pre></td></tr></table></figure>
<p>GCD 通过将 block 放置在调度队列上来为运行时执行调度 block。当它从队列中移除一个 block 时，它将该 block 分配给其管理的线程池中的一个可用线程。GCD 标识了两种类型的调度队列：串行队列和并发队列。</p>
<p>放置在串行队列上的 block 按照先进先出（FIFO）的顺序被移除。一旦一个 block 从队列中移除，它必须在移除另一个 block 之前完成执行。每个进程都有自己的串行队列（称为主队列）。开发人员可以创建局部于特定进程的额外串行队列。串行队列对于确保多个任务的顺序执行非常有用。</p>
<p>放置在并发队列上的 block 也按照先进先出的顺序被移除，但是可以同时移除多个 block，从而允许多个 block 并行执行。系统有三个全局并发调度队列，并且根据优先级进行区分：低、默认和高。优先级表示 block 相对重要性的近似值。简单来说，具有更高优先级的 block 应该放置在高优先级调度队列上。</p>
<p>以下代码段演示了如何获取默认优先级的并发队列并使用 dispatch_async() 函数将一个 block 提交到队列中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">dispatch_async(<span class="built_in">queue</span>, ^&#123; <span class="built_in">printf</span>(<span class="string">&quot;I am a block.&quot;</span>); &#125;);</span><br></pre></td></tr></table></figure>
<p>在内部，GCD 的线程池由 POSIX 线程组成。GCD 主动管理该池，允许线程的数量根据应用程序需求和系统容量而增长和收缩。</p>
<h2 id="线程问题">线程问题</h2>
<h3 id="The-fork-and-exec-System-Calls">The fork() and exec() System Calls</h3>
<p>fork() 系统调用用于创建一个独立的、重复的进程。在多线程程序中，fork() 和 exec() 系统调用的语义发生了变化。如果程序中的一个线程调用了 fork()，那么新进程是复制所有线程，还是新进程是单线程的呢？<strong>一些 UNIX 系统选择使用两个版本的 fork()</strong>，一个版本复制所有线程，另一个版本只复制调用了 fork() 系统调用的线程。</p>
<p>如果一个线程调用了 exec() 系统调用，<strong>那么参数中指定的程序将替换整个进程，包括所有线程</strong>。</p>
<p>选择使用 fork() 的哪个版本取决于应用程序。如果在 fork() 后立即调用 exec()，则复制所有线程是不必要的，因为参数中指定的程序将替换进程。在这种情况下，只复制调用线程是合适的。然而，如果在 fork() 后独立的进程没有调用 exec()，那么独立的进程应该复制所有线程。</p>
<h3 id="信号处理">信号处理</h3>
<p>信号在UNIX系统中用于通知一个进程特定事件发生。信号可以是同步接收的，也可以是异步接收的，这取决于事件发生的源头和原因。所有信号，无论是同步还是异步，都遵循相同的模式：</p>
<ol>
<li>通过发生特定事件生成信号。</li>
<li>将信号传递给一个进程。</li>
<li>一旦传递，必须处理信号。</li>
</ol>
<p>同步信号的示例包括非法内存访问和除零。如果运行中的程序执行这些操作之一，就会生成一个信号。<strong>同步信号被传递给执行引起信号的操作的同一进程</strong>（这就是它们被认为是同步的原因）。</p>
<p>当由运行进程外部事件生成信号时，该进程异步接收信号。此类信号的示例包括使用特定按键（例如<control><C>）终止进程以及计时器超时。<strong>通常，异步信号被发送到另一个进程</strong>。</C></control></p>
<p>一个信号可以由两种可能的处理程序之一处理：</p>
<ol>
<li>默认信号处理程序</li>
<li>用户定义的信号处理程序</li>
</ol>
<p><strong>每个信号都有一个默认信号处理程序，内核在处理该信号时运行该处理程序。这个默认操作可以被用户定义的信号处理程序覆盖</strong>，后者被调用以处理信号。信号的处理方式各不相同。有些信号（例如更改窗口大小）被简单地忽略；其他信号（例如非法内存访问）通过终止程序来处理。</p>
<p>在单线程程序中处理信号是直截了当的：信号总是传递给一个进程。然而，在多线程程序中，一个进程可能有多个线程，因此传递信号更加复杂。那么，信号应该传递到哪里呢？</p>
<ol>
<li>将信号传递给引起信号的线程。</li>
<li>将信号传递给进程中的每个线程。</li>
<li>将信号传递给进程中的某些线程。</li>
<li>为接收进程的所有信号分配一个特定的线程。</li>
</ol>
<p>传递信号的方法取决于生成的信号类型。例如，同步信号需要传递给引起信号的线程，而异步信号的情况则不那么明确。一些异步信号（例如终止进程的信号，如<control><C>）应该发送到所有线程。</C></control></p>
<p>传递信号的标准UNIX函数是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> signal)</span>;</span><br></pre></td></tr></table></figure>
<p>这个函数指定了要向其发送特定信号的进程（pid）。大多数多线程版本的UNIX允许线程指定它们将接受哪些信号和哪些信号将被阻塞。因此，在某些情况下，异步信号可能只被传递到不阻塞它的那些线程。但是，由于信号只需要处理一次，因此通常只将信号传递到找到的第一个不阻塞它的线程。POSIX Pthreads提供了以下函数，允许将信号传递给指定的线程（tid）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_kill</span><span class="params">(<span class="type">pthread_t</span> tid, <span class="type">int</span> signal)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="线程取消">线程取消</h3>
<p>线程取消涉及在其完成之前终止线程。例如，如果多个线程同时在数据库中搜索，其中一个线程返回结果，那么可能会取消其余的线程。另一种情况可能发生在用户按下 Web 浏览器上的按钮停止网页进一步加载时。通常，一个网页使用多个线程加载 ——每个图像都在单独的线程中加载。当用户按下浏览器上的停止按钮时，加载页面的所有线程都将被取消。</p>
<p>即将取消的线程通常称为目标线程。取消目标线程可能发生在两种不同的场景下：</p>
<ol>
<li><strong>异步取消</strong>。一个线程立即终止目标线程。</li>
<li><strong>延迟取消</strong>。目标线程周期性地检查是否应该终止，允许其有机会以有序的方式自行终止。</li>
</ol>
<p><strong>如果资源已分配给要取消的线程或要取消的线程正在更新与其他线程所共享的数据，那么取消就会有困难</strong>。这在异步取消的情况下尤其麻烦。通常，操作系统将从已取消的线程中回收系统资源，但不会回收所有资源。因此，异步取消可能无法释放必要的系统范围资源。相反，延迟取消中，一个线程指示目标线程应该被取消，但取消只在目标线程检查标志以确定是否应该取消时发生。Pthread称这些点为取消点 (cancellation point)。</p>
<p>在Pthreads中，使用<code>pthread_cancel()</code>函数启动线程取消。目标线程的标识符作为参数传递给该函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_t</span> tid;</span><br><span class="line"><span class="comment">/* 创建线程 */</span></span><br><span class="line">pthread_create(&amp;tid, <span class="number">0</span>, worker, <span class="literal">NULL</span>);</span><br><span class="line">. . .</span><br><span class="line"><span class="comment">/* 取消线程 */</span></span><br><span class="line">pthread_cancel(tid);</span><br></pre></td></tr></table></figure>
<p>然而，调用<code>pthread_cancel()</code>只是表示请求取消目标线程；实际的取消取决于目标线程如何设置以处理请求。Pthreads支持三种取消模式。每种模式都定义为一种状态和一种类型，如下表所示。线程可以使用API设置其取消状态和类型。</p>
<img src="https://raw.githubusercontent.com/BlackForest1990/Mypic/img/img/线程取消模式.PNG" style="zoom:50%;">
<p>正如表格所示，Pthreads允许线程禁用或启用取消。显然，如果禁用取消，线程将无法被取消。但是，取消请求仍然挂起，因此线程稍后可以启用取消并响应请求。默认的取消类型是延迟取消。在这里，取消仅在线程到达取消点cancellation point时发生。建立取消点的一种技术是调用<code>pthread_testcancel()</code>函数。如果发现有挂起的取消请求，则将调用一个称为清理处理程序cleanup handler 的函数。此函数允许线程释放可能已经获取的任何资源，然后线程终止。</p>
<p>以下代码演示了线程如何使用延迟取消响应取消请求：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 进行一段时间的工作 */</span></span><br><span class="line">    <span class="comment">/* . . . */</span></span><br><span class="line">    <span class="comment">/* 检查是否有取消请求 */</span></span><br><span class="line">    pthread_testcancel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于前述问题，Pthreads文档不推荐使用异步取消。因此，我们在这里不进行介绍。有趣的是，在Linux系统上，使用Pthreads API进行线程取消是通过信号处理的。</p>
<h3 id="Thread-Local-Storage">Thread-Local Storage</h3>
<p>属于一个进程的线程共享该进程的数据。事实上，这种数据共享是多线程编程的一个好处之一。然而，在某些情况下，每个线程可能需要拥有某些数据的自己的副本。我们将这样的数据称为线程本地存储（TLS）。例如，在事务处理系统中，我们可能在单独的线程中处理每个事务。此外，每个事务可能被分配一个唯一的标识符。为了将每个线程与其唯一标识符关联起来，我们可以使用线程本地存储。</p>
<p>很容易将 TLS 与局部变量混淆。然而，局部变量仅在单个函数调用期间可见，而 TLS 数据在函数调用之间是可见的。在某些方面，TLS 与静态数据类似。<strong>区别在于 TLS 数据对于每个线程是唯一的</strong>。大多数线程库，包括 Windows 和 Pthreads，都提供对线程本地存储的某种形式的支持；Java 也提供支持。</p>
<h3 id="调度程序激活">调度程序激活</h3>
<p>多线程程序需要考虑的最后一个问题涉及内核与线程库之间的通信，这可能是由多对多和双层模型所要求的。这种协调允许动态调整内核线程的数量，以确保最佳性能。</p>
<p>许多实现多对多或双层模型的系统在用户线程和内核线程之间放置了一个中间数据结构。这个数据结构通常称为轻量级进程（Lightweight Process，LWP）。对于用户线程库来说，LWP 看起来像是可以调度用户线程运行的虚拟处理器。每个 LWP 都附加到一个内核线程上，而操作系统调度的是内核线程在物理处理器上运行。如果一个内核线程阻塞（例如，等待 I/O 操作完成），LWP 也会阻塞。在上层，附加到 LWP 的用户级线程也会阻塞。</p>
<img src="https://raw.githubusercontent.com/BlackForest1990/Mypic/img/img/LWP.PNG" style="zoom:40%;">
<p>一个应用程序可能需要任意数量的 LWPs 来有效运行。考虑在单个处理器上运行的 CPU 密集型应用程序。在这种情况下，一次只能运行一个线程，因此一个 LWP 就足够了。然而，I/O 密集型的应用程序可能需要多个 LWPs 来执行。通常，每个并发的阻塞系统调用都需要一个 LWP。例如，假设同时发生了五个不同的文件读取请求。需要五个 LWPs，因为它们都可能在内核中等待 I/O 完成。如果一个进程只有四个 LWPs，<strong>那么第五个请求必须等待其中一个 LWP 从内核返回</strong>。</p>
<p>用户线程库和内核之间的通信方案之一被称为<strong>调度程序激活</strong>（scheduler activation）。其工作原理如下：内核提供应用程序一组虚拟处理器（LWPs），应用程序可以将用户线程调度到可用的虚拟处理器上。此外，内核必须通知应用程序某些事件。<strong>这个过程被称为 upcall</strong>。Upcalls 由线程库处理，使用 upcall 处理程序，并且 upcall 处理程序必须在虚拟处理器上运行。</p>
<p><strong>触发 upcall 的一个事件是应用程序线程即将阻塞</strong>。在这种情况下，内核通过 upcall 通知应用程序线程即将阻塞，并标识特定的线程。然后，内核为应用程序分配一个新的虚拟处理器。应用程序在这个新的虚拟处理器上运行一个 upcall 处理程序，<strong>该处理程序保存阻塞线程的状态并放弃正在运行阻塞线程的虚拟处理器</strong>。然后，upcall 处理程序调度另一个有资格在新虚拟处理器上运行的线程。当阻塞线程等待的事件发生时，内核再次发起 upcall 给线程库，通知它先前被阻塞的线程现在有资格运行。这个事件的 upcall 处理程序也需要一个虚拟处理器，内核可能分配一个新的虚拟处理器或抢占其中一个用户线程并在其虚拟处理器上运行 upcall 处理程序。在标记未阻塞的线程有资格运行之后，应用程序调度一个有资格在可用虚拟处理器上运行的线程。</p>
<h2 id="Linux-线程">Linux 线程</h2>
<p>Linux提供了fork()系统调用，具有复制进程的传统功能。Linux还提供使用clone()系统调用创建线程的能力。然而，Linux不区分进程和线程。事实上，Linux在引用程序中的控制流时使用术语task而不是process或thread。</p>
<p>当调用clone()时，它会传递一组标志，这些标志确定父任务和子任务之间要共享多少。假设clone()传递了标志CLONE_FS、CLONE_VM、CLONE_SIGHAND和CLONE_FILES。那么父任务和子任务将共享相同的文件系统信息（例如当前工作目录）、相同的内存空间、相同的信号处理程序和相同的打开文件集。以这种方式使用clone()相当于创建线程，因为父任务与其子任务共享大多数资源。但是，如果在调用clone()时没有设置这些标志中的任何一个，将不会发生共享，结果类似于fork()系统调用提供的功能。</p>
<img src="https://raw.githubusercontent.com/BlackForest1990/Mypic/img/img/Linux线程.PNG" style="zoom:40%;">
<p>共享级别的差异是可能的，因为任务在Linux内核中的表示方式。对于系统中的每个任务，都存在一个唯一的内核数据结构（具体而言，是struct task_struct）。该数据结构不存储任务的数据，而是包含指向其他数据结构的指针，其中存储了这些数据，例如表示打开文件列表、信号处理信息和虚拟内存的数据结构。当调用fork()时，将创建一个新任务，以及父进程的所有相关数据结构的副本。当调用clone()系统调用时，也会创建一个新任务。但是，与其复制所有数据结构不同，新任务根据传递给clone()的标志集指向父任务的数据结构。</p>
<p>Linux引入线程组的表示。一个线程组中的所有线程使用和该线程组的领头线程(thread group leader)相同的PID,也就是该组中第一个轻量级进程的PID,它被存入进程描述符的tgid字段中。getpid()系统调用返回当前进程的tgid值而不是pid的值，因此，一个多线程应用的所有线程共享相同的PID。绝大多数进程都属于一个线程组，包含单一的成员；线程组的领头线程其tgid的值与pid的值相同，因而 getpid()系统调用对这类进程所起的作用和一般进程是一样的。</p>
<h3 id="内核线程">内核线程</h3>
<p>在 Linux中，内核线程在以下几方面不同于普通进程：</p>
<ul>
<li>内核线程只运行在内核态，而普通进程既可以运行在内核态，也可以运行在用户态。</li>
<li>因为内核线程只运行在内核态，它们只使用大于PAGE_OFFSET的线性地址空间。另一方面，不管在用户态还是在内核态，普通进程可以用4GB的线性地址空间。</li>
</ul>
<p>kernel_thread()函数创建一个新的内核线程，它接受的参数有：所要执行的内核函数的地址(fn)、要传递给函数的参数(arg)、一组 clone标志(flags)。该函数本质上调用do_fork()</p>
<p>所有进程的祖先叫做进程0,idle 进程，它是在Linux的初始化阶段从无到有创建的一个内核线程。这个祖先进程使用下列静态分配的数据结构(所有其他进程的数据结构都是动态分配的):</p>
<ul>
<li>存放在init_task变量中的进程描述符，由INIT_TASK 宏完成对它的初始化。</li>
<li>存放在init_thread_union变量中的thread_info描述符和内核堆栈，由INIT_THREAD_INFO宏完成对它们的初始化。</li>
</ul>
<p>start_kernel()函数初始化内核需要的所有数据结构，激活中断，创建另一个叫进程1的内核线程(一般叫做init进程):</p>
<p>kernel_thread(init, NULL,CLONE_FSICLONE_SIGHAND);</p>
<p>新创建内核线程的PID为1,并与进程0共享每进程所有的内核数据结构。此外，当调度程序选择到它时，init 进程开始执行 init()函数。</p>
<p>创建init进程后，进程0执行 cpu_idle()函数，该函数本质上是在开中断的情况下重复执行 hlt汇编语言指令。只有当没有其他进程处于TASK_RUNNING状态时，调度程序才选择进程0。</p>
<p>在多处理器系统中，每个CPU都有一个进程0。只要打开机器电源，计算机的 BIOS就启动某一个CPU,同时禁用其他CPU。运行在CPU 0上的 swapper进程初始化内核数据结构，然后激活其他的CPU,并通过copy_process()函数创建另外的swapper进程，把0传递给新创建的swapper 进程作为它们的新PID。此外，内核把适当的CPU索引赋给内核所创建的每个进程的 thread_info描述符的cpu 字段。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blackforest1990.github.io">BlackForest1990</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blackforest1990.github.io/2023/12/05/%E7%BA%BF%E7%A8%8B/">https://blackforest1990.github.io/2023/12/05/%E7%BA%BF%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blackforest1990.github.io" target="_blank">黑暗森林</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">进程管理</a></div><div class="post_share"><div class="social-share" data-image="/image/blackforest.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>谢谢支持</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechatpay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechatpay.jpg"/></a><div class="post-qr-code-desc"></div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/12/11/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/" title="进程同步"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">进程同步</div></div></a></div><div class="next-post pull-right"><a href="/2023/11/28/%E8%BF%9B%E7%A8%8B/" title="进程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">进程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/02/19/deadlock/" title="deadlock"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-02-19</div><div class="title">deadlock</div></div></a></div><div><a href="/2024/01/03/CPU%E8%B0%83%E5%BA%A6/" title="CPU调度"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-01-19</div><div class="title">CPU调度</div></div></a></div><div><a href="/2023/11/28/%E8%BF%9B%E7%A8%8B/" title="进程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-08-12</div><div class="title">进程</div></div></a></div><div><a href="/2023/12/11/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/" title="进程同步"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-08-06</div><div class="title">进程同步</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BA"><span class="toc-number">1.1.1.</span> <span class="toc-text">动机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">1.1.2.</span> <span class="toc-text">优点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.</span> <span class="toc-text">进程和线程有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%A0%B8%E7%BC%96%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">多核编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E6%8C%91%E6%88%98"><span class="toc-number">1.3.1.</span> <span class="toc-text">编程挑战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E6%80%A7%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">并行性的类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.4.</span> <span class="toc-text">多线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.4.1.</span> <span class="toc-text">多对一模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.4.2.</span> <span class="toc-text">一对一模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.4.3.</span> <span class="toc-text">多对多模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%BA%93"><span class="toc-number">1.5.</span> <span class="toc-text">线程库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pthreads"><span class="toc-number">1.5.1.</span> <span class="toc-text">Pthreads</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-Threads"><span class="toc-number">1.5.2.</span> <span class="toc-text">Java Threads</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.6.</span> <span class="toc-text">隐式线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread-Pools"><span class="toc-number">1.6.1.</span> <span class="toc-text">Thread Pools</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenMP"><span class="toc-number">1.6.2.</span> <span class="toc-text">OpenMP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Grand-Central-Dispatch"><span class="toc-number">1.6.3.</span> <span class="toc-text">Grand Central Dispatch</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98"><span class="toc-number">1.7.</span> <span class="toc-text">线程问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#The-fork-and-exec-System-Calls"><span class="toc-number">1.7.1.</span> <span class="toc-text">The fork() and exec() System Calls</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86"><span class="toc-number">1.7.2.</span> <span class="toc-text">信号处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%8F%96%E6%B6%88"><span class="toc-number">1.7.3.</span> <span class="toc-text">线程取消</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread-Local-Storage"><span class="toc-number">1.7.4.</span> <span class="toc-text">Thread-Local Storage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F%E6%BF%80%E6%B4%BB"><span class="toc-number">1.7.5.</span> <span class="toc-text">调度程序激活</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.8.</span> <span class="toc-text">Linux 线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.8.1.</span> <span class="toc-text">内核线程</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By BlackForest1990</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">如果只允许一种声音存在，那么，唯一存在的那个声音就是谎言。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>