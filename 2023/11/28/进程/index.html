<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>进程 | 黑暗森林</title><meta name="author" content="BlackForest1990"><meta name="copyright" content="BlackForest1990"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="进程 在所有操作系统中，一个重要的概念是进程（process）。进程本质上是正在执行的一个程序。进程不止是程序代码，程序代码有时被称为文本段（text section）。进程还包括当前活动，通过程序计数器（program counter）的值和处理器寄存器的内容来表示。另外，进程还包括堆栈段stack（函数参数，返回地址和局部变量）和数据段data section（全局变量）。进程还包括堆（hea">
<meta property="og:type" content="article">
<meta property="og:title" content="进程">
<meta property="og:url" content="https://blackforest1990.github.io/2023/11/28/%E8%BF%9B%E7%A8%8B/index.html">
<meta property="og:site_name" content="黑暗森林">
<meta property="og:description" content="进程 在所有操作系统中，一个重要的概念是进程（process）。进程本质上是正在执行的一个程序。进程不止是程序代码，程序代码有时被称为文本段（text section）。进程还包括当前活动，通过程序计数器（program counter）的值和处理器寄存器的内容来表示。另外，进程还包括堆栈段stack（函数参数，返回地址和局部变量）和数据段data section（全局变量）。进程还包括堆（hea">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blackforest1990.github.io/image/blackforest.jpg">
<meta property="article:published_time" content="2023-11-28T06:01:38.000Z">
<meta property="article:modified_time" content="2024-01-09T05:17:03.533Z">
<meta property="article:author" content="BlackForest1990">
<meta property="article:tag" content="进程管理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blackforest1990.github.io/image/blackforest.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blackforest1990.github.io/2023/11/28/%E8%BF%9B%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '进程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-09 13:17:03'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="黑暗森林" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/image/blackforest.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="黑暗森林"><span class="site-name">黑暗森林</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">进程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-28T06:01:38.000Z" title="发表于 2023-11-28 14:01:38">2023-11-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-09T05:17:03.533Z" title="更新于 2024-01-09 13:17:03">2024-01-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="进程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="进程">进程</h2>
<p>在所有操作系统中，一个重要的概念是进程（process）。进程本质上是正在执行的一个程序。进程不止是程序代码，程序代码有时被称为<strong>文本段</strong>（text section）。进程还包括当前活动，通过<strong>程序计数器</strong>（program counter）的值和处理器<strong>寄存器</strong>的内容来表示。另外，进程还包括<strong>堆栈段</strong>stack（函数参数，返回地址和局部变量）和<strong>数据段</strong>data section（全局变量）。进程还包括<strong>堆</strong>（heap），是在进程运行期间动态分配内存。</p>
<p>这里强调:程序本身不是进程:程序是被动实体，如存储在磁盘上包含一系列指令的文件内容(常被称为可执行文件) ，而进程是活动实体，它有一个程序计数器用来表示下一个要执行的命令和相关资源集合。当一个可执行文件被装入内存时，一个程序才能成为进程。装载可执行文件通常有两种方法，即双击一个代表此可执行文件的图标或在命令行中输入该文件的文件名(如prog.exe 或 a.out)。</p>
<img src="https://raw.githubusercontent.com/BlackForest1990/Mypic/img/img/%E8%BF%9B%E7%A8%8B.png" style="zoom:40%;">
<h3 id="进程状态">进程状态</h3>
<p>● new: 进程被创建</p>
<p>● running: 指令正被执行</p>
<p>● waiting: 该进程正在等待/阻止某些事件的发生</p>
<p>● ready: 该进程正在等待被分配给一个处理器</p>
<p>● terminated: 该进程已完成执行</p>
<img src="https://raw.githubusercontent.com/BlackForest1990/Mypic/img/img/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png" style="zoom:40%;">
<h3 id="进程控制块">进程控制块</h3>
<p>每个进程在操作系统内用进程控制块 (process control block. PCB)来表示。</p>
<img src="https://raw.githubusercontent.com/BlackForest1990/Mypic/img/img/PCB.png" style="zoom:30%;">
<ul>
<li>
<p>进程状态:状态可包括new/running/waiting/ready/terminated。</p>
</li>
<li>
<p>程序计数器:计数器表示进程要执行的下个指令的地址。</p>
</li>
<li>
<p>CPU 寄存器:根据计算机体系结构的不同，寄存器的数量和类型也不同。它们包括累加器、索引寄存器、堆栈指针、通用寄存器和其他条件码信息寄存器。与程序计数器一起，这些状态信息在出现中断时也需要保存，以便进程以后能正确地继续执行。</p>
</li>
<li>
<p>CPU 调度信息:这类信息包括进程优先级、调度队列的指针和其他调度参数</p>
</li>
</ul>
  <img src="https://raw.githubusercontent.com/BlackForest1990/Mypic/img/img/%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2.png" style="zoom:40%;">
<ul>
<li>
<p>内存管理信息:根据操作系统所使用的内存系统，这类信息包括基址和界限寄存器的值、页表或段表。</p>
</li>
<li>
<p>记账信息:这类信息包括 CPU 时间、实际使用时间、时间界限、记账数据、作业或进程数量等。</p>
</li>
<li>
<p>I/O 状态信息:这类信息包括分配给进程的 I/O 设备列表、打开的文件列表等。</p>
<h3 id="Linux中的进程表示">Linux中的进程表示</h3>
<p>Linux 操作系统中的进程控制块是通过 &lt;linux/sched.h&gt; 中的 task_struct 来表示的。这个结构包含了表示一个进程所需要的所有信息，包括进程的状态、调度和内存管理信息、打开文件列表和指向父进程和所有子进程的指针(创建进程的进程是父进程，被进程创建的进程为子进程)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> state; <span class="comment">/* state of the process */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> <span class="title">se</span>;</span> <span class="comment">/* scheduling information */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">parent</span>;</span> <span class="comment">/* this process’s parent */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children</span>;</span> <span class="comment">/* this process’s children */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span> <span class="comment">/* list of open files */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span> <span class="comment">/* address space of this process */</span></span><br></pre></td></tr></table></figure>
<p>例如，进程的状态是通过这个结构中的long state 字段来表示的。在Linux 内核里，所有活动的进程是通过一个名为task_struct 的<strong>双向链表</strong>来表示的，内核为当前正在运行的进程保存了一个指针(current)。</p>
<img src="https://raw.githubusercontent.com/BlackForest1990/Mypic/img/img/linux%20task%20struct.PNG" style="zoom:40%;">
<p>解释一下内核如何操作一个指定进程的 task_struct 字段。假定操作系统想把当前运行进程的状态值修改成 new state。如果 current是指向当前进程的指针，那么要改变状态可以如下进行:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">current-&gt;state = new state;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="进程调度">进程调度</h2>
<p>多道程序设计的目的是无论何时都有进程在运行，从而使 CPU 利用率达到最大化。分时系统在进程之间快速切换 CPU 以便用户在程序运行时能与其进行交互。为了达到此目的，进程调度选择一个可用的进程(可能从多个可用进程集合中选择)到 CPU 上执行。单处理器系统从不会有超过一个进程在运行。如果有多个进程，那么余下的则需要等待 CPU空闲并重新调度。</p>
<h3 id="调度队列">调度队列</h3>
<p>进程进入系统时，会被加入到<strong>作业队列</strong>(job queue)中,该队列包括系统中所有进程。驻留在内存中就绪的、等待运行的进程保存在<strong>就绪队列</strong>(ready queue)中, 该队列通常用链表实现，其头结点指向链表的第一个和最后一个PCB块的指针。每个PCB包括一个指向就绪队列的下一个PCB的指针域。</p>
<p>操作系统也有其他队列。当给进程分配了CPU 后，它开始执行并最终完成，或被中断，或等待特定事件发生(如完成I/O 请求)。假设进程向一个共享设备(如磁盘)发送I/O 请求，由于系统有许多进程，磁盘可能会忙于其他进程的I/O 请求，因此该进程可能需要等待磁盘。等待特定 I/O 设备的进程列表称为<strong>设备队列</strong>(device queue)。</p>
<img src="https://raw.githubusercontent.com/BlackForest1990/Mypic/img/img/ready%20queue%20and%20device%20queue.PNG" style="zoom:40%;">
<p>新进程开始处于就绪队列。它在就绪队列中等待直到被选中执行或被派遣。当进程分配到 CPU 并执行时，可能发生下面事件中的一种:</p>
<ul>
<li>进程可能发出一个 I/O 请求，并被放到 I/O 队列中。</li>
<li>进程可能创建一个新的子进程，并等待其结束。</li>
<li>进程可能会由于中断而强制释放 CPU ，并被放回到就绪队列中。</li>
</ul>
<p>对于前两种情况，进程最终从等待状态切换到就绪态，并放回到就绪队列中。进程继续这一循环直到终止，到时它将从所有队列中删除，其PCB 和资源将得以释放。</p>
<h3 id="调度程序">调度程序</h3>
<p>进程选择是由相应的<strong>调度程序</strong>(scheduler) 来执行的。通常对于批处理系统，进程更多地是被提交，而不是马上执行。这些进程被放到大容量存储设备(通常为磁盘)的缓冲池中，保存在那里以便以后执行。<strong>长期调度程序</strong>(long-term scheduler) 或<strong>作业调度程序</strong> (job scheduler) 从该池中选择进程，并装入内存准备执行(秒/分钟级别调度)。<strong>短期调度程序</strong> (short-term scheduler) 或 <strong>CPU 调度程序</strong>从准备执行的进程中选择进程(毫秒级别调度)，并为之分配 CPU 。达到最好性能，长期调度程序应该选择一个合理的包含I/O 为主的和 CPU 为主的组合进程。</p>
<img src="https://raw.githubusercontent.com/BlackForest1990/Mypic/img/img/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E9%98%9F%E5%88%97.png" style="zoom:30%;">
<p>对于有些系统，可能没有长期调度程序。例如，UNIX 或Windows 的分时系统通常没有长期调度程序，只是简单地将所有新进程放在内存中以供短期调度程序使用。这些系统的稳定性依赖于物理限制(如可用的终端数)或用户的自我调整。如果多用户系统性能下降到令人难以接受，那么将有用户退出。</p>
<p>有的操作系统如分时系统，可能引入另外的<strong>中期调度程序</strong>( medium-term scheduler) 。中期调度程序的核心思想是能将进程从内存(或从 CPU 竞争)中移出，从而降低多道程序设计的程度。之后，进程能被重新调入内存，并从中断处继续执行。这种方案称为交换 (swapping) 。通过中期调度程序，进程可换出，并在后来可被换入。为了改善进程组合，或者因内存要求的改变引起了可用内存的过度使用而需要释放内存，就有必要使用交换。</p>
<img src="https://raw.githubusercontent.com/BlackForest1990/Mypic/img/img/%E4%B8%AD%E6%9C%9F%E8%B0%83%E5%BA%A6%E8%BF%9B%E7%A8%8B.png" style="zoom:40%;">
<h3 id="上下文切换">上下文切换</h3>
<p>将 CPU 切换到另一个进程需要保存当前进程的状态并恢复另一个进程的状态，这一任务称为<strong>上下文切换</strong> (context switch) 。当发生上下文切换时，内核会将旧进程的状态保存在其 PCB 中，然后装入经调度要执行的并己保存的新进程的上下文。上下文切换时间是额外开销，因为切换时系统并不能做什么工作。上下文切换速度因机器而不同，它依赖于内存速度、必须复制的寄存器的数量、是否有特殊指令(如装入或保存所有寄存器的单个指令)，一般需几毫秒。</p>
<p>上下文切换时间与硬件支持密切相关。例如，有的处理器(如 Sun UltraSPARC) 提供了多组寄存器集合，上下文切换只需要简单地改变当前寄存器组的指针。当然，如果活动进程数超过了寄存器集合数量，那么系统需要像以前一样在寄存器与内存之间进行数据复制。而且，操作系统越复杂，上下文切换所要做的工作就越多。</p>
<h2 id="进程操作">进程操作</h2>
<p>绝大多数系统内的进程能并发执行，它们可以动态创建和删除，因此操作系统必须提供某种机制(或工具)以创建和终止进程。</p>
<h3 id="进程创建">进程创建</h3>
<p>在UNIX中，每个进程都由其进程标识符（PID）唯一标识。通过fork()系统调用创建一个新进程。新进程由原始进程的地址空间的副本组成。这种机制允许父进程与其子进程轻松通信。两个进程都在fork()之后的指令继续执行，唯一的区别是fork()的返回码对于新（子）进程是零，而子进程的（非零）进程标识符被返回给父进程。</p>
<p>在fork()系统调用之后，通常有两个进程中的一个使用exec()系统调用来用一个新程序替换进程的内存空间。exec()系统调用将一个二进制文件加载到内存中（销毁包含exec()系统调用的程序的内存映像）并开始执行。通过这种方式，两个进程能够通信然后各自进行。父进程然后可以创建更多的子进程；或者，如果它在子进程运行时没有其他事情可做，它可以发出wait()系统调用，将自己移出就绪队列直到子进程终止。由于对exec()的调用用新程序覆盖进程的地址空间，所以exec()的调用除非发生错误否则不会返回控制。</p>
<p>下面显示的C程序演示了先前描述的UNIX系统调用。现在我们有两个运行相同程序的不同进程。唯一的区别是子进程的pid（进程标识符）的值为零，而父进程的值为大于零的整数（实际上，它是子进程的实际pid）。子进程从父进程继承特权和调度属性，以及某些资源，如打开的文件。然后，子进程使用execlp()系统调用（execlp()是exec()系统调用的一种版本）命令/bin/ls覆盖其地址空间。父进程等待子进程完成，使用wait()系统调用。当子进程完成（通过隐式或显式调用exit()）时，父进程从wait()调用处恢复，然后使用exit()系统调用完成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    pid t pid;</span><br><span class="line">    <span class="comment">/* fork a child process */</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123; <span class="comment">/* error occurred */</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Fork Failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">/* child process */</span></span><br><span class="line">    	execlp(<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">/* parent process */</span></span><br><span class="line">        <span class="comment">/* parent will wait for the child to complete */</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child Complete&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/BlackForest1990/Mypic/img/img/%E8%BF%9B%E7%A8%8B-fork.png" alt></p>
<p>某些系统中(UNIX)，当进程创建了另一个进程后，父进程和子进程就以某种形式继续保持关联。子进程自身可以创建更多的进程，组成一个进程的树形结构。进程和它的所有子女以及后裔共同组成一个进程组。当用户从键盘发出一个信号时，该信号被送给当前与键盘相关的进程组中的所有成员（它们通常是在当前窗口创建的所有活动进程）。每个进程可以分别捕获该信号、忽略该信号或采取默认的动作，即被该信号杀死。</p>
<p>下图展示了Linux操作系统的典型进程树，显示了每个进程及其PID（进程标识符）的名称。在这里我们使用术语“进程”比较宽泛，因为Linux更倾向于使用task。init进程（始终具有PID 1）充当所有用户进程的根父进程。一旦系统启动，init进程还可以创建各种用户进程，如Web服务器、打印服务器、SSH服务器等。我们看到init的两个子进程是kthreadd和sshd。kthreadd进程负责创建代表内核执行任务的其他进程（在这种情况下是khelper和pdflush）。sshd进程负责管理通过SSH（安全外壳）连接到系统的客户端。登录进程负责管理直接登录到系统的客户端。在这个示例中，一个客户端已经登录并正在使用bash shell，其分配的PID为8416。使用bash命令行接口，该用户创建了进程ps和emacs编辑器。</p>
<img src="https://raw.githubusercontent.com/BlackForest1990/Mypic/img/img/Linux%E8%BF%9B%E7%A8%8B%E6%A0%91.PNG" style="zoom:40%;">
<h3 id="进程的终止">进程的终止</h3>
<p>一个进程在执行完最后一条语句并通过使用 exit() 系统调用请求操作系统删除它时终止。在这一刻，进程可以通过 wait() 系统调用向其父进程返回一个状态值（通常是一个整数）。进程的所有资源，包括物理和虚拟内存、打开的文件以及I/O缓冲区，都会被操作系统释放。</p>
<p>终止也可能发生在其他情况下。一个进程可以通过适当的系统调用（例如在Windows中的TerminateProcess()）引发另一个进程的终止。通常，这样的系统调用只能由要终止的进程的父进程调用。否则，用户可以任意终止彼此的任务。请注意，如果父进程要终止子进程，<strong>父进程需要知道子进程的标识</strong>。因此，当一个进程创建一个新的进程时，新创建的进程的标识会传递给父进程。</p>
<p>父进程可能出于多种原因终止其子进程的执行：</p>
<ul>
<li>子进程已经超出了其被分配的一些资源的使用限制。（要确定是否发生了这种情况，父进程必须有一种机制来检查其子进程的状态。）</li>
<li>分配给子进程的任务不再需要执行。</li>
<li>父进程正在退出，而如果其父进程终止，操作系统不允许子进程继续执行。</li>
</ul>
<p>在一些系统中，如果一个进程的父进程终止，那么该进程就不能存在。在这种系统中，如果一个进程终止（无论是正常还是异常终止），那么它的所有子进程也必须被终止。这种现象被称为<strong>级联终止</strong>，通常由操作系统启动。</p>
<p>为了说明进程的执行和终止，在Linux和UNIX系统中，我们可以使用 <code>exit()</code> 系统调用来终止一个进程，并提供一个退出状态作为参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* exit with status 1 */</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>实际上，在正常终止情况下，exit() 可以直接调用（如上所示）或间接调用（通过 main() 函数中的返回语句）。</p>
<p>父进程可以通过使用 wait() 系统调用等待子进程的终止。wait() 系统调用接受一个参数，允许父进程获取子进程的退出状态。此系统调用还返回终止的子进程的进程标识符，以便父进程可以知道其哪个子进程已经终止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pid t pid;</span><br><span class="line"><span class="type">int</span> status;</span><br><span class="line">pid = wait(&amp;status);</span><br></pre></td></tr></table></figure>
<p>当一个进程终止时，其资源由操作系统释放。然而，它在进程表中的条目必须一直保留，直到父进程调用 wait()，因为进程表包含了进程的退出状态。一个已经终止但其父进程尚未调用 wait() 的进程被称为<strong>僵尸进程</strong>。所有进程在终止时都会过渡到这个状态，但通常它们只会短暂存在。一旦父进程调用了 wait()，僵尸进程的进程标识符和其在进程表中的条目就会被释放。</p>
<p>现在考虑一下，如果父进程没有调用 wait() 而是终止了，从而使其子进程成为孤儿进程，会发生什么情况。Linux 和 UNIX 通过将 init 进程指定为孤儿进程的新父进程来解决这种情况。init 进程定期调用 wait()，从而允许收集任何孤儿进程的退出状态，并释放孤儿进程的进程标识符和进程表条目。</p>
<h2 id="进程间通信">进程间通信</h2>
<p>提供允许进程合作的环境有几个原因：</p>
<ul>
<li>信息共享。由于可能有多个用户对同一信息感兴趣（例如共享文件），我们必须提供一种环境，允许对这样的信息进行并发访问。</li>
<li>计算加速。如果我们希望某个任务运行得更快，我们必须将其分解为子任务，每个子任务将与其他子任务并行执行。请注意，只有计算机具有多个处理核心时，才能实现这样的加速。</li>
<li>模块化。我们可能希望以模块化的方式构建系统，将系统功能划分为独立的进程或线程。</li>
<li>方便。即使是单个用户也可能同时处理许多任务。例如，用户可能同时进行编辑、听音乐和编译。</li>
</ul>
<p>合作进程需要一种进程间通信（IPC）机制，使它们能够交换数据和信息。有两种基本的进程间通信模型：共享内存和消息传递。在共享内存模型中，建立了由合作进程共享的内存区域。进程可以通过读写数据到共享区域来交换信息。在消息传递模型中，通信通过合作进程之间交换的消息进行。</p>
<img src="https://raw.githubusercontent.com/BlackForest1990/Mypic/img/img/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B%E5%AF%B9%E6%AF%94.png" style="zoom:30%;">
<p>这两种模型在操作系统中都很常见，许多系统都同时实现了它们。消息传递对于交换较小量的数据很有用，因为不需要避免冲突。在分布式系统中，消息传递也比共享内存更容易实现。共享内存可能比消息传递更快，因为消息传递系统通常是通过系统调用实现的，因此需要更耗时的内核干预。在共享内存系统中，只有在建立共享内存区域时才需要系统调用。一旦共享内存建立，所有访问都被视为常规内存访问，不需要内核的帮助。</p>
<p>最近对具有多个处理核心的系统进行的研究表明，在这些系统上，消息传递提供了比共享内存更好的性能。共享内存存在缓存一致性问题，因为共享数据在多个缓存之间迁移。<strong>随着系统上处理核心数量的增加，我们可能会看到消息传递作为IPC的首选机制</strong>。</p>
<blockquote>
<p><strong>多进程架构 — Chrome 浏览器</strong></p>
<p>许多网站包含诸如 JavaScript、Flash 和 HTML5 等主动内容，以提供丰富而动态的网页浏览体验。不幸的是，这些 Web 应用程序也可能包含软件缺陷，这可能导致响应时间变慢，甚至导致 Web 浏览器崩溃。在仅显示来自一个网站的内容的 Web 浏览器中，这并不是一个大问题。但是，大多数现代 Web 浏览器提供标签式浏览，允许单个 Web 浏览器应用程序同时打开多个网站，每个站点在单独的标签中。用户只需点击相应的标签即可在不同的站点之间切换。这种排列如下图所示：</p>
<img src="https://raw.githubusercontent.com/BlackForest1990/Mypic/img/img/%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8.PNG" style="zoom:60%;">
<p>这种方法的一个问题是，如果任何一个标签中的 Web 应用程序崩溃，整个进程，包括显示其他网站的所有其他标签，也会崩溃。谷歌的 Chrome Web 浏览器通过采用多进程架构来解决这个问题。Chrome 将进程分为三种类型：浏览器、渲染器和插件。</p>
<ul>
<li><strong>浏览器进程</strong> 负责管理用户界面以及磁盘和网络 I/O。在启动 Chrome 时会创建一个新的浏览器进程。只会创建一个浏览器进程。</li>
<li><strong>渲染器进程</strong> 包含用于呈现网页的逻辑。因此，它们包含处理 HTML、JavaScript、图像等的逻辑。通常情况下，每个在新标签中打开的网站都会创建一个新的渲染器进程，因此可以同时存在多个渲染器进程。</li>
<li><strong>插件进程</strong> 为每种正在使用的插件（如 Flash 或 QuickTime）创建一个进程。插件进程包含插件的代码以及额外的代码，使插件能够与相关的渲染器进程和浏览器进程进行通信。</li>
</ul>
<p>多进程方法的优势在于各个网站之间运行时是隔离的。如果一个网站崩溃，只有它的渲染器进程受到影响，所有其他进程都不受影响。此外，渲染器进程在沙箱中运行，这意味着对磁盘和网络 I/O 的访问受到限制，从而最小化了任何安全漏洞的影响。</p>
</blockquote>
<h3 id="共享内存系统">共享内存系统</h3>
<p>使用共享内存进行进程间通信需要通信的进程建立一个共享内存区域。通常，共享内存区域存在于创建该共享内存段的进程的地址空间中。希望使用这个共享内存段进行通信的其他进程必须将其连接到它们的地址空间。通常情况下，操作系统会阻止一个进程访问另一个进程的内存。共享内存要求两个或多个进程同意解除这个限制。然后，它们可以通过在共享区域中读写数据来交换信息。数据的形式和位置由这些进程决定，并不受操作系统的控制。这些进程还负责确保它们不会同时写入相同的位置。</p>
<p>为了阐述合作进程的概念，让我们考虑一下生产者-消费者问题，这是一种常见的合作进程范例。生产者进程生成由消费者进程消耗的信息。例如，编译器可能生成汇编代码，由汇编器消耗。然后，汇编器可能生成目标模块，由加载器消耗。生产者-消费者问题还为客户端-服务器范式提供了一个有用的隐喻。通常我们将服务器视为生产者，客户端视为消费者。例如，Web 服务器生成（即提供）HTML 文件和图像，而客户端 Web 浏览器请求这些资源并消耗（即读取）它们。</p>
<p>生产者-消费者问题的一个解决方案使用了共享内存。为了允许生产者和消费者进程同时运行，我们必须有一个可以由生产者填充并由消费者清空的项目缓冲区。这个缓冲区将位于由生产者和消费者进程共享的内存区域。生产者可以在消费者正在消耗另一项时生成一项。生产者和消费者必须同步，以确保消费者不会尝试消耗尚未生成的项目。</p>
<p>可以使用两种类型的缓冲区。无界缓冲区对缓冲区的大小没有实际限制。消费者可能必须等待新项目，但生产者始终可以生成新项目。有界缓冲区假定一个固定的缓冲区大小。在这种情况下，如果缓冲区为空，消费者必须等待；如果缓冲区已满，生产者必须等待。</p>
<p>让我们更仔细地看一下有界缓冲区是如何通过共享内存进行进程间通信的。以下变量存在于生产者和消费者进程共享的内存区域中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER SIZE 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">. . .</span><br><span class="line">&#125;item;</span><br><span class="line">item buffer[BUFFER SIZE];</span><br><span class="line"><span class="type">int</span> in = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> out = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>共享缓冲区被实现为一个带有两个逻辑指针（in和out）的循环数组：in指向缓冲区中的下一个空位置；out指向缓冲区中的第一个满位置。当in == out时，缓冲区为空；当((in + 1) % BUFFER SIZE) == out时，缓冲区为满。生产者进程有一个本地变量nextProduced，用于存储要生成的新项。消费者进程有一个本地变量nextConsumed，用于存储要消耗的项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">item next_produced;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">/* produce an item in next produced */</span></span><br><span class="line">    <span class="keyword">while</span> (((in + <span class="number">1</span>) % BUFFER SIZE) == out)</span><br><span class="line">    ; <span class="comment">/* do nothing */</span></span><br><span class="line">    buffer[in] = next_produced;</span><br><span class="line">    in = (in + <span class="number">1</span>) % BUFFER SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">item next consumed;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (in == out)</span><br><span class="line">    ; <span class="comment">/* do nothing */</span></span><br><span class="line">    next_consumed = buffer[out];</span><br><span class="line">    out = (out + <span class="number">1</span>) % BUFFER SIZE;</span><br><span class="line">    <span class="comment">/* consume the item in next consumed */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方案允许在同一时间最多有BUFFER SIZE − 1个项目在缓冲区中。<strong>这个例子未解决的问题是生产者进程和消费者进程同时尝试访问共享缓冲区的情况</strong>。</p>
<blockquote>
<p><strong>An Example: POSIX Shared Memory</strong></p>
<p>在POSIX系统中有多种IPC机制，包括共享内存和消息传递。在这里，我们探讨一下用于共享内存的POSIX API。POSIX共享内存使用内存映射文件进行组织，将共享内存区域与文件关联起来。一个进程首先必须使用shm_open()系统调用创建一个共享内存对象，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shm_fd = shm_open(name, O_CREAT | O_RDWR, <span class="number">0666</span>);</span><br></pre></td></tr></table></figure>
<p>第一个参数指定了共享内存对象的名称。希望访问这个共享内存的进程必须使用这个名称引用对象。后续的参数指定了如果对象不存在就创建它（O_CREAT），并且对象是可读写的（O_RDWR）。最后一个参数设置了共享内存对象的目录权限。对shm_open()的成功调用会返回一个整数文件描述符，用于表示共享内存对象。一旦对象建立，ftruncate()函数被用于配置对象的大小，单位是字节。调用ftruncate(shm_fd, 4096)将对象的大小设置为4096字节。最后，mmap()函数建立了一个包含共享内存对象的内存映射文件，并返回一个指向用于访问共享内存对象的内存映射文件的指针。</p>
<p>生产者创建了一个名为&quot;OS&quot;的共享内存对象，并向共享内存写入了&quot;Hello World!&quot;这个著名的字符串。该程序内存映射了一个指定大小的共享内存对象，并允许对该对象进行写入（显然，对于生产者来说只有写入是必要的）。标志MAP_SHARED指定对共享内存对象的更改将对所有共享该对象的进程可见。注意，我们通过调用sprintf()函数并将格式化的字符串写入指针ptr来写入共享内存对象。在每次写入之后，我们必须将指针按照写入的字节数递增。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* the size (in bytes) of shared memory object */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> SIZE <span class="number">4096</span>;</span><br><span class="line">    <span class="comment">/* name of the shared memory object */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name = <span class="string">&quot;OS&quot;</span>;</span><br><span class="line">    <span class="comment">/* strings written to shared memory */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message <span class="number">0</span> = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message <span class="number">1</span> = <span class="string">&quot;World!&quot;</span>;</span><br><span class="line">    <span class="comment">/* shared memory file descriptor */</span></span><br><span class="line">    <span class="type">int</span> shm_fd;</span><br><span class="line">    <span class="comment">/* pointer to shared memory obect */</span></span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">    <span class="comment">/* create the shared memory object */</span></span><br><span class="line">    shm_fd = shm_open(name, O_CREAT | O_RDRW, <span class="number">0666</span>);</span><br><span class="line">    <span class="comment">/* configure the size of the shared memory object */</span></span><br><span class="line">    ftruncate(shm_fd, SIZE);</span><br><span class="line">    <span class="comment">/* memory map the shared memory object */</span></span><br><span class="line">    ptr = mmap(<span class="number">0</span>, SIZE, PROT_WRITE, MAP_SHARED, shm_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* write to the shared memory object */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(ptr,<span class="string">&quot;%s&quot;</span>,message <span class="number">0</span>);</span><br><span class="line">    ptr += <span class="built_in">strlen</span>(message <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(ptr,<span class="string">&quot;%s&quot;</span>,message <span class="number">1</span>);</span><br><span class="line">    ptr += <span class="built_in">strlen</span>(message <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费者进程读取并输出共享内存的内容。消费者还调用shm_unlink()函数，在消费者访问完共享内存后删除共享内存段。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* the size (in bytes) of shared memory object */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> SIZE <span class="number">4096</span>;</span><br><span class="line">    <span class="comment">/* name of the shared memory object */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name = <span class="string">&quot;OS&quot;</span>;</span><br><span class="line">    <span class="comment">/* shared memory file descriptor */</span></span><br><span class="line">    <span class="type">int</span> shm_fd;</span><br><span class="line">    <span class="comment">/* pointer to shared memory obect */</span></span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">    <span class="comment">/* open the shared memory object */</span></span><br><span class="line">    shm_fd = shm_open(name, O_RDONLY, <span class="number">0666</span>);</span><br><span class="line">    <span class="comment">/* memory map the shared memory object */</span></span><br><span class="line">    ptr = mmap(<span class="number">0</span>, SIZE, PROT_READ, MAP_SHARED, shm_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* read from the shared memory object */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,(<span class="type">char</span> *)ptr);</span><br><span class="line">    <span class="comment">/* remove the shared memory object */</span></span><br><span class="line">    shm_unlink(name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="消息传递系统">消息传递系统</h3>
<p>消息传递提供了一种机制，允许进程在不共享相同地址空间的情况下进行通信和同步它们的操作。在分布式环境中特别有用，其中通信的进程可能驻留在由网络连接的不同计算机上。例如，一个互联网聊天程序可以设计成参与聊天的用户通过交换消息进行通信。</p>
<p>消息传递设施至少提供两个操作： send(message)（发送消息） receive(message)（接收消息）</p>
<p>由进程发送的消息可以是固定大小或可变大小的。如果只能发送固定大小的消息，则系统级实现比较直接。然而，这种限制使编程任务变得更加困难。相反，可变大小的消息需要更复杂的系统级实现，但编程任务变得更简单。这是操作系统设计中经常遇到的一种权衡。</p>
<p>如果进程P和Q想要通信，它们必须相互发送消息并接收消息：它们之间必须存在一种通信链路。这个链接可以以多种方式实现。我们关心的不是链接的物理实现（例如共享内存、硬件总线或网络），而是它的逻辑实现。以下是逻辑实现链接和send()/receive()操作的几种方法：</p>
<ul>
<li>直接或间接通信</li>
<li>同步或异步通信</li>
<li>自动或显式缓冲</li>
</ul>
<h4 id="命名">命名</h4>
<p>进程之间要进行通信，它们必须有一种方式来引用彼此。可以使用直接通信或间接通信。</p>
<p>在直接通信中，每个想要通信的进程必须明确命名通信的接收方或发送方。原语被定义如下：</p>
<ul>
<li>send(P, message) — 向进程 P 发送消息。</li>
<li>receive(Q, message) — 从进程 Q 接收消息。</li>
</ul>
<p>在这个方案中，通信链具有以下属性：</p>
<ul>
<li>每对想要通信的进程之间会自动建立一个连接。进程只需知道对方的身份就可以进行通信。</li>
<li>一个链接与两个进程关联。</li>
<li>每对进程之间存在且仅存在一个链接。</li>
</ul>
<p>这个方案在寻址上表现出对称性，即发送方和接收方都必须命名对方才能进行通信。这个方案的变体采用<strong>非对称</strong>的寻址方式。在这种情况下，只有发送方命名接收方，而不要求接收方命名发送方。原语被定义如下：</p>
<ul>
<li>send(P, message) — 向进程 P 发送消息。</li>
<li>receive(id, message) — 从任何进程接收消息。变量 id 被设置为发生通信的进程的名称。</li>
</ul>
<p>这两种方案（对称和非对称）的缺点是由于生成的进程定义的模块性有限。更改进程标识符可能需要检查所有其他进程定义。必须找到对旧标识符的所有引用，以便可以将它们修改为新标识符。<strong>总的来说，任何这种硬编码技术，在其中标识符必须明确说明的地方，都不如涉及间接寻址的技术更为可取</strong>。</p>
<p>在间接通信中，消息被发送到和从邮箱或端口中接收。**邮箱可以抽象地看作是一个对象，进程可以将消息放入其中，也可以从中移除消息。每个邮箱都有一个唯一的标识。**例如，POSIX 消息队列使用整数值来标识邮箱。一个进程可以通过许多不同的邮箱与另一个进程通信，但只有在它们有一个共享的邮箱时，两个进程才能通信。原语被定义如下：</p>
<ul>
<li>send(A, message) — 向邮箱 A 发送消息。</li>
<li>receive(A, message) — 从邮箱 A 接收消息。</li>
</ul>
<p>在这个方案中，通信链具有以下属性：</p>
<ul>
<li>仅当一对进程都有一个共享的邮箱时，才会在它们之间建立连接。</li>
<li>一个链接可以与多于两个进程关联。</li>
<li>对于每一对通信的进程，可能存在多个不同的链接，每个链接对应一个邮箱。</li>
</ul>
<p>**邮箱可以由进程或操作系统拥有。**如果邮箱由进程拥有（即邮箱是进程的地址空间的一部分），那么我们区分所有者（只能通过这个邮箱接收消息）和用户（只能向邮箱发送消息）。由于每个邮箱都有一个唯一的所有者，所以不会混淆应该接收发送到该邮箱的消息的进程。当拥有邮箱的进程终止时，邮箱消失。随后任何尝试向这个邮箱发送消息的进程都必须得到通知，告诉它该邮箱已经不存在。</p>
<p>相反，由操作系统拥有的邮箱是独立的，不附属于任何特定的进程。操作系统必须提供一种机制，允许进程执行以下操作：</p>
<ul>
<li>创建一个新的邮箱。</li>
<li>通过邮箱发送和接收消息。</li>
<li>删除一个邮箱。 创建新邮箱的进程默认是那个邮箱的所有者。最初，只有所有者可以通过该邮箱接收消息。但是，通过适当的系统调用，所有权和接收权限可以传递给其他进程。当然，这种规定可能导致每个邮箱有多个接收者。</li>
</ul>
<h4 id="同步">同步</h4>
<p>进程之间的通信通过对send()和receive()原语的调用来实现。实现每个原语的方式有不同的设计选项。消息传递可以是阻塞的或非阻塞的，也称为同步和异步。</p>
<ul>
<li>阻塞发送。发送进程被阻塞，直到消息被接收进程或邮箱接收。</li>
<li>非阻塞发送。发送进程发送消息并继续操作。</li>
<li>阻塞接收。接收者被阻塞，直到有消息可用。</li>
<li>非阻塞接收。接收者检索到一个有效的消息或一个空消息。</li>
</ul>
<p>send()和receive()的不同组合是可能的。当send()和receive()都是阻塞的时候，我们有了发送者和接收者之间的汇合。当我们使用阻塞的send()和receive()语句时，生产者-消费者问题的解决方案变得非常简单。生产者只需调用阻塞的send()调用，等待消息被传递给接收者或邮箱。同样，当消费者调用receive()时，它会阻塞，直到有消息可用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">message next_produced;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">/* produce an item in next_produced */</span></span><br><span class="line">    send(next_produced);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message next_consumed;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    receive(next_consumed);</span><br><span class="line">    <span class="comment">/* consume the item in next_consumed */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="缓冲">缓冲</h4>
<p>无论通信是直接还是间接的，由通信进程交换的消息都存在于一个临时队列中。基本上，这样的队列可以通过三种方式实现：</p>
<ul>
<li><strong>零容量（Zero capacity）</strong>：队列的最大长度为零；因此，链接不能有任何等待的消息。在这种情况下，发送方必须阻塞，直到接收方接收到消息。</li>
<li><strong>有界容量（Bounded capacity）</strong>：队列的长度有限，为n；最多可以容纳n条消息。如果在发送新消息时队列没有满，消息将被放入队列中（可以是消息的副本或消息的指针），发送方可以继续执行而无需等待。然而，链接的容量是有限的。如果链接已满，发送方必须阻塞，直到队列中有空间。</li>
<li><strong>无界容量（Unbounded capacity）</strong>：队列的长度是潜在无限的；因此，任意数量的消息都可以在其中等待。发送方永远不会阻塞。</li>
</ul>
<p>零容量的情况有时被称为没有缓冲的消息系统。其他情况被称为具有自动缓冲的系统。</p>
<h2 id="客户端-服务器系统中的通信">客户端-服务器系统中的通信</h2>
<p>在本节中，我们将探讨客户端-服务器系统中通信的另外三种策略：套接字（sockets）、远程过程调用（RPCs）和管道（pipes）。</p>
<h3 id="Sockets">Sockets</h3>
<p>套接字被定义为通信的端点。在网络上通信的一对进程使用一对套接字，每个进程一个。套接字由IP地址和端口号拼接而成。一般来说，套接字采用客户端-服务器体系结构。服务器通过监听指定端口等待传入的客户端请求。一旦接收到请求，服务器接受来自客户端套接字的连接以完成连接。实现特定服务的服务器（例如telnet、FTP和HTTP）监听知名端口（telnet服务器监听端口23；FTP服务器监听端口21；Web或HTTP服务器监听端口80）。所有小于1024的端口都被视为知名端口；我们可以使用它们来实现标准服务。</p>
<p>当客户端进程发起连接请求时，它会被分配一个由其主机计算机指定的端口。此端口具有大于1024的某个任意数字。例如，如果主机X上的具有IP地址146.86.5.20的客户端希望与在地址161.25.19.8上监听端口80的Web服务器建立连接，主机X可能会被分配端口1625。连接将由一对套接字组成：主机X上的(146.86.5.20:1625)和Web服务器上的(161.25.19.8:80)。在主机之间传输的数据包将根据目标端口号传递到适当的进程。</p>
<img src="https://raw.githubusercontent.com/BlackForest1990/Mypic/img/img/%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%9A%E4%BF%A1.png" style="zoom:30%;">
<p>所有连接必须是唯一的。因此，如果主机X上的另一个进程也希望与相同的Web服务器建立另一个连接，它将被分配一个大于1024且不等于1625的端口号。这确保所有连接都由唯一的套接字对组成。</p>
<p>Java提供了三种不同类型的套接字。基于连接的（TCP）套接字使用Socket类实现。无连接的（UDP）套接字使用DatagramSocket类。最后，MulticastSocket类是DatagramSocket类的子类。多播套接字允许将数据发送给多个接收者。</p>
<p>我们的示例描述了一个使用基于连接的TCP套接字的日期服务器。该操作允许客户端从服务器请求当前日期和时间。服务器监听端口6013，尽管端口可以是大于1024的任意任意数字。当接收到连接时，服务器将日期和时间返回给客户端。服务器创建一个指定将监听端口6013的ServerSocket。然后，服务器开始使用accept()方法监听该端口。服务器在accept()方法上阻塞，等待客户端请求连接。当接收到连接请求时，accept()返回一个套接字，服务器可以用来与客户端通信。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateServer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ServerSocket</span> <span class="variable">sock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6013</span>);</span><br><span class="line">                <span class="comment">/* now listen for connections */</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> sock.accept();</span><br><span class="line">                    <span class="type">PrintWriter</span> <span class="variable">pout</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line">                    <span class="title class_">PrintWriter</span>(client.getOutputStream(), <span class="literal">true</span>);</span><br><span class="line">                    <span class="comment">/* write the Date to the socket */</span></span><br><span class="line">                    pout.println(<span class="keyword">new</span> <span class="title class_">java</span>.util.Date().toString());</span><br><span class="line">                    <span class="comment">/* close the socket and resume */</span></span><br><span class="line">                    <span class="comment">/* listening for connections */</span></span><br><span class="line">                    client.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            System.err.println(ioe);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器与套接字通信的详细步骤如下。服务器首先创建一个PrintWriter对象，用于与客户端通信。PrintWriter对象允许服务器使用print()和println()方法向套接字写入输出。服务器进程通过调用println()方法向客户端发送日期。一旦将日期写入套接字，服务器关闭与客户端的套接字，并继续等待更多请求。</p>
<p>客户端通过创建一个套接字并连接到服务器正在监听的端口来与服务器通信。客户端创建一个Socket，并请求与IP地址为127.0.0.1、端口为6013的服务器建立连接。一旦建立连接，客户端可以使用正常的流I/O语句从套接字读取数据。在从服务器接收到日期后，客户端关闭套接字并退出。<strong>IP地址127.0.0.1是一个特殊的IP地址，被称为回环地址</strong>。当计算机引用IP地址127.0.0.1时，它指的是自己。这种机制允许同一主机上的客户端和服务器使用TCP/IP协议进行通信。IP地址127.0.0.1可以替换为运行日期服务器的另一台主机的IP地址。除了IP地址外，还可以使用实际主机名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateClient</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/* make connection to server socket */</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">sock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6013</span>);</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> sock.getInputStream();</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">bin</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line">            <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(in));</span><br><span class="line">            <span class="comment">/* read the date from the socket */</span></span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ( (line = bin.readLine()) != <span class="literal">null</span>)</span><br><span class="line">            System.out.println(line);</span><br><span class="line">            <span class="comment">/* close the socket connection*/</span></span><br><span class="line">            sock.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            System.err.println(ioe);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用套接字进行通信，尽管普遍而高效，被认为是在分布式进程之间进行低级通信的一种形式。其中一个原因是套接字仅允许在通信线程之间交换无结构的字节流。客户端或服务器应用程序有责任对数据施加结构。</p>
<h3 id="远程过程调用">远程过程调用</h3>
<p>远程服务的最常见形式之一是RPC范例，RPC被设计为一种抽象的过程调用机制，用于在具有网络连接的系统之间使用。在许多方面，它类似于IPC机制，并且通常构建在这样的系统之上。然而，在这里，因为我们处理的是进程在不同系统上执行的环境，我们必须使用基于消息的通信方案来提供远程服务。</p>
<p>与IPC消息不同，RPC通信中交换的消息是结构良好的，因此不再只是数据包。每个消息都寻址到监听远程系统上某个端口的RPC守护程序，并且每个消息都包含一个标识符，指定要执行的函数以及传递给该函数的参数。然后按照请求执行函数，并将任何输出发送回请求者，以独立的消息形式。</p>
<p>端口只是包含在消息数据包开头的一个数字。虽然系统通常只有一个网络地址，但它可以在该地址内有多个端口，以区分它支持的许多网络服务。如果远程进程需要一个服务，它会将消息寻址到适当的端口。例如，如果一个系统希望允许其他系统能够列出其当前用户，它将具有支持这样一个RPC的守护程序，附加到一个端口上，比如端口3027。任何远程系统都可以通过向服务器的端口3027发送RPC消息来获取所需的信息（即当前用户列表）。数据将在回复消息中接收到。</p>
<p>RPC的语义允许客户端调用远程主机上的过程，就像在本地调用过程一样。<strong>RPC系统通过在客户端侧提供一个存根来隐藏允许通信发生的细节</strong>。通常，每个单独的远程过程都有一个单独的存根。当客户端调用远程过程时，RPC系统调用适当的存根，将提供给远程过程的参数传递给它。该存根定位服务器上的端口并对参数进行编组。参数编组涉及将参数封装为可以通过网络传输的形式。然后，存根使用消息传递向服务器发送消息。服务器端的类似存根接收此消息并在服务器上调用该过程。如果需要，返回值将使用相同的技术传递回客户端。在Windows系统上，存根代码是从使用Microsoft Interface Definition Language（MIDL）编写的规范中编译出来的，该语言用于定义客户端和服务器程序之间的接口。</p>
<p><strong>必须处理的一个问题涉及客户端和服务器机器上数据表示的差异</strong>。考虑32位整数的表示。一些系统（称为big-endian）首先存储最高有效字节，而其他系统（称为little-endian）首先存储最低有效字节。在计算机体系结构内，两种顺序都没有本质的“更好”之分；相反，选择在计算机体系结构内是任意的。为了解决这样的差异，许多RPC系统定义了数据的机器无关表示。其中一种表示被称为外部数据表示（XDR）。在客户端侧，参数编组涉及在将数据发送到服务器之前将机器相关的数据转换为XDR。在服务器端，XDR数据进行解组，并转换为服务器的机器相关表示。</p>
<p>另一个重要问题涉及调用的语义。而本地过程调用仅在极端情况下失败，RPC可能会因为常见网络错误而失败，或者被重复执行多次。解决这个问题的一种方法是让操作系统确保消息仅被执行一次，而不是至多一次。大多数本地过程调用具有“仅一次”功能，但实现起来更为困难。</p>
<p>首先，考虑“至多一次”。这种语义可以通过将时间戳附加到每个消息上来实现。<strong>服务器必须保留其已处理的所有消息的时间戳历史记录，或者历史记录足够大，以确保检测到重复的消息</strong>。具有已在历史记录中的时间戳的传入消息将被忽略。然后，客户端可以发送一条或多条消息，并确保它只执行一次。</p>
<p>对于“仅一次”，我们需要消除服务器永远不会接收到请求的风险。为了实现这一点，服务器必须实现上述“至多一次”协议，但还必须向客户端确认已接收和执行了RPC调用。这些ACK消息在整个网络中都很常见。客户端必须定期重新发送每个RPC调用，直到收到该调用的ACK为止。</p>
<p>另一个重要问题涉及服务器和客户端之间的通信。**在标准过程调用中，通常在链接、加载或执行时间发生某种绑定，以便过程调用的名称被过程调用的内存地址替换。**RPC方案要求对客户端和服务器端口进行类似的绑定，但是客户端如何知道服务器上的端口号呢？由于它们不共享内存，因此两个系统都没有关于对方的完整信息。</p>
<p>有两种常见的方法。首先，绑定信息可以是预先确定的，以固定的端口地址的形式存在。在编译时，RPC调用与其关联的固定端口号。一旦程序被编译，服务器就不能更改所请求服务的端口号。其次，可以通过会合机制动态地进行绑定。通常，在固定的RPC端口上提供一个会合守护程序。然后，客户端发送一个包含所需执行的RPC的名称的消息给会合守护程序，请求该RPC的端口地址。返回端口号后，就可以将RPC调用发送到该端口，直到该进程终止（或服务器崩溃）。这种方法需要初始请求的额外开销，但比第一种方法更灵活。</p>
<img src="https://raw.githubusercontent.com/BlackForest1990/Mypic/img/img/RPC.png" style="zoom:30%;">
<p>RPC方案在实现分布式文件系统时非常有用。这样的系统可以作为一组RPC守护程序和客户端来实现。消息寻址到服务器上将执行文件操作的分布式文件系统端口。消息包含要执行的磁盘操作。磁盘操作可能是读取、写入、重命名、删除或状态，对应于常见的文件相关系统调用。返回消息包含由客户端的DFS守护程序代表客户端执行的该调用产生的任何数据。例如，一条消息可能包含一个请求将整个文件传输给客户端，也可能仅限于简单的块请求。在后一种情况下，如果要传输整个文件，可能需要多次请求。</p>
<h3 id="管道">管道</h3>
<p>管道允许两个进程进行通信。在早期的UNIX系统中，管道是最早的IPC机制之一。它们通常为进程相互通信提供了较为简单的方式，尽管它们也有一些局限性。在实现管道时，需要考虑四个问题：</p>
<ol>
<li>管道是否允许双向通信，还是通信是单向的？</li>
<li>如果允许双向通信，它是半双工的（数据只能单向传输）还是全双工的（数据可以同时在两个方向传输）？</li>
<li>通信进程之间是否必须存在某种关系（如父子关系）？</li>
<li>管道是否可以在网络上通信，还是通信进程必须位于同一台机器上？</li>
</ol>
<h4 id="普通管道">普通管道</h4>
<p>普通管道允许两个进程以标准的生产者-消费者方式进行通信：生产者向管道的一端写入（写端），而消费者从另一端读取（读端）。**因此，普通管道是单向的，只允许单向通信。**如果需要双向通信，必须使用两个管道，每个管道在不同的方向发送数据。接下来，我们将演示如何在UNIX上构建普通管道。在这两个程序示例中，一个进程向管道写入消息“Greetings”，而另一个进程从管道中读取这条消息。</p>
<p>在UNIX系统上，使用函数pipe(int fd[])构建普通管道。这个函数创建一个通过int fd[]文件描述符访问的管道：fd[0]是管道的读端fd[1]是写端。UNIX将管道视为一种特殊类型的文件，因此可以使用普通的read()和write()系统调用访问管道。</p>
<p>普通管道无法从创建它的进程外部访问。通常，父进程创建一个管道，并使用它与通过fork()创建的子进程进行通信。下图说明了文件描述符fd与父进程和子进程之间的关系。</p>
<img src="https://raw.githubusercontent.com/BlackForest1990/Mypic/img/img/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%92%8C%E7%AE%A1%E9%81%93%E7%9A%84%E5%85%B3%E7%B3%BB.PNG" style="zoom:50%;">
<p>在下面的UNIX程序中，父进程创建了一个管道，然后调用fork()创建子进程。在fork()调用之后发生的事情取决于数据如何通过管道流动。在这个示例中，父进程写入管道，而子进程从管道中读取。重要的是要注意，父进程和子进程最初都关闭了他们未使用的管道端。这是一个重要的步骤，以确保从管道读取的进程能够检测到文件末尾（read()返回0），当写入端关闭其端口时。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 25</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ_END 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE_END 1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> write msg[BUFFER_SIZE] = <span class="string">&quot;Greetings&quot;</span>;</span><br><span class="line">    <span class="type">char</span> read msg[BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create the pipe */</span></span><br><span class="line">    <span class="keyword">if</span> (pipe(fd) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Pipe failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* fork a child process */</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123; <span class="comment">/* error occurred */</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Fork Failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123; <span class="comment">/* parent process */</span></span><br><span class="line">        <span class="comment">/* close the unused end of the pipe */</span></span><br><span class="line">        close(fd[READ_END]);</span><br><span class="line">        <span class="comment">/* write to the pipe */</span></span><br><span class="line">        write(fd[WRITE_END], write msg, <span class="built_in">strlen</span>(write msg)+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">/* close the write end of the pipe */</span></span><br><span class="line">        close(fd[WRITE_END]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">/* child process */</span></span><br><span class="line">        <span class="comment">/* close the unused end of the pipe */</span></span><br><span class="line">        close(fd[WRITE_END]);</span><br><span class="line">        <span class="comment">/* read from the pipe */</span></span><br><span class="line">        read(fd[READ_END], read msg, BUFFER SIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read %s&quot;</span>,read msg);</span><br><span class="line">        <span class="comment">/* close the write end of the pipe */</span></span><br><span class="line">        close(fd[READ_END]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，普通管道在UNIX系统上都要求通信进程之间存在父-子关系。这意味着这些管道只能用于在同一台机器上的进程之间进行通信。</p>
<h4 id="命名管道">命名管道</h4>
<p>普通管道提供了一个简单的机制，允许一对进程进行通信。然而，普通管道只存在于进程在彼此通信时。在UNIX系统上，一旦进程完成通信并终止，普通管道就会停止存在。命名管道提供了一种更强大的通信工具。通信可以是双向的，并且不需要父子关系。一旦建立了命名管道，多个进程可以使用它进行通信。事实上，在典型情况下，一个命名管道可能有多个写入者。此外，命名管道在通信进程完成后仍然存在。</p>
<p>在UNIX系统中，命名管道被称为FIFO（先进先出）。一旦创建，它们会在文件系统中显示为典型的文件。可以使用mkfifo()系统调用创建FIFO，并使用普通的open()、read()、write()和close()系统调用对其进行操作。它将继续存在，直到在文件系统中明确删除为止。虽然FIFO允许双向通信，<strong>但通常只允许半双工传输</strong>。如果数据必须在两个方向上传输，通常会使用两个FIFO。此外，通信进程必须驻留在同一台机器上。如果需要跨机器通信，则必须使用套接字。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blackforest1990.github.io">BlackForest1990</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blackforest1990.github.io/2023/11/28/%E8%BF%9B%E7%A8%8B/">https://blackforest1990.github.io/2023/11/28/%E8%BF%9B%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blackforest1990.github.io" target="_blank">黑暗森林</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">进程管理</a></div><div class="post_share"><div class="social-share" data-image="/image/blackforest.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>谢谢支持</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechatpay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechatpay.jpg"/></a><div class="post-qr-code-desc"></div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/11/29/how-to-make-money/" title="how to make money"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">how to make money</div></div></a></div><div class="next-post pull-right"><a href="/2023/11/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%AF%BC%E8%AE%BA/" title="操作系统原理导论"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">操作系统原理导论</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/01/03/CPU%E8%B0%83%E5%BA%A6/" title="CPU调度"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-01-19</div><div class="title">CPU调度</div></div></a></div><div><a href="/2024/02/19/deadlock/" title="deadlock"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-02-19</div><div class="title">deadlock</div></div></a></div><div><a href="/2023/12/05/%E7%BA%BF%E7%A8%8B/" title="线程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-12-29</div><div class="title">线程</div></div></a></div><div><a href="/2023/12/11/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/" title="进程同步"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-12-29</div><div class="title">进程同步</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">1.1.</span> <span class="toc-text">进程状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">1.2.</span> <span class="toc-text">进程控制块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.3.</span> <span class="toc-text">Linux中的进程表示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">2.</span> <span class="toc-text">进程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E9%98%9F%E5%88%97"><span class="toc-number">2.1.</span> <span class="toc-text">调度队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.2.</span> <span class="toc-text">调度程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">2.3.</span> <span class="toc-text">上下文切换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%93%8D%E4%BD%9C"><span class="toc-number">3.</span> <span class="toc-text">进程操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-number">3.1.</span> <span class="toc-text">进程创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2"><span class="toc-number">3.2.</span> <span class="toc-text">进程的终止</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">4.</span> <span class="toc-text">进程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.1.</span> <span class="toc-text">共享内存系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.2.</span> <span class="toc-text">消息传递系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E5%90%8D"><span class="toc-number">4.2.1.</span> <span class="toc-text">命名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5"><span class="toc-number">4.2.2.</span> <span class="toc-text">同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2"><span class="toc-number">4.2.3.</span> <span class="toc-text">缓冲</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">5.</span> <span class="toc-text">客户端-服务器系统中的通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Sockets"><span class="toc-number">5.1.</span> <span class="toc-text">Sockets</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="toc-number">5.2.</span> <span class="toc-text">远程过程调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-number">5.3.</span> <span class="toc-text">管道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%AE%A1%E9%81%93"><span class="toc-number">5.3.1.</span> <span class="toc-text">普通管道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-number">5.3.2.</span> <span class="toc-text">命名管道</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By BlackForest1990</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">如果只允许一种声音存在，那么，唯一存在的那个声音就是谎言。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>